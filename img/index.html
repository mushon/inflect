<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/svg+xml" sizes="any" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üñºÔ∏è</text></svg>"/>
    <title>Inflective Image Viewer</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            background: #000;
        }
        canvas {
            display: block;
            cursor: grab;
        }
    </style>
</head>
<body>
    <canvas id="imageViewer"></canvas>
    <script>
        const canvas = document.getElementById('imageViewer');
        const ctx = canvas.getContext('2d');
        const pixelRatio = window.devicePixelRatio || 1;

        let image = new Image();
        let view = { topLeft: [0, 0], bottomRight: [0, 0] };
        let isDragging = false;
        let isDrawing = false;
        let startDrag = null;
        const ANIMATION_DURATION = 500;
        
        function parseHash() {
            const hash = location.hash.slice(1);
            if (!hash) return null;
            const [params, url] = hash.includes('&') ? hash.split('&') : [null, hash];
            const coords = params ? params.split(',').map(Number).map(Math.floor) : null;
            return { url, coords };
        }

        function updateHash(url, view) {
            const { topLeft, bottomRight } = view;
            location.hash = `${topLeft.map(Math.floor).join(',')},${bottomRight.map(Math.floor).join(',')}&${url}`;
        }

        function fitViewToCanvas(image) {
            const scaleX = canvas.width / image.width;
            const scaleY = canvas.height / image.height;
            const scale = Math.min(scaleX, scaleY);

            const displayWidth = image.width * scale;
            const displayHeight = image.height * scale;

            const offsetX = (canvas.width - displayWidth) / 2;
            const offsetY = (canvas.height - displayHeight) / 2;

            view.topLeft = [-offsetX / scale, -offsetY / scale];
            view.bottomRight = [(image.width + offsetX / scale), (image.height + offsetY / scale)];
        }

        function render() {
            // Set the canvas size for Retina displays
            canvas.width = Math.floor(window.innerWidth * pixelRatio);
            canvas.height = Math.floor(window.innerHeight * pixelRatio);

            // Ensure the canvas is displayed at the correct size
            canvas.style.width = `${window.innerWidth}px`;
            canvas.style.height = `${window.innerHeight}px`;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Scale the context for Retina displays
            ctx.save();
            ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);

            const { topLeft, bottomRight } = view;
            const zoomWidth = bottomRight[0] - topLeft[0];
            const zoomHeight = bottomRight[1] - topLeft[1];
            const scale = Math.min(
                canvas.width / pixelRatio / zoomWidth,
                canvas.height / pixelRatio / zoomHeight
            );

            ctx.translate(
                canvas.width / pixelRatio / 2 - (topLeft[0] + zoomWidth / 2) * scale,
                canvas.height / pixelRatio / 2 - (topLeft[1] + zoomHeight / 2) * scale
            );
            ctx.scale(scale, scale);
            ctx.drawImage(image, 0, 0);

            ctx.restore();
        }

        function animateView(targetView) {
            const startView = { ...view };
            const startTime = performance.now();

            function animate(time) {
                const progress = Math.min((time - startTime) / ANIMATION_DURATION, 1);
                view.topLeft[0] = Math.floor(startView.topLeft[0] + progress * (targetView.topLeft[0] - startView.topLeft[0]));
                view.topLeft[1] = Math.floor(startView.topLeft[1] + progress * (targetView.topLeft[1] - startView.topLeft[1]));
                view.bottomRight[0] = Math.floor(startView.bottomRight[0] + progress * (targetView.bottomRight[0] - startView.bottomRight[0]));
                view.bottomRight[1] = Math.floor(startView.bottomRight[1] + progress * (targetView.bottomRight[1] - startView.bottomRight[1]));

                render();

                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }

            requestAnimationFrame(animate);
        }

        function updateView(coords, animate = false) {
            if (coords) {
                const targetView = {
                    topLeft: coords.slice(0, 2).map(Math.floor),
                    bottomRight: coords.slice(2, 4).map(Math.floor),
                };

                if (animate) {
                    animateView(targetView);
                } else {
                    view = targetView;
                    render();
                }
            } else {
                fitViewToCanvas(image);
                render();
            }
        }

        function loadImage(url) {
            image.onload = () => {
                if (!location.hash || !parseHash().coords) {
                    fitViewToCanvas(image);
                }
                render();
            };
            image.src = url;
        }

        function setupInteractions() {
            canvas.addEventListener('mousedown', (e) => {
                if (window.self !== window.top) return;                

                isDragging = true;
                canvas.style.cursor = 'grabbing';
                startDrag = [e.clientX, e.clientY];
            });

            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    // Adjust the drag distances for the pixel ratio
                    const dx = ((startDrag[0] - e.clientX) * (view.bottomRight[0] - view.topLeft[0])) / (canvas.width / pixelRatio);
                    const dy = ((startDrag[1] - e.clientY) * (view.bottomRight[1] - view.topLeft[1])) / (canvas.height / pixelRatio);

                    // Update the view coordinates
                    view.topLeft[0] = Math.floor(view.topLeft[0] + dx);
                    view.topLeft[1] = Math.floor(view.topLeft[1] + dy);
                    view.bottomRight[0] = Math.floor(view.bottomRight[0] + dx);
                    view.bottomRight[1] = Math.floor(view.bottomRight[1] + dy);

                    // Update the startDrag position
                    startDrag = [e.clientX, e.clientY];

                    render();
                }
            });

            canvas.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    canvas.style.cursor = 'grab';
                    updateHash(image.src, view);
                }
            });

            canvas.addEventListener('wheel', (e) => {
                if (window.self !== window.top) return;
                e.preventDefault();
                
                const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;

                // Adjust pointer position to account for pixel ratio
                const pointerX = (e.clientX * pixelRatio) / canvas.width;
                const pointerY = (e.clientY * pixelRatio) / canvas.height;

                const centerX = view.topLeft[0] + pointerX * (view.bottomRight[0] - view.topLeft[0]);
                const centerY = view.topLeft[1] + pointerY * (view.bottomRight[1] - view.topLeft[1]);

                const zoomWidth = (view.bottomRight[0] - view.topLeft[0]) * zoomFactor;
                const zoomHeight = (view.bottomRight[1] - view.topLeft[1]) * zoomFactor;

                view.topLeft = [
                    Math.floor(centerX - zoomWidth * pointerX),
                    Math.floor(centerY - zoomHeight * pointerY)
                ];
                view.bottomRight = [
                    Math.floor(centerX + zoomWidth * (1 - pointerX)),
                    Math.floor(centerY + zoomHeight * (1 - pointerY))
                ];

                render();
                updateHash(image.src, view);
            });

        }

        window.addEventListener('hashchange', () => {
            const parsed = parseHash();

            if (parsed) {
                const { url, coords } = parsed;
                if (url !== image.src) {
                    loadImage(url);
                }
                const animate = window.self !== window.top;
                updateView(coords, animate);
            }
        });

        window.addEventListener('resize', () => {
            render();
        });

        const parsed = parseHash();
        if (parsed) {
            const { url, coords } = parsed;
            loadImage(url);
            updateView(coords, false);
        } else {
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = '20px Arial';
            ctx.fillText('Please specify an image URL in the hash.', canvas.width / 2, canvas.height / 2);
        }

        setupInteractions();
    </script>
</body>
</html>