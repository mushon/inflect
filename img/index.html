<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0"
  />
  <link
    rel="icon"
    type="image/svg+xml"
    sizes="any"
    href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üñºÔ∏è</text></svg>"
  />
  <title>Inflective Image Viewer</title>
  <style>
    html,
    body {
      font-family: 'HelveticaNeueLight', 'HelveticaNeue-Light',
        'Helvetica Neue Light', 'HelveticaNeue', 'Helvetica Neue',
        TeXGyreHerosRegular, Arial, sans-serif;
      font-weight: 200;
      font-size: calc(0.75vw + 0.75vh);
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
      background: #222;
    }
    canvas {
      display: block;
      cursor: grab;
      z-index: 1;
    }

    /* If inside an iframe, hide the nav and remove the grab cursor */
    body.frame canvas {
      cursor: default;
    }
    body.frame nav {
      display: none;
    }
    /* Hide the layers UI when embedded in an iframe */
    body.frame #layers-panel {
      display: none;
    }

    nav {
      padding: 0.5em;
      background-color: #ccc;
      z-index: 2;
      position: fixed;
      top: 0;
      right: 0;
      text-align: right;
    }
    #color {
      width: 3em;
      height: 2em;
    }
    #box,
    #arr,
    #none {
      margin: 0 1em;
    }
  </style>
</head>
<body>
  <canvas id="imageViewer"></canvas>
  <nav>
    <label for="color">Color</label>
    <input id="color" type="color" value="#ff0000" /><br />
    <label for="arr">Line</label>
    <input type="radio" id="arr" name="tool" value="arrow" /> <br />
    <label for="box">Box</label>
    <input type="radio" id="box" name="tool" value="box" /> <br />
    <label for="none">Pan</label>
    <input
      type="radio"
      id="none"
      name="tool"
      value="none"
      checked
    />
    <br />
    <label for="opacity">Image Opacity</label>
    <input id="opacity" type="range" min="0" max="100" value="100" style="width: 6em; vertical-align: middle;">
    <br />
    <label for="rotate">Rotate</label>
    <input id="rotate" type="range" min="-180" max="180" value="0" style="width:6em; vertical-align: middle;"> 
    <button id="rotate-reset" title="Reset rotation">‚Ü∫</button>
  </nav>

  <!-- Layers UI panel -->
  <aside id="layers-panel" style="position: fixed; left: 0; top: 0; bottom: 0; width: 14em; background: rgba(255,255,255,0.95); padding: 0.5em; overflow:auto; z-index:3;">
    <h3 style="margin:0 0 0.5em 0; font-size:1em;">Layers</h3>
    <div id="layers-list"></div>
    <div style="margin-top:0.5em;">
      <input id="new-layer-url" type="text" placeholder="Image URL or path" style="width:100%; box-sizing:border-box;">
      <button id="add-layer" style="width:100%; margin-top:0.25em;">Add Layer</button>
    </div>
  </aside>


  <script>
    // ---------------------------------------------------------------------
    // Basic Setup
    // ---------------------------------------------------------------------
    const canvas = document.getElementById('imageViewer');
    const ctx = canvas.getContext('2d');
    const colorInput = document.getElementById('color');
    const toolInputs = document.querySelectorAll('input[name="tool"]');
    const opacityInput = document.getElementById('opacity');
    let imageOpacity = 1.0;
    if (opacityInput) {
      // On load, set slider and imageOpacity from hash
      const parsed = parseHash();
      let initialOpacity = 100;
      if (parsed && typeof parsed.opacity === 'number') {
        initialOpacity = parsed.opacity;
      }
      opacityInput.value = initialOpacity;
      imageOpacity = initialOpacity / 100;
      opacityInput.addEventListener('input', () => {
        imageOpacity = parseInt(opacityInput.value, 10) / 100;
        // Update only the opacity field in the hash, preserving all other fields
        const hash = location.hash.slice(1);
        const parts = hash.split('&');
        // If hash is legacy (no &), don't try to update, just use updateHash
        if (parts.length < 5) {
          const parsed = parseHash();
          updateHash(
            parsed && parsed.url ? parsed.url : '',
            parsed && parsed.view ? parsed.view : null,
            parsed && parsed.annotations ? parsed.annotations : {},
            parseInt(opacityInput.value, 10)
          );
        } else {
          // parts: [view/cover/poster, opacity, boxes, lines, url]
          parts[1] = opacityInput.value;
          location.hash = parts.join('&');
        }
        render();
      });
    }

    const pixelRatio = window.devicePixelRatio || 1;
    const inFrame = window.self !== window.top; // Are we in an iframe?

    // If we're in a frame, hide the controls
    if (inFrame) {
      document.body.classList.add('frame');
    }

    let lineWidth =
      (parseInt(window.getComputedStyle(document.body).fontSize, 10) /
        7.5) *
      pixelRatio;
    let interactiveChange = false;

    // The current image (old) and its URL
    let currentUrl = null;
    let image = new Image();
  // layers support: array of {url, opacity, rotation, tx, ty, scale, img, loaded}
  let layers = [];
  // Layers that are in the process of fading out (removed from main layers array)
  let fadingOutLayers = [];
  // Deterministic readiness signal for tests and parents. true when current
  // view (single image or multilayers) has finished loading and initial render.
  window.viewerReady = false;

    // Pan/zoom "view" in image coords
    let view = { topLeft: [0, 0], bottomRight: [0, 0] };

    let isDragging = false;
    let startDrag = null;

  // Rotation in degrees
  let imageRotationDeg = 0;
  // Image drop shadow settings (RGBA, blur, vertical offset in canvas pixels)
  const IMG_SHADOW_COLOR = 'rgba(0,0,0,0.35)';
  const IMG_SHADOW_BLUR = 18;
  const IMG_SHADOW_OFFSET_Y = 8;

    const ANIMATION_DURATION = 1000; // used for pan/zoom if same URL changes

    // Durations for fade out/in
    const FADE_OUT_DURATION = 100;
    const FADE_IN_DURATION = 100;

    // ---------------------------------------------------------------------
    // Animation cancel token
    // ---------------------------------------------------------------------
    // Each time we start a new animation or hashchange, increment this
    // so that older animations exit early if they see the token changed.
    let animationCancelToken = 0;

    // ---------------------------------------------------------------------
    // parseHash / updateHash
    // ---------------------------------------------------------------------
    function parseHash() {
      const hash = location.hash.slice(1);
      if (!hash) return null;

      if (!hash.includes('&')) {
        // If no ampersand is found, assume the hash is just a URL
        // return color as 6-digit hex WITHOUT leading '#'
        return {
          url: hash,
          view: null,
          annotations: { boxes: [], lines: [], color: 'ff0000' },
          poster: false,
          cover: false,
          opacity: 100
        };
      }

  const parts = hash.split('&');
  let viewPart = '';
  let opacityStr = '';
  let boxes = '';
  let lines = '';
  let url = '';
  let rotationStr = '';
  if (parts.length >= 1) viewPart = parts[0];
  if (parts.length >= 2) opacityStr = parts[1];
  if (parts.length >= 3) boxes = parts[2];
  if (parts.length >= 4) lines = parts[3];
  if (parts.length >= 5) url = parts[4];
  if (parts.length >= 6) rotationStr = parts[5];
  // Tolerate a common short form where the final numeric rotation ended up as the
  // 5th part (url slot) because the user supplied fewer &-separated fields.
  // Example: "&&&/img/cover.png&45" => parts.length === 5 and url === '45'.
  if (!rotationStr && url && !isNaN(parseFloat(url))) {
  // detected trailing numeric rotation (shifted fields)
    rotationStr = url;
    // shift fields left so url is what was in the `lines` slot, etc.
    url = lines || '';
    lines = boxes || '';
    boxes = opacityStr || '';
    opacityStr = viewPart || '';
    viewPart = '';
    // fields shifted to recover rotation and url
  }
  // Also tolerate the case where the url token landed in the `lines` slot
  // e.g. the hash was '#&&&/img/cover.png&' so parts[3] contains the url and
  // parts[4] is empty. Detect a path-like lines value and shift left.
  if (!rotationStr && !url && lines && (lines.startsWith('/') || lines.startsWith('http') || lines.indexOf('.png') !== -1 || lines.indexOf('/img/') !== -1)) {
    // detected url token in `lines` slot, shift fields
    url = lines || '';
    lines = boxes || '';
    boxes = opacityStr || '';
    opacityStr = viewPart || '';
    viewPart = '';
    // shifted fields (url-in-lines)
  }
      let color = 'ff0000';
      let opacity = 100;
      // If the second field is a color (legacy), detect and shift
      if (opacityStr && (opacityStr.startsWith('#') || /^[0-9a-fA-F]{6}$/.test(opacityStr))) {
        color = opacityStr;
        opacity = 100;
      } else if (opacityStr && !isNaN(parseInt(opacityStr))) {
        opacity = parseInt(opacityStr, 10);
      }

      // normalize color to 6-digit hex without '#'
      if (typeof color === 'string') {
        color = color.replace(/[^0-9a-fA-F]/g, '').trim();
        if (color.length === 3) color = color.split('').map(c => c + c).join('');
        if (color.length > 6) color = color.slice(0,6);
        if (color.length === 0) color = 'ff0000';
        color = color.toLowerCase();
      } else {
        color = 'ff0000';
      }

      const result = {
        url,
        view: null,
        annotations: { boxes: [], lines: [], color },
        poster: false,
        cover: false,
        opacity,
        rotation: 0,
        layers: []
      };

      if (viewPart === 'poster') {
        result.poster = true;
      } else if (viewPart === 'cover') {
        result.cover = true;
      } else if (viewPart) {
        const coords = viewPart.split(',').map(Number);
        result.view = {
          topLeft: coords.slice(0, 2).map(Math.floor),
          bottomRight: coords.slice(2, 4).map(Math.floor),
        };
      }
      if (boxes) {
        result.annotations.boxes = boxes.split(',').map(Number);
      }
      if (lines) {
        result.annotations.lines = lines.split(',').map(Number);
      }
      if (rotationStr && !isNaN(parseFloat(rotationStr))) {
        result.rotation = parseFloat(rotationStr);
      }

      // Parse layers if the url field contains pipe-separated layer specs
      result.layers = parseLayersFromUrlField(url);
      // Keep result.url as the raw first layer url for backward compatibility
      if (result.layers && result.layers.length > 0) result.url = result.layers[0].url;
      return result;
    }

    // Derive a stable layer id from a URL by using the filename (last path segment).
    function layerIdFromUrl(url) {
      try {
        const u = new URL(String(url), location.origin);
        const path = u.pathname || String(url);
        const segs = path.split('/').filter(Boolean);
        let last = segs.length ? segs[segs.length - 1] : path;
        last = String(last).replace(/[?#].*$/, '');
        try { last = decodeURIComponent(last); } catch (e) {}
        return last || String(url);
      } catch (e) {
        const s = String(url || '');
        const segs = s.split('/').filter(Boolean);
        let last = segs.length ? segs[segs.length - 1] : s;
        last = String(last).replace(/[?#].*$/, '');
        try { last = decodeURIComponent(last); } catch (e) {}
        return last || s;
      }
    }

    // Public helper so parent frames can forward messy hrefs/hashes safely.
    // Accepts strings like '/img/cover.png', full URLs, or a raw href containing
    // the viewer token '&&&...'. Returns true if applied, false otherwise.
    window.acceptViewerHash = function(raw) {
      try {
        if (!raw || typeof raw !== 'string') return false;
        const s = raw.trim();
        const ampIdx = s.indexOf('&&&');
        if (ampIdx !== -1) {
          // extract token after &&& up to next '&'
          const after = s.slice(ampIdx + 3);
          const tokenSegment = after.split('&')[0] || '';
          if (!tokenSegment) return false;
          location.hash = '#&&&' + tokenSegment;
          return true;
        }
        const urlMatch = s.match(/(https?:\/\/[^#\s]+|\/[^#\s]+|[^#\s]+\.(png|jpe?g|gif|webp|svg))/i);
        if (urlMatch && urlMatch[0]) {
          let url = urlMatch[0];
          try {
            const u = new URL(url, location.origin);
            url = u.pathname + (u.search || '');
          } catch (e) {
            // keep raw
          }
          location.hash = '#' + url;
          return true;
        }
        return false;
      } catch (e) {
        return false;
      }
    };

    // Parse a url field into layer specs. Each token is "url[@k=v@k2=v2]" and tokens are pipe-separated.
    // This parser is tolerant: it will split on literal '|' or encoded '%7C', strip any stray
    // fragment identifiers that accidentally landed in the token (e.g. '/img/#-...'), and
    // defensively decode URI components.
    function parseLayersFromUrlField(urlField) {
      if (!urlField) return [];
      const rawStr = String(urlField || '');
      // split on pipe or encoded pipe
      const tokens = rawStr.split(/\||%7C/i).map(t => (t || '').trim()).filter(Boolean);
      const out = [];
      tokens.forEach(tok => {
        // parts after @ are params; first part is raw url token
        const parts = tok.split('@');
        let raw = parts[0] || '';
        // If the token somehow contains a '#' (fragment), strip it off: e.g. '/img/#-...' => '/img/'
        const hashIdx = raw.indexOf('#');
        if (hashIdx !== -1) raw = raw.slice(0, hashIdx);
        // Defensive decode
        let url = raw;
        try {
          url = decodeURIComponent(raw);
        } catch (e) {
          // leave url as raw if decode fails
          url = raw;
        }
        url = String(url).trim();
        if (!url) return; // skip empty

  const layer = { id: layerIdFromUrl(url), url, opacity: 100, rotation: 0, tx: 0.5, ty: 0.5, scale: 1, img: null, loaded: false };
        parts.slice(1).forEach(p => {
          const eq = p.indexOf('=');
          if (eq === -1) return;
          const k = p.slice(0, eq);
          let vRaw = p.slice(eq + 1);
          let v = vRaw;
          try { v = decodeURIComponent(vRaw); } catch (e) { v = vRaw; }
          if (k === 'o') layer.opacity = Number(v);
          else if (k === 'r') layer.rotation = Number(v);
          else if (k === 'x') layer.tx = Number(v);
          else if (k === 'y') layer.ty = Number(v);
          else if (k === 's') layer.scale = Number(v);
        });
        out.push(layer);
      });
      // If any parsed layer looks incomplete (no extension), attempt to recover
      // by scanning the original urlField for image-like paths and using the
      // first suitable match.
      const extRe = /\.(png|jpe?g|gif|webp|svg)$/i;
      const imgMatches = rawStr.match(/\/img\/[^@\|\s#]+?\.(png|jpe?g|gif|webp|svg)/ig) || [];
      const recovered = out.map((l, idx) => {
        if (l && l.url && extRe.test(l.url)) return l;
        // pick same-index match if available, otherwise first match
        const candidate = imgMatches[idx] || imgMatches[0];
        if (candidate) {
          return { ...l, url: candidate };
        }
        return l;
      });
      return recovered.filter(l => l && l.url);
    }

    // Serialize layers back into the url field (pipe-separated)
    function layersToUrlField(layersArr) {
      if (!layersArr || !layersArr.length) return '';
      return layersArr
        .map(l => {
          const parts = [encodeURIComponent(l.url)];
          if (typeof l.opacity === 'number' && l.opacity !== 100) parts.push('o=' + l.opacity);
          if (typeof l.rotation === 'number' && l.rotation !== 0) parts.push('r=' + l.rotation);
          if (typeof l.tx === 'number' && l.tx !== 0.5) parts.push('x=' + l.tx);
          if (typeof l.ty === 'number' && l.ty !== 0.5) parts.push('y=' + l.ty);
          if (typeof l.scale === 'number' && l.scale !== 1) parts.push('s=' + l.scale);
          return parts.join('@');
        })
        .join('|');
    }

    // Preload layers (Image objects). Calls onDone when all complete (or errored).
    // If options.preserveExisting is true, existing Image objects on matching URLs
    // will be reused and only missing images will be loaded.
    function preloadLayers(layersSpec, onDone, options = {}) {
      const preserveExisting = !!options.preserveExisting;
      if (!preserveExisting) {
        layers = layersSpec.map(ls => ({ id: layerIdFromUrl(ls.url), ...ls }));
        window.layers = layers;
      } else {
        // Merge layersSpec with existing layers by URL, preserving img/loaded when present
        const urlToExisting = {};
        (layers || []).forEach(l => { if (l && l.url) urlToExisting[l.url] = l; });
        layers = layersSpec.map(ls => {
          const existing = urlToExisting[ls.url] || {};
          return {
            id: layerIdFromUrl(ls.url),
            url: ls.url,
            opacity: typeof ls.opacity === 'number' ? ls.opacity : (existing.opacity || 100),
            rotation: typeof ls.rotation === 'number' ? ls.rotation : (existing.rotation || 0),
            tx: typeof ls.tx === 'number' ? ls.tx : (existing.tx !== undefined ? existing.tx : 0.5),
            ty: typeof ls.ty === 'number' ? ls.ty : (existing.ty !== undefined ? existing.ty : 0.5),
            scale: typeof ls.scale === 'number' ? ls.scale : (existing.scale !== undefined ? existing.scale : 1),
            img: existing.img || null,
            loaded: existing.loaded || false
          };
        });
        window.layers = layers;
      }

      let remaining = layers.filter(l => !l.loaded).length;
      if (remaining === 0) {
        // ensure legacy image is set
        image = layers[0] && layers[0].img ? layers[0].img : image;
        // reflect serialized url in currentUrl
        currentUrl = layersToUrlField(layers);
        window.layers = layers;
        // mark ready only after images report natural sizes and any initial fades
        setViewerReadyDeferred(layers);
        if (onDone) onDone();
        return;
      }

      layers.forEach((layer, idx) => {
        if (layer.loaded && layer.img) return; // already loaded
        const imgObj = new Image();
        layer.img = imgObj;
        layer.loaded = false;
        imgObj.crossOrigin = 'anonymous';
        imgObj.onload = () => {
          layer.loaded = true;
          remaining--;
          // set primary image for legacy paths
          if (idx === 0) image = imgObj;
          if (remaining <= 0) {
            // all loaded ‚Äî defer readiness until images have measurable sizes / fades
            currentUrl = layersToUrlField(layers);
            window.layers = layers;
            setViewerReadyDeferred(layers);
            if (onDone) onDone();
          }
        };
        imgObj.onerror = () => {
          console.warn('Failed to load layer image', layer.url);
          layer.loaded = false;
          remaining--;
          if (idx === 0) image = imgObj;
          if (remaining <= 0) {
            currentUrl = layersToUrlField(layers);
            window.layers = layers;
            setViewerReadyDeferred(layers);
            if (onDone) onDone();
          }
        };
        imgObj.src = layer.url;
      });
      // reflect serialized url in currentUrl for updateHash compatibility
      currentUrl = layersToUrlField(layers);
    }

    // Apply parsed layers: if URLs changed or count changed, preload; otherwise merge params into existing layers
    function applyParsedLayers(parsedLayers, onDone) {
  // applyParsedLayers: parsedLayers and existing layers info suppressed in normal logs
      if (!parsedLayers || parsedLayers.length === 0) {
        // Fade out all existing layers rather than clearing immediately
        const old = layers || [];
        if (old.length > 0) {
          old.forEach(r => {
            if (!fadingOutLayers.includes(r)) {
              r._animProps = { opacity: r.opacity, rotation: r.rotation, tx: r.tx, ty: r.ty, scale: r.scale, _animAlpha: 1 };
              r._animAlpha = 1;
              fadingOutLayers.push(r);
              tweenProps({ _animAlpha: 1 }, { _animAlpha: 0 }, FADE_OUT_DURATION || 300, v => { r._animAlpha = v._animAlpha; r._animProps._animAlpha = v._animAlpha; }, () => {
                const idx = fadingOutLayers.indexOf(r);
                if (idx !== -1) fadingOutLayers.splice(idx, 1);
              });
            }
          });
        }
        layers = [];
        currentUrl = null;
        if (onDone) onDone();
        return;
      }

      // Decide whether to preload: only preload if parsedLayers introduce any
      // URL not already present in the existing `layers` set. This is robust to
      // reordering and encoding differences.
  const existingUrlsArr = (layers || []).map(l => l && l.url);
  const parsedUrlsArr = (parsedLayers || []).map(p => p && p.url);
  const existingUrls = new Set(existingUrlsArr);
  const parsedUrls = new Set(parsedUrlsArr);
      let needPreload = false;
      for (const u of parsedUrls) {
        if (!existingUrls.has(u)) {
          needPreload = true;
          // missing url -> will preload
          break;
        }
      }
      // If parsedUrls is a strict subset of existingUrls (parsed is shorter but
      // all parsed URLs are present), don't immediately drop existing layers ‚Äî
      // treat it as a params-only update and merge into the existing array.
      const parsedIsSubsetOfExisting = parsedUrlsArr.length > 0 && parsedUrlsArr.every(u => existingUrls.has(u)) && parsedLayers.length < layers.length;
  if (parsedIsSubsetOfExisting) {
        // parsed is subset of existing; we still need to remove layers that
        // are no longer referenced and animate them out, and animate any new
        // ones that may also be present in parsedLayers (edge cases).
        const urlToParsed = {};
        parsedLayers.forEach(p => { if (p && p.url) urlToParsed[p.url] = p; });
        // Determine which existing layers are removed
        const removed = (layers || []).filter(l => l && l.url && !parsedUrls.has(l.url));
        removed.forEach(r => { r._animAlpha = 1; fadingOutLayers.push(r); });
        // Merge parsed params into existing and keep only parsed order
        const oldLayersSnapshot = (layers || []).slice();
        layers = parsedLayers.map(p => {
          const existing = (oldLayersSnapshot || []).find(l => l && l.url === p.url) || {};
          return {
            id: layerIdFromUrl(p.url),
            url: p.url,
            opacity: typeof p.opacity === 'number' ? p.opacity : (existing.opacity !== undefined ? existing.opacity : 100),
            rotation: typeof p.rotation === 'number' ? p.rotation : (existing.rotation !== undefined ? existing.rotation : 0),
            tx: typeof p.tx === 'number' ? p.tx : (existing.tx !== undefined ? existing.tx : 0.5),
            ty: typeof p.ty === 'number' ? p.ty : (existing.ty !== undefined ? existing.ty : 0.5),
            scale: typeof p.scale === 'number' ? p.scale : (existing.scale !== undefined ? existing.scale : 1),
            img: existing.img || null,
            loaded: existing.loaded || false
          };
        });
        window.layers = layers;
  currentUrl = layersToUrlField(layers);
        // If any merged layer isn't loaded yet, preload only the missing images
        const unloaded = layers.filter(l => !l.loaded || !l.img);
        if (unloaded.length > 0) {
          preloadLayers(layers.map(l => ({ url: l.url, opacity: l.opacity, rotation: l.rotation, tx: l.tx, ty: l.ty, scale: l.scale })), () => {
            image = layers[0] && layers[0].img ? layers[0].img : image;
            // Fade-in any newly added ones
            const added = parsedLayers.filter(p => p && p.url && !existingUrls.has(p.url));
            const newlyAdded = (layers || []).filter(l => l && added.find(a => a.url === l.url));
            newlyAdded.forEach(n => { n._animAlpha = 0; const start = performance.now(); const dur = 300; (function step(now) { const t = Math.min((now - start) / dur,1); n._animAlpha = t; render(); if (t<1) requestAnimationFrame(step); })(start); });
            // Fade-out removed ones
            fadingOutLayers.forEach(f => { const start = performance.now(); const dur = 300; (function step(now) { const t = Math.min((now - start) / dur,1); f._animAlpha = 1 - t; render(); if (t<1) requestAnimationFrame(step); else { const idx = fadingOutLayers.indexOf(f); if (idx !== -1) fadingOutLayers.splice(idx,1); } })(start); });
            // start reconcile animation between old and new
            reconcileLayers(oldLayersSnapshot, layers);
            if (onDone) onDone();
          }, { preserveExisting: true });
          return;
        }
        // No preload needed; still animate removed and added layers
        const addedNow = parsedLayers.filter(p => p && p.url && !existingUrls.has(p.url));
        const newlyAddedNow = (layers || []).filter(l => l && addedNow.find(a => a.url === l.url));
        newlyAddedNow.forEach(n => { n._animAlpha = 0; const start = performance.now(); const dur = 300; (function step(now) { const t = Math.min((now - start) / dur,1); n._animAlpha = t; render(); if (t<1) requestAnimationFrame(step); })(start); });
        fadingOutLayers.forEach(f => { const start = performance.now(); const dur = 300; (function step(now) { const t = Math.min((now - start) / dur,1); f._animAlpha = 1 - t; render(); if (t<1) requestAnimationFrame(step); else { const idx = fadingOutLayers.indexOf(f); if (idx !== -1) fadingOutLayers.splice(idx,1); } })(start); });
        // animate diffs
        reconcileLayers(oldLayersSnapshot, layers);
        if (onDone) onDone();
        return;
      }
      // needPreload decision logged only on preload
  if (needPreload) {
        // When preloading due to URL changes, animate removed/added layers
        // Determine removed layers (present in existingUrlsArr but not in parsed)
        const removed = (layers || []).filter(l => l && l.url && !parsedUrls.has(l.url));
        const added = parsedLayers.filter(p => p && p.url && !existingUrls.has(p.url));
        // Move removed layers into fadingOutLayers and start fade animation
        const oldLayersSnapshot = (layers || []).slice();
        removed.forEach(r => {
          // preserve current visual state
          r._animAlpha = 1;
          fadingOutLayers.push(r);
        });
        // Preload new set
        preloadLayers(parsedLayers, () => {
          // After preload, mark newly added layers to fade in
          // Recompute layers variable from newly loaded content
          currentUrl = layersToUrlField(layers);
          window.layers = layers;
          const newlyAdded = (layers || []).filter(l => l && l.url && added.find(a => a.url === l.url));
          newlyAdded.forEach(n => { n._animAlpha = 0; });
          // schedule fade-in animations for new layers
          newlyAdded.forEach(n => {
            const start = performance.now();
            const dur = 300;
            (function step(now) {
              const t = Math.min((now - start) / dur, 1);
              n._animAlpha = t;
              render();
              if (t < 1) requestAnimationFrame(step);
            })(start);
          });
          // start fade-out animations for removed layers and remove them when done
          fadingOutLayers.forEach(f => {
            const start = performance.now();
            const dur = 300;
            (function step(now) {
              const t = Math.min((now - start) / dur, 1);
              f._animAlpha = 1 - t;
              render();
              if (t < 1) requestAnimationFrame(step);
              else {
                // remove from fadingOutLayers
                const idx = fadingOutLayers.indexOf(f);
                if (idx !== -1) fadingOutLayers.splice(idx, 1);
              }
            })(start);
          });
          // reconcile props between old snapshot and new layers
          reconcileLayers(oldLayersSnapshot, layers);
          if (onDone) onDone();
        });
        return;
        return;
      }

  // No full preload needed: merge parsed params with existing layers by URL.
      // This keeps existing Image objects and loaded flags stable even if tokens
      // were reordered or encoded differently.
      const oldLayersSnapshot = (layers || []).slice();
      const urlToExisting = {};
      layers.forEach((l, idx) => {
        if (l && l.url) urlToExisting[l.url] = { img: l.img, loaded: l.loaded, opacity: l.opacity, rotation: l.rotation, tx: l.tx, ty: l.ty, scale: l.scale };
      });
      layers = parsedLayers.map((p) => {
        const existing = urlToExisting[p.url] || {};
        return {
          id: layerIdFromUrl(p.url),
          url: p.url,
          opacity: typeof p.opacity === 'number' ? p.opacity : (existing.opacity !== undefined ? existing.opacity : 100),
          rotation: typeof p.rotation === 'number' ? p.rotation : (existing.rotation !== undefined ? existing.rotation : 0),
          tx: typeof p.tx === 'number' ? p.tx : (existing.tx !== undefined ? existing.tx : 0.5),
          ty: typeof p.ty === 'number' ? p.ty : (existing.ty !== undefined ? existing.ty : 0.5),
          scale: typeof p.scale === 'number' ? p.scale : (existing.scale !== undefined ? existing.scale : 1),
          img: existing.img || null,
          loaded: existing.loaded || false
        };
      });
  currentUrl = layersToUrlField(layers);
      // If any merged layer isn't loaded yet, preload only the missing images
      const unloaded = layers.filter(l => !l.loaded || !l.img);
      if (unloaded.length > 0) {
        // Call preloadLayers with preserveExisting so existing Image objects are kept
        preloadLayers(layers.map(l => ({ url: l.url, opacity: l.opacity, rotation: l.rotation, tx: l.tx, ty: l.ty, scale: l.scale })), () => {
          // After targeted preload, ensure primary image and view are correct
          image = layers[0] && layers[0].img ? layers[0].img : image;
          // reconcile props
          reconcileLayers(oldLayersSnapshot, layers);
          if (onDone) onDone();
        }, { preserveExisting: true });
        return;
      }
      // finalize by reconciling (no preload path)
      reconcileLayers(oldLayersSnapshot, layers);
      if (onDone) onDone();
    }

    function updateHash(url, theView, annotations = {}, opacity = 100, rotation = undefined) {
      interactiveChange = true;
      const defaultAnnotations = {
        boxes: [],
        lines: [],
        color: '#ff0000',
      };
      annotations = { ...defaultAnnotations, ...annotations };

      const viewParams = theView
        ? `${theView.topLeft.map(Math.floor).join(',')},${theView.bottomRight
            .map(Math.floor)
            .join(',')}`
        : '';

  let color = annotations.color || 'ff0000';
      if (color.startsWith('#')) color = color.slice(1);

      const boxParams =
        annotations.boxes.length > 0 ? annotations.boxes.join(',') : '';
      const arrowParams =
        annotations.lines.length > 0 ? annotations.lines.join(',') : '';

      // Opacity is always the second field
      // If rotation wasn't explicitly provided, preserve existing rotation from the hash
      let finalRotation = rotation;
      if (typeof finalRotation === 'undefined') {
        const parsed = parseHash();
        finalRotation = (parsed && typeof parsed.rotation === 'number') ? parsed.rotation : 0;
      }
      const newHash = `${viewParams}&${opacity}&${boxParams}&${arrowParams}&${url}&${finalRotation}`;
      // Write the updated hash. Keep this compact in normal logs.
      location.hash = newHash;

      setTimeout(() => {
        interactiveChange = false;
      }, 1);
    }

    // ---------------------------------------------------------------------
    // Pan/Zoom Helpers
    // ---------------------------------------------------------------------
    function fitViewToCanvas(img) {
      if (!img || !img.width || !img.height) return;

      const scaleX = canvas.width / img.width;
      const scaleY = canvas.height / img.height;
      const scale = Math.min(scaleX, scaleY);

      const displayWidth = img.width * scale;
      const displayHeight = img.height * scale;

      const offsetX = (canvas.width - displayWidth) / 2;
      const offsetY = (canvas.height - displayHeight) / 2;

      view.topLeft = [-offsetX / scale, -offsetY / scale];
      view.bottomRight = [
        img.width + offsetX / scale,
        img.height + offsetY / scale,
      ];
    }

    // Compute view object (topLeft/bottomRight) that would be set by fitViewToCanvas
    function computeFitView(img) {
      if (!img || !img.width || !img.height) return null;
      const scaleX = canvas.width / img.width;
      const scaleY = canvas.height / img.height;
      const scale = Math.min(scaleX, scaleY);
      const displayWidth = img.width * scale;
      const displayHeight = img.height * scale;
      const offsetX = (canvas.width - displayWidth) / 2;
      const offsetY = (canvas.height - displayHeight) / 2;
      return {
        topLeft: [-offsetX / scale, -offsetY / scale],
        bottomRight: [img.width + offsetX / scale, img.height + offsetY / scale]
      };
    }

    function fitViewToCoverCanvas(img) {
      if (!img || !img.width || !img.height) return;
      const canvasAspect = canvas.width / canvas.height;
      const imgAspect = img.width / img.height;
      let cropWidth, cropHeight, offsetX, offsetY;
      if (canvasAspect > imgAspect) {
        // Canvas is wider, crop top/bottom
        cropWidth = img.width;
        cropHeight = img.width / canvasAspect;
        offsetX = 0;
        offsetY = (img.height - cropHeight) / 2;
      } else {
        // Canvas is taller, crop sides
        cropHeight = img.height;
        cropWidth = img.height * canvasAspect;
        offsetY = 0;
        offsetX = (img.width - cropWidth) / 2;
      }
      view.topLeft = [offsetX, offsetY];
      view.bottomRight = [offsetX + cropWidth, offsetY + cropHeight];
    }

    // Compute a cover view without mutating global view
    function computeCoverView(img) {
      if (!img || !img.width || !img.height) return null;
      const canvasAspect = canvas.width / canvas.height;
      const imgAspect = img.width / img.height;
      let cropWidth, cropHeight, offsetX, offsetY;
      if (canvasAspect > imgAspect) {
        cropWidth = img.width;
        cropHeight = img.width / canvasAspect;
        offsetX = 0;
        offsetY = (img.height - cropHeight) / 2;
      } else {
        cropHeight = img.height;
        cropWidth = img.height * canvasAspect;
        offsetY = 0;
        offsetX = (img.width - cropWidth) / 2;
      }
      return { topLeft: [offsetX, offsetY], bottomRight: [offsetX + cropWidth, offsetY + cropHeight] };
    }

    function animateView(targetView) {
      // Grab a local token so we can detect if a new animation has started
      const localToken = animationCancelToken;
      const startView = { ...view };
      const startTime = performance.now();

      function animate(time) {
        // If animationCancelToken changes, stop this old animation
        if (localToken !== animationCancelToken) {
          return;
        }

        const progress = Math.min((time - startTime) / ANIMATION_DURATION, 1);

        view.topLeft[0] = Math.floor(
          startView.topLeft[0] +
            progress * (targetView.topLeft[0] - startView.topLeft[0])
        );
        view.topLeft[1] = Math.floor(
          startView.topLeft[1] +
            progress * (targetView.topLeft[1] - startView.topLeft[1])
        );
        view.bottomRight[0] = Math.floor(
          startView.bottomRight[0] +
            progress *
              (targetView.bottomRight[0] - startView.bottomRight[0])
        );
        view.bottomRight[1] = Math.floor(
          startView.bottomRight[1] +
            progress *
              (targetView.bottomRight[1] - startView.bottomRight[1])
        );

        render();
        if (progress < 1) {
          requestAnimationFrame(animate);
        }
      }
      requestAnimationFrame(animate);
    }

    function updateView(coords, animate = false, poster = false, cover = false) {
      if (cover) {
        fitViewToCoverCanvas(image);
        render();
        return;
      }
      if (poster) {
        fitViewToCanvas(image);
        render();
        return;
      }
      if (coords) {
        const targetView = {
          topLeft: coords.topLeft,
          bottomRight: coords.bottomRight,
        };
        if (animate) {
          animateView(targetView);
        } else {
          view = targetView;
          render();
        }
      } else {
        fitViewToCanvas(image);
        render();
      }
    }

    function setViewImmediately(coords) {
      if (coords) {
        view.topLeft = coords.topLeft.slice();
        view.bottomRight = coords.bottomRight.slice();
      } else {
        fitViewToCanvas(image);
      }
      render();
    }

    // ---------------------------------------------------------------------
    // Rendering
    // ---------------------------------------------------------------------
    function render() {
      canvas.width = Math.floor(window.innerWidth * pixelRatio);
      canvas.height = Math.floor(window.innerHeight * pixelRatio);
      canvas.style.width = `${window.innerWidth}px`;
      canvas.style.height = `${window.innerHeight}px`;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);

      const { topLeft, bottomRight } = view;
      const zoomWidth = bottomRight[0] - topLeft[0];
      const zoomHeight = bottomRight[1] - topLeft[1];
      const scale = Math.min(
        canvas.width / pixelRatio / zoomWidth,
        canvas.height / pixelRatio / zoomHeight
      );

      ctx.translate(
        canvas.width / pixelRatio / 2 -
          (topLeft[0] + zoomWidth / 2) * scale,
        canvas.height / pixelRatio / 2 -
          (topLeft[1] + zoomHeight / 2) * scale
      );
      ctx.scale(scale, scale);

      // Draw layers if any, otherwise draw single image
      if (layers && layers.length > 0) {
        // Render from last to first so that layers[0] (treated as top-most) is
        // painted last and appears on top of subsequent layers.
        let needRetry = false;
        for (let i = layers.length - 1; i >= 0; i--) {
          const layer = layers[i];
          if (!layer) continue;
          // If layer reports loaded but img.width isn't ready yet, mark for retry
          if (layer.loaded && layer.img && !layer.img.width) {
            needRetry = true;
            continue;
          }
          if (!layer.img || !layer.img.width) continue;
          ctx.save();
          // Use animated props when present so we can tween between states
          const props = layer._animProps || layer;
          // combine global opacity with layer opacity and per-layer animation alpha
          const baseOpacity = (imageOpacity || 1) * ((typeof props.opacity === 'number' ? props.opacity : 100) / 100);
          const animAlpha = (typeof props._animAlpha === 'number') ? props._animAlpha : ((typeof layer._animAlpha === 'number') ? layer._animAlpha : 1);
          const layerOpacity = baseOpacity * animAlpha;
          ctx.globalAlpha = layerOpacity;
          // drop shadow
          ctx.shadowColor = IMG_SHADOW_COLOR;
          ctx.shadowBlur = IMG_SHADOW_BLUR;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = IMG_SHADOW_OFFSET_Y;
          // compute anchor in image coords
          const px = (typeof props.tx === 'number' ? props.tx : 0.5) * layer.img.width;
          const py = (typeof props.ty === 'number' ? props.ty : 0.5) * layer.img.height;
          // If embedded in an iframe, nudge layers slightly so they remain
          // visually separable even when fully opaque. This avoids a case
          // where stacked images obscure each other in embedded contexts.
          const iframeNudge = (inFrame && layers.length > 1) ? ((i - (layers.length - 1) / 2) * 10) : 0;
          ctx.translate(px, py + iframeNudge);
          const rad = ((typeof props.rotation === 'number' ? props.rotation : 0) * Math.PI) / 180;
          ctx.rotate(rad);
          const sc = typeof props.scale === 'number' ? props.scale : 1;
          ctx.scale(sc, sc);
          // draw centered at anchor
          ctx.drawImage(layer.img, -layer.img.width / 2, -layer.img.height / 2);
          ctx.restore();
        }
        if (inFrame && needRetry) {
          // Re-render shortly to allow image natural size to initialize
          setTimeout(() => render(), 80);
        }
        // Draw any layers that are fading out on top so their fade is visible
        if (fadingOutLayers && fadingOutLayers.length) {
          for (const layer of fadingOutLayers) {
            if (!layer.img || !layer.img.width) continue;
            ctx.save();
            // fadingOutLayers may carry their own _animProps; prefer them
            const props = layer._animProps || layer;
            const layerOpacity = (imageOpacity || 1) * ((typeof props.opacity === 'number' ? props.opacity : 100) / 100);
            const anim = (typeof props._animAlpha === 'number') ? props._animAlpha : ((typeof layer._animAlpha === 'number') ? layer._animAlpha : 1);
            ctx.globalAlpha = layerOpacity * anim;
            const px = (typeof props.tx === 'number' ? props.tx : 0.5) * layer.img.width;
            const py = (typeof props.ty === 'number' ? props.ty : 0.5) * layer.img.height;
            const iframeNudge = (inFrame && layers.length + fadingOutLayers.length > 1) ? 0 : 0;
            ctx.translate(px, py + iframeNudge);
            const rad = ((typeof props.rotation === 'number' ? props.rotation : 0) * Math.PI) / 180;
            ctx.rotate(rad);
            const sc = typeof props.scale === 'number' ? props.scale : 1;
            ctx.scale(sc, sc);
            ctx.drawImage(layer.img, -layer.img.width / 2, -layer.img.height / 2);
            ctx.restore();
          }
        }
      } else {
        // Fallback single image
        if (image && image.width && image.height) {
          console.debug('[render] drawing single image, imageRotationDeg=', imageRotationDeg, 'image.width=', image.width, 'image.height=', image.height);
          ctx.save();
          ctx.globalAlpha = imageOpacity;
          drawImageWithRotation(ctx, image, imageRotationDeg);
          ctx.restore();
        }
      }

      // Draw annotations from the hash
      const parsed = parseHash();
      const annotations =
        (parsed && parsed.annotations) || {
          boxes: [],
          lines: [],
          color: 'ff0000',
        };

      // Boxes
      if (annotations.boxes) {
        ctx.save();
        ctx.strokeStyle = '#' + annotations.color;
        ctx.lineWidth = lineWidth / scale;
        for (let i = 0; i < annotations.boxes.length; i += 4) {
          const [x1, y1, x2, y2] = annotations.boxes.slice(i, i + 4);
          ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
        }
        ctx.restore();
      }

      // Lines
      if (annotations.lines) {
        ctx.save();
        ctx.strokeStyle = '#' + annotations.color;
        ctx.lineWidth = lineWidth / scale;
        for (let i = 0; i < annotations.lines.length; i += 4) {
          const [x1, y1, x2, y2] = annotations.lines.slice(i, i + 4);
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }
        ctx.restore();
      }

      ctx.restore();
      // Update iframe status overlay (if any)
      updateIframeStatus();
    }

    // ---------------------------------------------------------------------
    // Fade Helpers (with cancelable animations)
    // ---------------------------------------------------------------------
    function renderFade(img, alpha) {
      canvas.width = Math.floor(window.innerWidth * pixelRatio);
      canvas.height = Math.floor(window.innerHeight * pixelRatio);
      canvas.style.width = `${window.innerWidth}px`;
      canvas.style.height = `${window.innerHeight}px`;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);

      const { topLeft, bottomRight } = view;
      const zoomWidth = bottomRight[0] - topLeft[0];
      const zoomHeight = bottomRight[1] - topLeft[1];
      const scale = Math.min(
        canvas.width / pixelRatio / zoomWidth,
        canvas.height / pixelRatio / zoomHeight
      );

      ctx.translate(
        canvas.width / pixelRatio / 2 -
          (topLeft[0] + zoomWidth / 2) * scale,
        canvas.height / pixelRatio / 2 -
          (topLeft[1] + zoomHeight / 2) * scale
      );
      ctx.scale(scale, scale);

      if (img && img.width && img.height) {
      ctx.globalAlpha = alpha;
      drawImageWithRotation(ctx, img, imageRotationDeg);
      }

      ctx.restore();
    }

    function fadeOutImage(img, duration, onDone) {
      // local token to detect cancellation
      const localToken = animationCancelToken;

      if (!img || !img.width || !img.height) {
        if (onDone) onDone();
        return;
      }
      const start = performance.now();
      (function animateFadeOut(now) {
        // check cancel
        if (localToken !== animationCancelToken) {
          return;
        }

        let elapsed = now - start;
        if (elapsed > duration) elapsed = duration;
        const progress = elapsed / duration; // 0..1
        const alpha = 1 - progress; // 1..0

        renderFade(img, alpha);

        if (elapsed < duration) {
          requestAnimationFrame(animateFadeOut);
        } else {
          // clear completely
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          if (onDone) onDone();
        }
      })(start);
    }

    function fadeInImage(img, duration, onDone) {
      // local token to detect cancellation
      const localToken = animationCancelToken;

      if (!img || !img.width || !img.height) {
        if (onDone) onDone();
        return;
      }
      const start = performance.now();
      (function animateFadeIn(now) {
        // check cancel
        if (localToken !== animationCancelToken) {
          return;
        }

        let elapsed = now - start;
        if (elapsed > duration) elapsed = duration;
        const progress = elapsed / duration; // 0..1
        const alpha = progress; // 0..1

        renderFade(img, alpha);

        if (elapsed < duration) {
          requestAnimationFrame(animateFadeIn);
        } else {
          // final normal draw
          if (onDone) onDone();
        }
      })(start);
    }

    // Wait for images to have natural sizes (naturalWidth/naturalHeight > 0)
    function waitForImageSizes(layersArr, timeout = 3000) {
      return new Promise((resolve) => {
        const imgs = (layersArr || []).map(l => l && l.img).filter(Boolean);
        if (!imgs.length) return resolve();
        const start = performance.now();
        (function check() {
          const allReady = imgs.every(i => i && i.naturalWidth && i.naturalHeight);
          if (allReady) return resolve();
          if (performance.now() - start > timeout) return resolve();
          setTimeout(check, 80);
        })();
      });
    }

    // Wait for any initial per-layer _animAlpha fades to reach ~1 (for added layers)
    function waitForInitialFades(layersArr, timeout = 1000) {
      return new Promise((resolve) => {
        const start = performance.now();
        (function check() {
          const allDone = (layersArr || []).every(l => {
            if (!l) return true;
            const a = (l._animProps && typeof l._animProps._animAlpha === 'number') ? l._animProps._animAlpha : (typeof l._animAlpha === 'number' ? l._animAlpha : 1);
            return a >= 0.99;
          });
          if (allDone) return resolve();
          if (performance.now() - start > timeout) return resolve();
          setTimeout(check, 50);
        })();
      });
    }

    // Defer window.viewerReady until images have sizes and initial fades have completed
    async function setViewerReadyDeferred(layersArr) {
      // bump cancel token to stop competing animations while settling
      animationCancelToken++;
      // If running in an automated/headless environment (puppeteer), be more lenient
      // and accept image.complete or width>0 quickly to avoid test flakiness.
      const isHeadless = (typeof navigator !== 'undefined' && !!navigator.webdriver);
      if (isHeadless) {
        // wait briefly for images to at least be present/complete
        const start = performance.now();
        await new Promise(resolve => {
          (function check() {
            const imgs = (layersArr || []).map(l => l && l.img).filter(Boolean);
            const ready = imgs.length === 0 || imgs.every(i => i && (i.complete || i.width > 0));
            if (ready) return resolve();
            if (performance.now() - start > 1500) return resolve();
            setTimeout(check, 80);
          })();
        });
        // short wait for fades
        await waitForInitialFades(layersArr, 300);
        setTimeout(() => { window.viewerReady = true; render(); }, 20);
      } else {
        await waitForImageSizes(layersArr, 4000);
        await waitForInitialFades(layersArr, 800);
        // small extra tick to ensure render has settled
        setTimeout(() => { window.viewerReady = true; render(); }, 20);
      }
    }

    // -----------------------------------------------------------------
    // Per-layer tween helpers
    // -----------------------------------------------------------------
    // Tween numeric props from `from` to `to` over duration (ms). Returns
    // a cancel function. The `apply` callback is called with intermediate
    // props on each frame.
    function tweenProps(from, to, duration, apply, onDone) {
      const start = performance.now();
      let cancelled = false;
      function step(now) {
        if (cancelled) return;
        let t = (now - start) / duration;
        if (t < 0) t = 0;
        if (t > 1) t = 1;
        const interp = {};
        for (const k of Object.keys(to)) {
          const vTo = to[k];
          const vFrom = from && typeof from[k] !== 'undefined' ? from[k] : 0;
          if (typeof vTo === 'number' && typeof vFrom === 'number') {
            interp[k] = vFrom + (vTo - vFrom) * t;
          } else {
            interp[k] = typeof vTo !== 'undefined' ? vTo : vFrom;
          }
        }
        try { apply(interp); } catch (e) { /* swallow */ }
        render();
        if (t < 1) requestAnimationFrame(step);
        else if (onDone) onDone();
      }
      requestAnimationFrame(step);
      return function cancel() { cancelled = true; };
    }

    // Reconcile layers: animate per-layer numeric props from current to target.
    // This will animate opacity, rotation, tx, ty, scale and per-layer _animAlpha
    // (for fades). `oldLayers` and `newLayers` are arrays of layer objects.
    function reconcileLayers(oldLayers, newLayers) {
      // bump global token so other long-running animations (view anim, fadeImage)
      // are treated as cancelled for the duration of our per-layer tweens.
      animationCancelToken++;
      const localAnimationToken = animationCancelToken;
      const oldByUrl = {};
      (oldLayers || []).forEach(l => { if (l && l.url) oldByUrl[l.url] = l; });
      const newByUrl = {};
      (newLayers || []).forEach(l => { if (l && l.url) newByUrl[l.url] = l; });

      // Determine removed and added
      const removed = (oldLayers || []).filter(l => l && l.url && !newByUrl[l.url]);
      const added = (newLayers || []).filter(l => l && l.url && !oldByUrl[l.url]);

      // We'll track pending tweens so we can commit the final layer state to
      // the URL hash only after all tweens have completed. Intermediate frames
      // must not cause hash writes.
      let pendingTweens = 0;
      const notePending = () => { pendingTweens++; };
      const donePending = () => { pendingTweens--; checkFinish(); };

      function checkFinish() {
        // Only finalize if all tweens done and the local animation token is still current
        if (pendingTweens <= 0 && localAnimationToken === animationCancelToken) {
          // Commit final animated props into the canonical layer fields and
          // update the serialized url hash once.
          (newLayers || []).forEach(n => {
            const target = n;
            const layerRef = layers.find(l => l.url === n.url);
            if (layerRef) {
              // If an _animProps container exists, pull final numeric props from it
              if (layerRef._animProps) {
                layerRef.opacity = typeof layerRef._animProps.opacity === 'number' ? layerRef._animProps.opacity : layerRef.opacity;
                layerRef.rotation = typeof layerRef._animProps.rotation === 'number' ? layerRef._animProps.rotation : layerRef.rotation;
                layerRef.tx = typeof layerRef._animProps.tx === 'number' ? layerRef._animProps.tx : layerRef.tx;
                layerRef.ty = typeof layerRef._animProps.ty === 'number' ? layerRef._animProps.ty : layerRef.ty;
                layerRef.scale = typeof layerRef._animProps.scale === 'number' ? layerRef._animProps.scale : layerRef.scale;
              } else {
                // otherwise use target values
                layerRef.opacity = typeof target.opacity === 'number' ? target.opacity : layerRef.opacity;
                layerRef.rotation = typeof target.rotation === 'number' ? target.rotation : layerRef.rotation;
                layerRef.tx = typeof target.tx === 'number' ? target.tx : layerRef.tx;
                layerRef.ty = typeof target.ty === 'number' ? target.ty : layerRef.ty;
                layerRef.scale = typeof target.scale === 'number' ? target.scale : layerRef.scale;
              }
            }
          });
          // Serialize and write final hash. Use parseHash to preserve annotations/view.
          try {
            const serialized = layersToUrlField(layers);
            const parsed = parseHash();
            const annotations = (parsed && parsed.annotations) ? parsed.annotations : { boxes: [], lines: [], color: 'ff0000' };
            // Write the final url/state into the hash (this sets interactiveChange briefly)
            updateHash(serialized, view, annotations, Math.round((imageOpacity||1)*100), imageRotationDeg);
          } catch (e) {
            // ignore errors writing hash
          }
        }
      }

      // Ensure finish check in case there are zero tweens
      checkFinish();

      // Animate removed layers: move into fadingOutLayers and tween _animAlpha to 0
      removed.forEach(r => {
        // if already in fading list, skip
        if (!fadingOutLayers.includes(r)) {
          // capture current visible props
          r._animProps = { opacity: r.opacity, rotation: r.rotation, tx: r.tx, ty: r.ty, scale: r.scale, _animAlpha: 1 };
          r._animAlpha = 1;
          fadingOutLayers.push(r);
          // start fade-out
          notePending();
          tweenProps({ _animAlpha: 1 }, { _animAlpha: 0 }, FADE_OUT_DURATION || 300, v => { r._animAlpha = v._animAlpha; r._animProps._animAlpha = v._animAlpha; }, () => {
            // remove when done
            const idx = fadingOutLayers.indexOf(r);
            if (idx !== -1) fadingOutLayers.splice(idx, 1);
            donePending();
          });
        }
      });

      // Animate existing layers' property changes
      (newLayers || []).forEach(n => {
        const prev = oldByUrl[n.url];
        const layerObj = layers.find(l => l.url === n.url) || n;
        // prepare target props
        const to = { opacity: typeof n.opacity === 'number' ? n.opacity : 100, rotation: typeof n.rotation === 'number' ? n.rotation : 0, tx: typeof n.tx === 'number' ? n.tx : 0.5, ty: typeof n.ty === 'number' ? n.ty : 0.5, scale: typeof n.scale === 'number' ? n.scale : 1 };
        const from = prev ? { opacity: typeof prev.opacity === 'number' ? prev.opacity : 100, rotation: typeof prev.rotation === 'number' ? prev.rotation : 0, tx: typeof prev.tx === 'number' ? prev.tx : 0.5, ty: typeof prev.ty === 'number' ? prev.ty : 0.5, scale: typeof prev.scale === 'number' ? prev.scale : 1 } : to;
        // initialize an _animProps container to drive render
        layerObj._animProps = { ...(layerObj._animProps || {}), ...from, _animAlpha: (layerObj._animProps && typeof layerObj._animProps._animAlpha === 'number') ? layerObj._animProps._animAlpha : ((typeof layerObj._animAlpha === 'number') ? layerObj._animAlpha : 1) };
        // tween to target props
        notePending();
        tweenProps(from, to, 300, v => { layerObj._animProps = { ...(layerObj._animProps || {}), ...v }; }, () => { /* done - leave final props */ donePending(); });
      });

      // Animate added layers fade-in when they become available (img loaded)
      added.forEach(a => {
        // find layer reference in layers array
        const l = layers.find(x => x.url === a.url) || a;
        // ensure starting alpha 0
        l._animProps = { ...(l._animProps || {}), _animAlpha: 0, opacity: typeof l.opacity === 'number' ? l.opacity : 100, rotation: typeof l.rotation === 'number' ? l.rotation : 0, tx: typeof l.tx === 'number' ? l.tx : 0.5, ty: typeof l.ty === 'number' ? l.ty : 0.5, scale: typeof l.scale === 'number' ? l.scale : 1 };
        // If image already loaded, start tween immediately; otherwise hook onload
        const startFadeIn = () => {
          notePending();
          tweenProps({ _animAlpha: 0 }, { _animAlpha: 1 }, FADE_IN_DURATION || 300, v => { l._animProps._animAlpha = v._animAlpha; l._animAlpha = v._animAlpha; }, () => { /* done */ donePending(); });
        };
        if (l.img && l.img.width) {
          startFadeIn();
        } else if (l.img) {
          l.img.onload = () => { startFadeIn(); };
        }
      });
    }

    // ---------------------------------------------------------------------
    // loadImage
    // ---------------------------------------------------------------------
    function loadImage(url) {
      currentUrl = url;
      // mark not-ready while loading
      window.viewerReady = false;
      image.onload = () => {
        const parsed = parseHash();
        if (parsed && parsed.view) {
          updateView(parsed.view, false);
        } else {
          fitViewToCanvas(image);
        }
        render();
        // Defer readiness until image has measurable size and fades are complete
        setViewerReadyDeferred([{ img: image, _animAlpha: 1 }]);
      };
      image.src = url;
    }

    // Helper to draw an image at 0,0 in canvas coords while applying the current
    // rotation around the image center. This assumes ctx has already been transformed
    // to map image coordinates to canvas display coordinates (scale/translate applied).
    function drawImageWithRotation(ctx, img, deg) {
      if (!img) return;
      if (!deg || deg === 0) {
        // apply shadow for single-image draw
        ctx.shadowColor = IMG_SHADOW_COLOR;
        ctx.shadowBlur = IMG_SHADOW_BLUR;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = IMG_SHADOW_OFFSET_Y;
        ctx.drawImage(img, 0, 0);
        return;
      }
      console.debug('[drawImageWithRotation] rotating draw, deg=', deg);
      const rad = (deg * Math.PI) / 180;
      const cx = img.width / 2;
      const cy = img.height / 2;
      // apply shadow for rotated draw
      ctx.shadowColor = IMG_SHADOW_COLOR;
      ctx.shadowBlur = IMG_SHADOW_BLUR;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = IMG_SHADOW_OFFSET_Y;
      ctx.translate(cx, cy);
      ctx.rotate(rad);
      ctx.drawImage(img, -cx, -cy);
      ctx.rotate(-rad);
      ctx.translate(-cx, -cy);
    }

    // ---------------------------------------------------------------------
    // Interactions
    // ---------------------------------------------------------------------
    function setupInteractions() {
      let currentTool = 'none';
      let annotationStart = null;

      toolInputs.forEach((input) => {
        input.addEventListener('change', () => {
          currentTool = input.value;
        });
      });

      colorInput.addEventListener('change', () => {
        const parsed = parseHash();
        const annotations = parsed
          ? parsed.annotations
          : { boxes: [], lines: [], color: 'ff0000' };
        annotations.color = colorInput.value.slice(1);
        updateHash(currentUrl, view, annotations);
        render();
      });

      if (opacityInput) {
        opacityInput.value = '100'; // ensure default is 100
        imageOpacity = 1.0;
        opacityInput.addEventListener('input', () => {
          imageOpacity = parseInt(opacityInput.value, 10) / 100;
          render();
        });
      }

      // Rotation control
      const rotateInput = document.getElementById('rotate');
      const rotateReset = document.getElementById('rotate-reset');
      // Initialize from hash if present
      const parsedInit = parseHash();
      if (parsedInit && typeof parsedInit.rotation === 'number') {
        imageRotationDeg = parsedInit.rotation || 0;
      }
      if (rotateInput) {
        rotateInput.value = imageRotationDeg;
        rotateInput.addEventListener('input', () => {
          imageRotationDeg = parseFloat(rotateInput.value) || 0;
          // If we have layers, apply rotation to the top-most layer and persist
          if (layers && layers.length > 0) {
            layers[0].rotation = imageRotationDeg;
            currentUrl = layersToUrlField(layers);
            const parsed = parseHash();
            const annotations = parsed ? parsed.annotations : { boxes: [], lines: [], color: 'ff0000' };
            updateHash(currentUrl, view, annotations, Math.round((imageOpacity||1)*100), imageRotationDeg);
          } else {
            // Update hash with rotation field for single-image path
            const parsed = parseHash();
            const annotations = parsed ? parsed.annotations : { boxes: [], lines: [], color: 'ff0000' };
            updateHash(currentUrl, view, annotations, Math.round((imageOpacity||1)*100), imageRotationDeg);
          }
          render();
        });
      }
      if (rotateReset) {
        rotateReset.addEventListener('click', () => {
          imageRotationDeg = 0;
          if (rotateInput) rotateInput.value = '0';
          if (layers && layers.length > 0) {
            layers[0].rotation = 0;
            currentUrl = layersToUrlField(layers);
            const parsed = parseHash();
            const annotations = parsed ? parsed.annotations : { boxes: [], lines: [], color: 'ff0000' };
            updateHash(currentUrl, view, annotations, Math.round((imageOpacity||1)*100), imageRotationDeg);
          } else {
            const parsed = parseHash();
            const annotations = parsed ? parsed.annotations : { boxes: [], lines: [], color: 'ff0000' };
            updateHash(currentUrl, view, annotations, Math.round((imageOpacity||1)*100), imageRotationDeg);
          }
          render();
        });
      }

      canvas.addEventListener('mousedown', (e) => {
        if (inFrame) return;
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (canvas.width / rect.width);
        const y = (e.clientY - rect.top) * (canvas.height / rect.height);

        if (currentTool === 'none') {
          // panning
          isDragging = true;
          canvas.style.cursor = 'grabbing';
          startDrag = [x, y];
        } else {
          // annotation
          annotationStart = [x, y];
        }
      });

      canvas.addEventListener('mousemove', (e) => {
        if (currentTool === 'none' && isDragging) {
          // panning
          const rect = canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left) * (canvas.width / rect.width);
          const y = (e.clientY - rect.top) * (canvas.height / rect.height);

          const dx =
            ((startDrag[0] - x) *
              (view.bottomRight[0] - view.topLeft[0])) /
            canvas.width;
          const dy =
            ((startDrag[1] - y) *
              (view.bottomRight[1] - view.topLeft[1])) /
            canvas.height;

          view.topLeft[0] += dx;
          view.topLeft[1] += dy;
          view.bottomRight[0] += dx;
          view.bottomRight[1] += dy;

          startDrag = [x, y];
          render();
        } else if (annotationStart) {
          // annotation preview
          const rect = canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left) * (canvas.width / rect.width);
          const y = (e.clientY - rect.top) * (canvas.height / rect.height);

          render();
          ctx.save();
          ctx.strokeStyle = colorInput.value;
          ctx.lineWidth = lineWidth;

          if (currentTool === 'box') {
            ctx.strokeRect(
              annotationStart[0],
              annotationStart[1],
              x - annotationStart[0],
              y - annotationStart[1]
            );
          } else if (currentTool === 'arrow') {
            ctx.beginPath();
            ctx.moveTo(annotationStart[0], annotationStart[1]);
            ctx.lineTo(x, y);
            ctx.stroke();
          }
          ctx.restore();
        }
      });

      canvas.addEventListener('mouseup', (e) => {
        const parsed = parseHash();
        const annotations = parsed
          ? parsed.annotations
          : { boxes: [], lines: [], color: 'ff0000' };

        if (currentTool === 'none' && isDragging) {
          isDragging = false;
          canvas.style.cursor = 'grab';
          updateHash(currentUrl, view, annotations);
        } else if (annotationStart) {
          // finalize annotation
          const rect = canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left) * (canvas.width / rect.width);
          const y = (e.clientY - rect.top) * (canvas.height / rect.height);

          const scaledStart = [
            Math.round(
              view.topLeft[0] +
                (annotationStart[0] / canvas.width) *
                  (view.bottomRight[0] - view.topLeft[0])
            ),
            Math.round(
              view.topLeft[1] +
                (annotationStart[1] / canvas.height) *
                  (view.bottomRight[1] - view.topLeft[1])
            ),
          ];
          const scaledEnd = [
            Math.round(
              view.topLeft[0] +
                (x / canvas.width) *
                  (view.bottomRight[0] - view.topLeft[0])
            ),
            Math.round(
              view.topLeft[1] +
                (y / canvas.height) *
                  (view.bottomRight[1] - view.topLeft[1])
            ),
          ];

          if (currentTool === 'box') {
            annotations.boxes.push(
              scaledStart[0],
              scaledStart[1],
              scaledEnd[0],
              scaledEnd[1]
            );
          } else if (currentTool === 'arrow') {
            annotations.lines.push(
              scaledStart[0],
              scaledStart[1],
              scaledEnd[0],
              scaledEnd[1]
            );
          }

          annotationStart = null;
          updateHash(currentUrl, view, annotations);
          render();
        }
      });

      canvas.addEventListener('wheel', (e) => {
        if (inFrame) return;
        e.preventDefault();

        const parsed = parseHash();
        const annotations = parsed
          ? parsed.annotations
          : { boxes: [], lines: [], color: 'ff0000' };

        const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;

        const pointerX = (e.clientX * pixelRatio) / canvas.width;
        const pointerY = (e.clientY * pixelRatio) / canvas.height;

        const centerX =
          view.topLeft[0] +
          pointerX * (view.bottomRight[0] - view.topLeft[0]);
        const centerY =
          view.topLeft[1] +
          pointerY * (view.bottomRight[1] - view.topLeft[1]);

        const zoomWidth =
          (view.bottomRight[0] - view.topLeft[0]) * zoomFactor;
        const zoomHeight =
          (view.bottomRight[1] - view.topLeft[1]) * zoomFactor;

        view.topLeft = [
          Math.floor(centerX - zoomWidth * pointerX),
          Math.floor(centerY - zoomHeight * pointerY),
        ];
        view.bottomRight = [
          Math.floor(centerX + zoomWidth * (1 - pointerX)),
          Math.floor(centerY + zoomHeight * (1 - pointerY)),
        ];

        render();
        updateHash(currentUrl, view, annotations);
      });
    }

    // ---------------------------------------------------------------------
    // Hashchange: fade-out ‚Üí set new image & immediate pan/zoom ‚Üí fade-in
    // ---------------------------------------------------------------------
    window.addEventListener('hashchange', () => {
      if (interactiveChange) return;

  // Increment token to cancel any old animations
  animationCancelToken++;
  console.debug('[hashchange] handler start, location.hash=', location.hash);

  const parsed = parseHash();
  if (!parsed) return;
  const { url, view: newView, poster, cover, opacity, rotation } = parsed;
  // Apply rotation from the hash
  imageRotationDeg = (typeof rotation === 'number') ? rotation : 0;
  const rotateInput = document.getElementById('rotate');
  if (rotateInput) rotateInput.value = imageRotationDeg;

      // Animate opacity slider and image opacity from hash
      if (typeof opacity === 'number' && opacityInput) {
        const targetOpacity = opacity / 100;
        opacityInput.value = opacity;
        // Animate imageOpacity to targetOpacity
        const startOpacity = imageOpacity;
        const duration = 200; // ms
        const startTime = performance.now();
        function animateOpacity(now) {
          const elapsed = now - startTime;
          const t = Math.min(elapsed / duration, 1);
          imageOpacity = startOpacity + (targetOpacity - startOpacity) * t;
          render();
          if (t < 1) {
            requestAnimationFrame(animateOpacity);
          } else {
            imageOpacity = targetOpacity;
            render();
          }
        }
        requestAnimationFrame(animateOpacity);
      }

      // Always apply parsed layers (merge params if same URLs)
      const parsedLayers = parseLayersFromUrlField(url);
      applyParsedLayers(parsedLayers, () => {
            // After layers applied, if the hash contained a trailing rotation and
            // we have layers, apply that rotation to the top-most layer and
            // persist it into the serialized url field so the visual result
            // matches the user's expectation.
            if (typeof rotation === 'number' && layers && layers.length > 0) {
              layers[0].rotation = rotation;
              // update serialized currentUrl to include per-layer r= param, but DO NOT
              // immediately write back to location.hash here because that causes a
              // hashchange re-entry which can lead to parsed/serialized inconsistencies
              // when token ordering/encoding differs. The rotate UI will persist this
              // when the user interacts, and programmatic callers can decide when to
              // persist.
              currentUrl = layersToUrlField(layers);
            }
            // After layers applied, handle view/fit and rendering
        // Determine target view and animate the transition for visual smoothness
        const primaryImg = (layers && layers[0] && layers[0].img) ? layers[0].img : image;
        if (cover) {
          const target = computeCoverView(primaryImg) || computeFitView(primaryImg);
          if (target) updateView(target, true, false, true);
        } else if (poster) {
          const target = computeFitView(primaryImg) || computeCoverView(primaryImg);
          if (target) updateView(target, true, true, false);
        } else {
          if (newView) updateView(newView, true, poster, cover);
        }
        render();
      });
    });

    // ---------------------------------------------------------------------
    // Resize
    // ---------------------------------------------------------------------
    window.addEventListener('resize', () => {
      if (!inFrame) fitViewToCanvas(image);      
      render();
    });

    // ---------------------------------------------------------------------
    // Clipboard: Pasting a new image
    // ---------------------------------------------------------------------
    document.addEventListener('paste', (e) => {
      const clipboardData = e.clipboardData || window.clipboardData;
      const pastedText = clipboardData.getData('Text');

      if (
        pastedText &&
        (pastedText.startsWith('http://') ||
          pastedText.startsWith('https://'))
      ) {
        const newImg = new Image();
        newImg.onload = () => {
          fadeOutImage(image, FADE_OUT_DURATION, () => {
            image = newImg;
            currentUrl = pastedText;
            fitViewToCanvas(image);

            const annotations = {
              boxes: [],
              lines: [],
              color: '#ff0000',
            };
            updateHash(pastedText, view, annotations);

            fadeInImage(image, FADE_IN_DURATION, () => {
              render();
            });
          });
        };
        newImg.onerror = () => {
          alert('The pasted URL is not a valid image. Please try again.');
        };
        newImg.src = pastedText;
      }
    });

    // ---------------------------------------------------------------------
    // Initial load from hash (or blank)
    // ---------------------------------------------------------------------

    const parsed = parseHash();
    if (parsed) {
  // Apply rotation from initial hash
  if (typeof parsed.rotation === 'number') imageRotationDeg = parsed.rotation;
  currentUrl = parsed.url;
      if (parsed.annotations && parsed.annotations.color) {
        colorInput.value = '#' + parsed.annotations.color;
      }
      if (parsed.layers && parsed.layers.length > 0) {
        preloadLayers(parsed.layers, () => {
          image = layers[0] && layers[0].img ? layers[0].img : image;
          // If the initial hash carried a rotation, apply it to the top layer so
          // the visual state reflects the hash even when using layers.
          if (typeof parsed.rotation === 'number' && layers && layers.length > 0) {
            layers[0].rotation = parsed.rotation;
          }
          currentUrl = layersToUrlField(layers);
          if (typeof parsed.opacity === 'number' && opacityInput) {
            opacityInput.value = parsed.opacity;
            imageOpacity = parsed.opacity / 100;
          }
          // Animate into the requested view for a smoother initial presentation
          if (parsed.cover) {
            const target = computeCoverView(image) || computeFitView(image);
            if (target) updateView(target, true, false, true);
          } else if (parsed.poster) {
            const target = computeFitView(image) || computeCoverView(image);
            if (target) updateView(target, true, true, false);
          } else if (parsed.view) {
            updateView(parsed.view, true);
          } else {
            const target = computeFitView(image);
            if (target) updateView(target, true);
          }
          render();
        });
      } else if (currentUrl) {
        image.onload = () => {
          // Set opacity from hash after image loads (works in iframe and top-level)
          if (typeof parsed.opacity === 'number' && opacityInput) {
            const targetOpacity = parsed.opacity / 100;
            opacityInput.value = parsed.opacity;
            imageOpacity = targetOpacity;
          }
          if (parsed.cover) {
            fitViewToCoverCanvas(image);
          } else if (parsed.poster) {
            fitViewToCanvas(image);
          } else if (parsed.view) {
            setViewImmediately(parsed.view);
          } else {
            fitViewToCanvas(image);
          }
          render();
        };
        image.src = currentUrl;
      } else {
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = '20px Arial';
        ctx.fillText(
          'Paste URL or path to image',
          canvas.width / 2,
          canvas.height / 2
        );
      }
    } else {
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = '20px Arial';
      ctx.fillText(
        'Paste URL or path to image',
        canvas.width / 2,
        canvas.height / 2
      );
    }

    setupInteractions();

  // -----------------------------
    // Layers UI
    // -----------------------------
    function renderLayersPanel() {
      const container = document.getElementById('layers-list');
      if (!container) return;
      container.innerHTML = '';
      layers.forEach((layer, idx) => {
        const row = document.createElement('div');
        row.style.border = '1px solid #ddd';
        row.style.padding = '6px';
        row.style.marginBottom = '6px';
        row.style.background = '#fff';

  const title = document.createElement('div');
        title.style.fontSize = '0.85em';
        title.style.marginBottom = '4px';
  title.textContent = `${layer.id}: ${layer.url}`;
        row.appendChild(title);

        // opacity
        const opLabel = document.createElement('label');
        opLabel.textContent = 'Opacity';
        opLabel.style.fontSize = '0.8em';
        opLabel.style.display = 'block';
        const opInput = document.createElement('input');
        opInput.type = 'range';
        opInput.min = 0; opInput.max = 100;
        opInput.value = typeof layer.opacity === 'number' ? layer.opacity : 100;
        opInput.addEventListener('input', () => {
          layer.opacity = Number(opInput.value);
          commitLayersChange();
        });
        opLabel.appendChild(opInput);
        row.appendChild(opLabel);

        // rotation
        const rLabel = document.createElement('label');
        rLabel.textContent = 'Rotation';
        rLabel.style.fontSize = '0.8em';
        rLabel.style.display = 'block';
        const rInput = document.createElement('input');
        rInput.type = 'range';
        rInput.min = -180; rInput.max = 180;
        rInput.value = typeof layer.rotation === 'number' ? layer.rotation : 0;
        rInput.addEventListener('input', () => {
          layer.rotation = Number(rInput.value);
          // Keep rotate UI in sync with top layer if this is top
          const rotateInput = document.getElementById('rotate');
          if (idx === 0 && rotateInput) rotateInput.value = layer.rotation;
          commitLayersChange();
        });
        rLabel.appendChild(rInput);
        row.appendChild(rLabel);

        // tx/ty/scale small inputs
        const smallWrap = document.createElement('div');
        smallWrap.style.display = 'flex';
        smallWrap.style.gap = '4px';

        const tx = document.createElement('input');
        tx.type = 'number'; tx.step = '0.01'; tx.min = 0; tx.max = 1;
        tx.title = 'Anchor X (0..1)'; tx.value = typeof layer.tx === 'number' ? layer.tx : 0.5;
        tx.style.width = '3.5em';
        tx.addEventListener('change', () => { layer.tx = Number(tx.value); commitLayersChange(); });
        smallWrap.appendChild(tx);

        const ty = document.createElement('input');
        ty.type = 'number'; ty.step = '0.01'; ty.min = 0; ty.max = 1;
        ty.title = 'Anchor Y (0..1)'; ty.value = typeof layer.ty === 'number' ? layer.ty : 0.5;
        ty.style.width = '3.5em';
        ty.addEventListener('change', () => { layer.ty = Number(ty.value); commitLayersChange(); });
        smallWrap.appendChild(ty);

        const sc = document.createElement('input');
        sc.type = 'number'; sc.step = '0.05'; sc.min = 0.01; sc.max = 10;
        sc.title = 'Scale'; sc.value = typeof layer.scale === 'number' ? layer.scale : 1;
        sc.style.width = '3.5em';
        sc.addEventListener('change', () => { layer.scale = Number(sc.value); commitLayersChange(); });
        smallWrap.appendChild(sc);

        row.appendChild(smallWrap);

        // Controls: up, down, remove
        const controls = document.createElement('div');
        controls.style.marginTop = '6px';
        const upBtn = document.createElement('button'); upBtn.textContent = '‚Üë';
        const downBtn = document.createElement('button'); downBtn.textContent = '‚Üì';
        const remBtn = document.createElement('button'); remBtn.textContent = 'Remove';
  upBtn.addEventListener('click', () => { moveLayerUpById(layer.id); });
  downBtn.addEventListener('click', () => { moveLayerDownById(layer.id); });
  remBtn.addEventListener('click', () => { removeLayerById(layer.id); });
        controls.appendChild(upBtn); controls.appendChild(downBtn); controls.appendChild(remBtn);
        row.appendChild(controls);

        container.appendChild(row);
      });
    }

    function commitLayersChange() {
      // Serialize and persist layers into the hash, but preserve existing images
      currentUrl = layersToUrlField(layers);
      const parsed = parseHash();
      const annotations = parsed ? parsed.annotations : { boxes: [], lines: [], color: 'ff0000' };
      // Use updateHash to write the new url field; preserve rotation in explicit field
      updateHash(currentUrl, view, annotations, Math.round((imageOpacity||1)*100), imageRotationDeg);
      // Ensure any newly referenced layer images are loaded (preserve existing)
      preloadLayers(layers.map(l => ({ url: l.url, opacity: l.opacity, rotation: l.rotation, tx: l.tx, ty: l.ty, scale: l.scale })), () => {
        // After preload, re-render
        image = layers[0] && layers[0].img ? layers[0].img : image;
        render();
      }, { preserveExisting: true });
      renderLayersPanel();
    }

    function addLayer(url) {
      if (!url) return;
      const newLayer = { id: url, url, opacity: 100, rotation: 0, tx: 0.5, ty: 0.5, scale: 1, img: null, loaded: false };
      // Append to top (index 0) so new layer is topmost
      layers.unshift(newLayer);
      commitLayersChange();
    }

    function findLayerIndexById(id) {
      return layers.findIndex(l => l && l.id === id);
    }

    function removeLayerById(id) {
      const idx = findLayerIndexById(id);
      if (idx === -1) return;
      layers.splice(idx, 1);
      commitLayersChange();
    }

    function moveLayerUpById(id) {
      const idx = findLayerIndexById(id);
      if (idx <= 0) return;
      const a = layers.splice(idx, 1)[0];
      layers.splice(idx - 1, 0, a);
      commitLayersChange();
    }

    function moveLayerDownById(id) {
      const idx = findLayerIndexById(id);
      if (idx < 0 || idx >= layers.length - 1) return;
      const a = layers.splice(idx, 1)[0];
      layers.splice(idx + 1, 0, a);
      commitLayersChange();
    }

    // Wire add-layer button
    const addBtn = document.getElementById('add-layer');
    if (addBtn) {
      addBtn.addEventListener('click', () => {
        const input = document.getElementById('new-layer-url');
        if (!input) return;
        const val = input.value && input.value.trim();
        if (val) {
          addLayer(val);
          input.value = '';
        }
      });
    }

    // Initial render of layers panel if any
    renderLayersPanel();

    // -----------------------------
    // Iframe debug/status overlay
    // -----------------------------
    function ensureIframeStatus() {
      if (!inFrame) return null;
      let el = document.getElementById('iframe-status');
      if (!el) {
        el = document.createElement('div');
        el.id = 'iframe-status';
        el.style.position = 'fixed';
        el.style.right = '0.5em';
        el.style.top = '0.5em';
        el.style.background = 'rgba(0,0,0,0.7)';
        el.style.color = '#fff';
        el.style.padding = '6px';
        el.style.fontSize = '11px';
        el.style.zIndex = 9999;
        el.style.borderRadius = '4px';
        el.style.maxWidth = '18em';
        el.style.whiteSpace = 'pre-wrap';
        document.body.appendChild(el);
      }
      return el;
    }

    function updateIframeStatus() {
      if (!inFrame) return;
      const el = ensureIframeStatus();
      if (!el) return;
      const lines = [];
      lines.push(`currentUrl: ${currentUrl || '<none>'}`);
      lines.push(`Layers: ${layers ? layers.length : 0}`);
      if (layers && layers.length) {
        layers.forEach((l, i) => {
          const nw = l && l.img ? (l.img.naturalWidth || l.img.width || 0) : 0;
          const nh = l && l.img ? (l.img.naturalHeight || l.img.height || 0) : 0;
          lines.push(`${i}: ${l.url || '<no-url>'} ${l.loaded ? '[loaded]' : '[loading]'} size=${nw}x${nh} o=${l.opacity} r=${l.rotation}`);
        });
      }
      el.textContent = lines.join('\n');
    }

    // ---------------------------------------------------------------------
    // ESC to Clear Annotations
    // ---------------------------------------------------------------------
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        // Clear annotations
        const annotations = {
          boxes: [],
          lines: [],
          color: colorInput.value.slice(1),
        };
        fitViewToCanvas(image);
        updateHash(currentUrl, view, annotations);
        render();
      }
    });
  </script>
</body>
</html>