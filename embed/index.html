<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Embed loader</title>
  <!-- Plyr CSS -->
  <link rel="stylesheet" href="https://cdn.plyr.io/3.7.8/plyr.css" />
  <style>
    :root{--ui-bg:rgba(0,0,0,0.6);--ui-fg:#fff}
    html,body{height:100%;margin:0;background:#000;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    #canvas{position:fixed;inset:0;background:transparent;display:flex;align-items:center;justify-content:center;overflow:hidden}
    #injected{width:100%;height:100%;}
    #injected.cover{position:fixed;top:0;left:50%;transform:translateX(-50%);width:177vh;height:100vh;overflow:hidden;}
    #injected.auto{display:flex;align-items:center;justify-content:center;}
    #injected.auto .plyr__video-embed{width: 57vh;}
    /* Floating UI */
    #floating{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:9999;display:flex;flex-direction:column;align-items:stretch;gap:8px;min-width:320px}
    #ui-handle{background:var(--ui-bg);padding:8px;border-radius:10px;color:var(--ui-fg);cursor:grab;display:flex;align-items:center;gap:8px;touch-action:none}
    #ui-body{background:rgba(0,0,0,0.45);padding:10px;border-radius:10px;color:var(--ui-fg);display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    input[type=text]{flex:1;min-width:200px;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.08);background:transparent;color:var(--ui-fg)}
    button{padding:8px 10px;border-radius:6px;border:0;background:#2ea44f;color:#fff;font-weight:700;cursor:pointer}
    button.secondary{background:#444;color:#fff}
    
    /* Plyr container */
    .embed-wrapper{width:100%;height:100%;position:relative;overflow:hidden}
    .plyr-container{width:100%;height:100%;position:relative;}
    
    /* Hide Plyr UI completely */
    .plyr__controls{display:none !important;}
    .plyr__control--overlaid{display:none !important;}
    .plyr__poster{display:none !important;}
  </style>
  <script src="https://cdn.plyr.io/3.7.8/plyr.js"></script>
  <script src="../src/players/adapter.js"></script>
</head>
<body>
  <div id="canvas">
    <div id="injected"></div>
  </div>

  <div id="floating" role="dialog" aria-label="Embed loader">
    <div id="ui-handle">Drag â€¢ Paste Video URL</div>
    <div id="ui-body">
      <input id="url" type="text" placeholder="https://..." aria-label="url input">
      <button id="load">Load</button>
      <label style="display:flex;align-items:center;gap:6px"><input id="autoplay" type="checkbox"> autoplay</label>
      <label style="display:flex;align-items:center;gap:6px"><input id="loop" type="checkbox"> loop</label>
      <label style="display:flex;align-items:center;gap:6px"><input id="cover" type="checkbox"> cover</label>
      <label style="display:flex;align-items:center;gap:6px"><input id="auto" type="checkbox"> auto</label>
      <button id="clear" class="secondary">Clear</button>
    </div>
  </div>

<script>
(function(){
  const injected = document.getElementById('injected');
  const floating = document.getElementById('floating');
  const handle = document.getElementById('ui-handle');
  const urlIn = document.getElementById('url');
  const loadBtn = document.getElementById('load');
  const clearBtn = document.getElementById('clear');
  const autoplayChk = document.getElementById('autoplay');
  const loopChk = document.getElementById('loop');
  const coverChk = document.getElementById('cover');
  const autoChk = document.getElementById('auto');
  
  let playerAdapter = null;

  // --- Hash state helpers -------------------------------------------------
  function parseHash(){
    try{
      const q = new URLSearchParams(location.search.replace(/^\?/, ''));
      const rawHash = (location.hash || '').replace(/^#/, '');
      const out = {};

      // Compact format: #url/flags
      if(rawHash){
        const parts = rawHash.split('/').filter(Boolean);
        if(parts.length > 0){
          try{ out.url = expandUrlFromHash(parts[0]); }catch(e){}
        }
        if(parts.length > 1){
          const flags = parts[1].split(',').map(t=>t.trim()).filter(Boolean);
          for(const f of flags){
            if(f === 'autoplay') out.autoplay = true;
            else if(f === 'loop') out.loop = true;
            else if(f === 'cover') out.cover = true;
            else if(f === 'auto') out.auto = true;
          }
        }
      }

      // Query params override hash
      for(const [k,v] of q.entries()){
        if(k === 'u' || k === 'url') out.url = expandUrlFromHash(v);
        else if(k === 'a' || k === 'autoplay') out.autoplay = (v === '1' || v === 'true' || v === '');
        else if(k === 'loop') out.loop = (v === '1' || v === 'true' || v === '');
        else if(k === 'cover') out.cover = (v === '1' || v === 'true' || v === '');
        else if(k === 'auto') out.auto = (v === '1' || v === 'true' || v === '');
      }

      if(typeof out.autoplay !== 'undefined') out.autoplay = !!out.autoplay;
      if(typeof out.loop !== 'undefined') out.loop = !!out.loop;
      if(typeof out.cover !== 'undefined') out.cover = !!out.cover;
      if(typeof out.auto !== 'undefined') out.auto = !!out.auto;
      
      return out;
    }catch(e){ return {}; }
  }

  function writeHash(state){
    try{
      const parts = [];
      if(state.url) parts.push(compactUrlForHash(state.url));

      const flags = [];
      if(state.autoplay) flags.push('autoplay');
      if(state.loop) flags.push('loop');
      if(state.cover) flags.push('cover');
      if(state.auto) flags.push('auto');
      if(flags.length) parts.push(flags.join(','));

      const newHash = parts.join('/');
      if(newHash) location.replace('#' + newHash);
      else location.replace('#');
    }catch(e){}
  }

  function compactUrlForHash(full){
    try{
      if(!full) return full;
      const decoded = decodeURIComponent(full);
      const stripped = decoded.replace(/^https?:\/\//i, '').replace(/^www\./i, '');
      return encodeURIComponent(stripped);
    }catch(e){ return encodeURIComponent(full); }
  }

  function expandUrlFromHash(compacted){
    try{
      if(!compacted) return compacted;
      const decoded = decodeURIComponent(compacted);
      if(/^https?:\/\//i.test(decoded)) return decoded;
      return 'https://' + decoded;
    }catch(e){ return decodeURIComponent(compacted || ''); }
  }

  function applyStateToUI(state){
    if(!state) return;
    if(state.url) urlIn.value = state.url;
    if(typeof state.autoplay !== 'undefined') autoplayChk.checked = !!state.autoplay;
    if(typeof state.loop !== 'undefined') loopChk.checked = !!state.loop;
    if(typeof state.cover !== 'undefined') coverChk.checked = !!state.cover;
    if(typeof state.auto !== 'undefined') autoChk.checked = !!state.auto;
  }

  // --- Player loading -----------------------------------------------------
  function shouldUsePlyrAdapter(url){
    const u = String(url || '').toLowerCase();
    return u.includes('youtube.com') || u.includes('youtu.be') || u.includes('vimeo.com') || u.match(/\.(mp4|webm|ogg)$/);
  }

  async function loadUrl(u){
    if(!u) return;

    if(!shouldUsePlyrAdapter(u)){
      console.warn('Only YouTube, Vimeo, and direct video files are supported');
      return;
    }

    try{
      // Destroy any existing adapter
      if(playerAdapter){ 
        try{ playerAdapter.destroy(); }catch(e){} 
        playerAdapter = null; 
      }
      injected.innerHTML = '';

      // Create wrapper and adapter
      const wrap = document.createElement('div');
      wrap.className = 'embed-wrapper plyr-container';
      injected.appendChild(wrap);

      playerAdapter = window.createAdapter(wrap, u);
      
      // Wire player events
      playerAdapter.on('ready', () => {
        const st = parseHash();
        console.log('[embed] Player ready, state:', st);
        
        // Toggle classes based on mode
        injected.classList.remove('cover', 'auto');
        if(st.cover){
          injected.classList.add('cover');
        } else if(st.auto){
          injected.classList.add('auto');
        }
        
        // Apply player state
        applyPlayerState(st);
        
        // Auto-hide UI if embedded
        try{ if(window.top !== window.self){ hideFloatingUI(); } }catch(e){}
        animateFloatingToBottom();
      });

      // Load the player
      await playerAdapter.load(u);

    }catch(err){
      console.error('Player load failed', err);
    }
  }

  function applyPlayerState(state){
    if(!playerAdapter || !playerAdapter.ready) return;
    console.log('[embed] applyPlayerState', state);
    
    try{
      // Apply muting for autoplay
      if(state.autoplay){
        playerAdapter.setMuted(true);
      }
      
      // Apply loop
      if(state.loop){
        playerAdapter.setLoop(true);
      }
      
      // Start playback
      if(state.autoplay){
        playerAdapter.play().then(() => {
          console.log('[embed] Autoplay succeeded');
        }).catch(e => {
          console.warn('[embed] Autoplay failed:', e);
        });
      }
    }catch(e){ 
      console.warn('applyPlayerState error', e); 
    }
  }

  // --- UI helpers ---------------------------------------------------------
  function animateFloatingToBottom(){
    try{
      floating.style.transition = 'transform 600ms ease, top 600ms ease, left 600ms ease';
      const vw = window.innerWidth, vh = window.innerHeight;
      const r = floating.getBoundingClientRect();
      const targetLeft = Math.round((vw - r.width)/2);
      const targetTop = Math.round(vh - r.height - 20);
      floating.style.left = targetLeft + 'px';
      floating.style.top = targetTop + 'px';
      floating.style.transform = 'translate(0,0)';
      setTimeout(()=>{ floating.style.transition = ''; }, 700);
    }catch(e){}
  }

  function hideFloatingUI(){
    try{
      floating.style.transition = 'opacity 300ms ease';
      floating.style.opacity = '0';
      floating.style.pointerEvents = 'none';
    }catch(e){}
  }

  // --- Event handlers -----------------------------------------------------
  loadBtn.addEventListener('click', ()=>{
    const u = urlIn.value.trim();
    if(!u) return;
    loadUrl(u);
    writeHash({ url: u, autoplay: autoplayChk.checked, loop: loopChk.checked, cover: coverChk.checked, auto: autoChk.checked });
  });

  clearBtn.addEventListener('click', ()=>{
    if(playerAdapter){ 
      try{ playerAdapter.destroy(); }catch(e){} 
      playerAdapter = null; 
    }
    injected.innerHTML=''; 
    urlIn.value='';
    writeHash({});
  });

  autoplayChk.addEventListener('change', ()=>{ 
    writeHash({ url: urlIn.value.trim(), autoplay: autoplayChk.checked, loop: loopChk.checked, cover: coverChk.checked, auto: autoChk.checked }); 
  });
  
  loopChk.addEventListener('change', ()=>{ 
    writeHash({ url: urlIn.value.trim(), autoplay: autoplayChk.checked, loop: loopChk.checked, cover: coverChk.checked, auto: autoChk.checked }); 
  });

  coverChk.addEventListener('change', ()=>{
    const u = urlIn.value.trim();
    if(u){
      loadUrl(u);
      writeHash({ url: u, autoplay: autoplayChk.checked, loop: loopChk.checked, cover: coverChk.checked, auto: autoChk.checked });
    }
  });

  autoChk.addEventListener('change', ()=>{
    const u = urlIn.value.trim();
    if(u){
      loadUrl(u);
      writeHash({ url: u, autoplay: autoplayChk.checked, loop: loopChk.checked, cover: coverChk.checked, auto: autoChk.checked });
    }
  });

  urlIn.addEventListener('keydown', (e)=>{ 
    if(e.key === 'Enter'){ 
      const u = urlIn.value.trim();
      if(u){
        loadUrl(u);
        writeHash({ url: u, autoplay: autoplayChk.checked, loop: loopChk.checked, cover: coverChk.checked, auto: autoChk.checked });
      }
    } 
  });

  // Handle hash changes
  window.addEventListener('hashchange', ()=>{
    const s = parseHash();
    applyStateToUI(s);
    if(s.url) loadUrl(s.url);
  });

  // Make floating draggable
  (function(){
    let dragging=false, sx=0, sy=0, ox=0, oy=0;
    handle.addEventListener('pointerdown', (ev)=>{
      dragging=true; 
      handle.setPointerCapture && handle.setPointerCapture(ev.pointerId);
      sx = ev.clientX; sy = ev.clientY; 
      const r = floating.getBoundingClientRect(); 
      ox = r.left; oy = r.top;
      floating.style.transition = 'none';
    });
    window.addEventListener('pointermove', (ev)=>{
      if(!dragging) return; 
      const dx = ev.clientX - sx, dy = ev.clientY - sy; 
      floating.style.left = (ox + dx) + 'px'; 
      floating.style.top = (oy + dy) + 'px'; 
      floating.style.transform = 'translate(0,0)';
    }, {passive:true});
    window.addEventListener('pointerup', ()=>{ 
      dragging=false; 
      floating.style.transition = ''; 
    }, {passive:true});
  })();

  // Initial load from hash
  try{
    const initial = parseHash();
    if(Object.keys(initial).length){ 
      applyStateToUI(initial);
      if(initial.url) loadUrl(initial.url);
    }
  }catch(e){}

  urlIn.focus();
})();
</script>
</body>
</html>
