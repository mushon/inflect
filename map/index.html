<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Dynamic Mapbox Map with Hash Control</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    html, body, #map {
      height: 100%;
      margin: 0;
      padding: 0;
      width: 100%;
    }
    #layer-controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border-radius: 4px;
      z-index: 1;
      font-family: sans-serif;
    }
  </style>
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <!-- Removed any Python-in-the-browser scripts (e.g., Pyodide, Brython) to prevent py.parse errors -->
  <!-- Add JSZip and togeojson for KMZ/KML support -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://unpkg.com/togeojson@0.16.0/dist/togeojson.js"></script>
</head>
<body>
<div id="map"></div>
<div id="layer-controls"></div>
<script>
// Hide control panel if in an iframe
if (window.self !== window.top) {
  document.addEventListener('DOMContentLoaded', function() {
    var controls = document.getElementById('layer-controls');
    if (controls) controls.style.display = 'none';
  });
}
// Sample Mapbox access token (replace with your own for production)
mapboxgl.accessToken = 'pk.eyJ1IjoibXVzaG9uIiwiYSI6ImNtOGVhMWFkZTJqOGkyanI3aHJzaG11N3oifQ.gU_FaxkjsMZqUbFQedDSJA';

// Sample style
const style = 'mapbox://styles/mushon/cmg0uv6tl00jn01qy6ruzhg29';

// Layers to toggle (layer ids must exist in the style)
// Will be populated with all layers from the style after map load
let allStyleLayers = [];

// Will hold the style default visibility for each layer
const styleDefaultVisibility = {};

// Default camera
const defaultCamera = {
  center: [34.3537, 31.4238], // Custom view
  zoom: 10,
  bearing: 37.6,
  pitch: 0
};

// Parse hash: #lat,lng,zoom,bearing,pitch/+layer1,-layer2/load:filename
function parseHash() {
  const hash = window.location.hash.replace('#', '');
  if (!hash) return { camera: { ...defaultCamera }, layers: allStyleLayers.map(l => l.id), dynamicGeojsonToLoad: [] };
  let cameraStr = '', layersStr = '', followId = null;
  const parts = hash.split('/');
  const restParts = [];
  for (let i = 0; i < parts.length; i++) {
    if (parts[i].startsWith('load:')) {
      continue;
    } else if (parts[i].length > 0) {
      restParts.push(parts[i]);
    }
  }
  cameraStr = restParts[0] || '';
  layersStr = restParts[1] || '';
  const cameraParts = cameraStr ? cameraStr.split(',').map(Number) : [];
  let layersOn = allStyleLayers.map(l => l.id);
  let dynamicGeojsonToLoad = [];
  if (layersStr) {
    layersOn = [];
    const layerState = {};
    layersStr.split(',').forEach(token => {
      // Support +id:follow and ~id:follow
      const match = token.match(/^([+~])([^:]+)(:follow)?$/);
      if (!match) return;
      const [, sign, lname, follow] = match;
      // Always use the id without :follow for loading/toggling
      layerState[lname] = { sign, follow: !!follow };
    });
    Object.entries(layerState).forEach(([lname, { sign, follow }]) => {
      if (sign === '+') {
        if (!allStyleLayers.some(l => l.id === lname)) {
          dynamicGeojsonToLoad.push(lname);
        }
        layersOn.push(lname);
        if (follow) followId = lname;
      } else if (sign === '~') {
        // For ~new-id, load as invisible (unchecked) dynamic layer
        if (!allStyleLayers.some(l => l.id === lname)) {
          dynamicGeojsonToLoad.push(lname);
        }
        if (follow) followId = lname;
        // Do NOT add to layersOn, so it is not visible/checked
      }
    });
  }
  return {
    camera: {
      center: [cameraParts[1] || defaultCamera.center[0], cameraParts[0] || defaultCamera.center[1]],
      zoom: cameraParts[2] || defaultCamera.zoom,
      bearing: cameraParts[3] || defaultCamera.bearing,
      pitch: cameraParts[4] || defaultCamera.pitch
    },
    layers: layersOn,
    dynamicGeojsonToLoad,
    followId
  };
}

// Helper: load and add GeoJSON as top layer or replace source of a layer
async function loadAndAddOrReplaceGeoJSON(geojsonFile, toLayer) {
  try {
    const response = await fetch(geojsonFile);
    if (!response.ok) throw new Error('Failed to fetch GeoJSON');
    const geojson = await response.json();
    let fileId = geojsonFile.split('/').pop();
    let cleanId = fileId.replace(/(_geojson|\.geojson)$/i, '');
    cleanId = cleanId.replace(/[^a-zA-Z0-9_-]/g, '_');
    const sourceId = cleanId;
    const layerId = cleanId;
    if (map.getLayer(layerId)) map.removeLayer(layerId);
    if (map.getSource(sourceId)) map.removeSource(sourceId);
    map.addSource(sourceId, { type: 'geojson', data: geojson });
    let type = 'line';
    if (geojson.features && geojson.features.length) {
      const geomType = geojson.features[0].geometry && geojson.features[0].geometry.type;
      if (geomType === 'Polygon' || geomType === 'MultiPolygon') type = 'fill';
      else if (geomType === 'Point' || geomType === 'MultiPoint') type = 'circle';
    }
    // Support options for visibility
    let visibility = 'visible';
    if (typeof toLayer === 'object' && toLayer !== null && toLayer.visibility === 'none') {
      visibility = 'none';
    }
    const layerDef = {
      id: layerId,
      type,
      source: sourceId,
      layout: { visibility },
      paint: type === 'line' ? { 'line-color': '#fff', 'line-width': 3 } :
             type === 'fill' ? { 'fill-color': '#f00', 'fill-opacity': 0.5 } :
             { 'circle-radius': 6, 'circle-color': '#f00' }
    };
    map.addLayer(layerDef);
    console.log(`Layer loaded: ${layerId}`);
    // After loading, always check if the hash has :follow for this layer and trigger follow logic if needed
    setTimeout(() => {
      const hash = window.location.hash.replace('#', '');
      const [, layersStr] = hash.split('/');
      if (layersStr) {
        const tokens = layersStr.split(',');
        const match = tokens.find(token => token.match(new RegExp(`^[+~]${layerId}:follow$`)));
        if (match && !(window._isFreeCameraAnimating)) {
          // Directly invoke the follow logic as in the hashchange handler
          const { camera, layers, dynamicGeojsonToLoad, followId } = parseHash();
          if (followId === layerId) {
            // 1. Fly to new location
            const flyOpts = {
              center: [camera.center[0], camera.center[1]],
              zoom: camera.zoom,
              bearing: camera.bearing,
              pitch: camera.pitch,
              duration: 1200
            };
            console.log('[FOLLOW] 1. Flying to new location:', flyOpts.center, 'zoom:', flyOpts.zoom);
            map.flyTo(flyOpts);

            // 2. Change visibility of existing layers
            const explicitState = {};
            layersStr.split(',').forEach(token => {
              const match = token.match(/^([+~])([^:]+)(:follow)?$/);
              if (!match) return;
              const [, sign, lname] = match;
              explicitState[lname] = sign;
            });
            let removedIds = [];
            allStyleLayers.slice().forEach(layer => {
              const id = layer.id;
              if (!map.getStyle().layers.some(l => l.id === id) && explicitState[id] !== '+') {
                if (map.getLayer(id)) map.removeLayer(id);
                if (map.getSource(id)) map.removeSource(id);
                removedIds.push(id);
                delete styleDefaultVisibility[id];
              }
            });
            allStyleLayers = allStyleLayers.filter(l => !removedIds.includes(l.id));
            Object.entries(explicitState).forEach(([id, sign]) => {
              if (map.getLayer(id)) {
                if (sign === '+') {
                  if (map.getLayoutProperty(id, 'visibility') !== 'visible') {
                    map.setLayoutProperty(id, 'visibility', 'visible');
                  }
                } else if (sign === '~') {
                  if (map.getLayoutProperty(id, 'visibility') !== 'none') {
                    map.setLayoutProperty(id, 'visibility', 'none');
                  }
                }
              }
            });
            console.log('[FOLLOW] 2. Changed visibility of existing layers');

            // 3. Layer is now loaded (this function)
            console.log(`[FOLLOW] 3. Layer loaded: ${layerId}`);

            // 4. Start following the line
            // Helper to extract coordinates from a source
            function getCoordsFromSource(source) {
              let coords = [];
              if (source && source._data && source._data.features) {
                source._data.features.forEach(f => {
                  if (!f.geometry) return;
                  if (f.geometry.type === 'LineString') coords = coords.concat(f.geometry.coordinates);
                  if (f.geometry.type === 'Polygon') coords = coords.concat(f.geometry.coordinates[0]);
                  if (f.geometry.type === 'MultiLineString') coords = coords.concat(...f.geometry.coordinates);
                  if (f.geometry.type === 'MultiPolygon') coords = coords.concat(...f.geometry.coordinates.map(ring => ring[0]));
                });
              }
              return coords;
            }
            const source = map.getSource(layerId);
            const coords = getCoordsFromSource(source);
            if (coords.length > 1) {
              console.log(`[FOLLOW] 4. Follow initiated for layer: ${layerId}`);
              window._isFreeCameraAnimating = true;
              pendingHashUpdate = { camera, layers, dynamicGeojsonToLoad };
              followPathWithFreeCamera(map, coords, () => {
                pendingHashUpdate = null;
                // Remove :follow from the hash for this layer
                let hash = window.location.hash.replace('#', '');
                const parts = hash.split('/');
                if (parts[1]) {
                  parts[1] = parts[1].replace(new RegExp(`([+~]${layerId}):follow`), '$1');
                }
                window.location.replace('#' + parts.join('/'));
              }, layerId);
            }
          }
        }
      }
    }, 0);
    // If requested as invisible, ensure visibility is set to none after adding
    if (visibility === 'none') {
      map.setLayoutProperty(layerId, 'visibility', 'none');
    }
    if (!allStyleLayers.some(l => l.id === layerId)) {
      allStyleLayers.push({ id: layerId, name: cleanId });
      styleDefaultVisibility[layerId] = 'visible';
    }
    createLayerControls(map, allStyleLayers.filter(l => map.getLayer(l.id) && map.getLayoutProperty(l.id, 'visibility') === 'visible').map(l => l.id));
  } catch (err) {
    alert('Error loading GeoJSON: ' + err.message);
    console.error(err);
  }
}

// Update hash from map state
function updateHash(map, visibleLayers) {
  const c = map.getCenter();
  const z = map.getZoom().toFixed(2);
  const b = map.getBearing().toFixed(1);
  const p = map.getPitch().toFixed(1);
  // Preserve existing layer part of hash if present
  const hash = window.location.hash.replace('#', '');
  const [, layersStr] = hash.split('/');
  const cameraStr = `${c.lat.toFixed(5)},${c.lng.toFixed(5)},${z},${b},${p}`;
  if (layersStr !== undefined) {
    window.location.replace(`#${cameraStr}/${layersStr}`);
  } else {
    window.location.replace(`#${cameraStr}`);
  }
}

// Create layer controls
function createLayerControls(map, visibleLayers) {
  const container = document.getElementById('layer-controls');
  container.innerHTML = '<strong>Layers</strong><br>';
  let foundLayer = false;
  // Always reflect the current style visibility for checkboxes
  // Parse current hash for explicit toggles
  const hash = window.location.hash.replace('#', '');
  const [, layersStr] = hash.split('/');
  const explicitState = {};
  if (layersStr) {
    layersStr.split(',').forEach(token => {
      const match = token.match(/^([+~])(.+)$/);
      if (!match) return;
      const [, sign, lname] = match;
      explicitState[lname] = sign;
    });
  }
  // Include all style layers and any geojson-above-* layers
  const allLayers = [
    ...allStyleLayers,
    ...map.getStyle().layers
      .filter(l => l.id.startsWith('geojson-above-') && !allStyleLayers.some(s => s.id === l.id))
      .map(l => ({ id: l.id }))
  ];
  // Order from highest (topmost) to lowest (bottommost)
  allLayers.reverse();
  allLayers.forEach(layer => {
    if (map.getLayer(layer.id)) {
      foundLayer = true;
      const vis = map.getLayoutProperty(layer.id, 'visibility');
      const defaultVis = styleDefaultVisibility[layer.id] || 'visible';
      let checked, bold, state, showReset = false;
      if (explicitState[layer.id] === '+') {
        checked = 'checked';
        bold = true;
        state = 'visible';
        showReset = (defaultVis !== 'visible');
      } else if (explicitState[layer.id] === '~') {
        checked = '';
        bold = true;
        state = 'hidden';
        showReset = (defaultVis !== 'none');
      } else {
        checked = (defaultVis === 'visible') ? 'checked' : '';
        bold = false;
        state = 'default';
        showReset = false;
      }
      let label = layer.name || layer.id;
      // Wrap the checkbox, label, and button in a span for easy removal
      container.innerHTML += `<span class="layer-list-item" data-layer-item="${layer.id}"><label style="${bold ? 'font-weight:bold;' : ''}"><input type="checkbox" data-layer="${layer.id}" ${checked}> ${label}</label>`;
      // For dynamic layers, show delete 'X' button instead of reset
      if (explicitState[layer.id] && !map.getStyle().layers.some(l => l.id === layer.id)) {
        container.innerHTML += ` <button data-delete="${layer.id}" title="Delete layer" style="font-size:1.1em;line-height:1;color:#c00;font-weight:bold;vertical-align:middle;padding:0 0.2em;">x</button>`;
      } else if (explicitState[layer.id]) {
        container.innerHTML += ` <button data-reset="${layer.id}" title="Reset to style default" style="font-size:1.1em;line-height:1;vertical-align:middle;padding:0 0.2em;">↻</button>`;
      }
      container.innerHTML += '</span><br>';
    }
  });
  if (!foundLayer) {
    container.innerHTML += '<em>No toggleable layers found in the current style.</em>';
  }
  container.querySelectorAll('input[type=checkbox]').forEach(cb => {
    cb.addEventListener('change', function() {
      const layerId = this.getAttribute('data-layer');
      if (!map.getLayer(layerId)) {
        console.warn(`Layer '${layerId}' not found in style.`);
        return;
      }
      // Parse current hash for explicit toggles
      const hash = window.location.hash.replace('#', '');
      const [cameraStr, layersStr] = hash.split('/');
      const explicitState = {};
      if (layersStr) {
        layersStr.split(',').forEach(token => {
          const match = token.match(/^([+~])(.+)$/);
          if (!match) return;
          const [, sign, lname] = match;
          explicitState[lname] = sign;
        });
      }
      // Toggle + or ~ in hash and set visibility
      if (this.checked) {
        explicitState[layerId] = '+';
        map.setLayoutProperty(layerId, 'visibility', 'visible');
      } else {
        explicitState[layerId] = '~';
        map.setLayoutProperty(layerId, 'visibility', 'none');
      }
      // Build new hash
      const tokens = Object.entries(explicitState).map(([lname, sign]) => `${sign}${lname}`);
      if (tokens.length > 0) {
        window.location.replace(`#${cameraStr}/${tokens.join(',')}`);
      } else {
        window.location.replace(`#${cameraStr}`);
      }
    });
  });

  // Add reset button listeners for style layers
  container.querySelectorAll('button[data-reset]').forEach(btn => {
    btn.addEventListener('click', function(e) {
      e.preventDefault();
      const layerId = this.getAttribute('data-reset');
      // Parse current hash for explicit toggles
      const hash = window.location.hash.replace('#', '');
      const [cameraStr, layersStr] = hash.split('/');
      const explicitState = {};
      if (layersStr) {
        layersStr.split(',').forEach(token => {
          const match = token.match(/^([+~])(.+)$/);
          if (!match) return;
          const [, sign, lname] = match;
          explicitState[lname] = sign;
        });
      }
      // Remove explicit toggle for this layer
      delete explicitState[layerId];
      // Style layer: restore style default
      const defaultVis = styleDefaultVisibility[layerId] || 'visible';
      map.setLayoutProperty(layerId, 'visibility', defaultVis);
      // Build new hash
      const tokens = Object.entries(explicitState).map(([lname, sign]) => `${sign}${lname}`);
      if (tokens.length > 0) {
        window.location.replace(`#${cameraStr}/${tokens.join(',')}`);
      } else {
        window.location.replace(`#${cameraStr}`);
      }
    });
  });

  // Add delete button listeners for dynamic layers
  container.querySelectorAll('button[data-delete]').forEach(btn => {
    btn.addEventListener('click', function(e) {
      e.preventDefault();
      const layerId = this.getAttribute('data-delete');
      // Parse current hash for explicit toggles
      const hash = window.location.hash.replace('#', '');
      const [cameraStr, layersStr] = hash.split('/');
      const explicitState = {};
      if (layersStr) {
        layersStr.split(',').forEach(token => {
          const match = token.match(/^([+~])(.+)$/);
          if (!match) return;
          const [, sign, lname] = match;
          explicitState[lname] = sign;
        });
      }
      // Remove explicit toggle for this layer
      delete explicitState[layerId];
      // Remove from map and state
      if (map.getLayer(layerId)) map.removeLayer(layerId);
      if (map.getSource(layerId)) map.removeSource(layerId);
      const idx = allStyleLayers.findIndex(l => l.id === layerId);
      if (idx !== -1) allStyleLayers.splice(idx, 1);
      delete styleDefaultVisibility[layerId];
      // Refresh the UI after deletion to ensure the list is in sync
      createLayerControls(map, allStyleLayers.filter(l => map.getLayer(l.id) && map.getLayoutProperty(l.id, 'visibility') === 'visible').map(l => l.id));
      // Remove from hash and update URL
      const tokens = Object.entries(explicitState).map(([lname, sign]) => `${sign}${lname}`);
      if (tokens.length > 0) {
        window.location.replace(`#${cameraStr}/${tokens.join(',')}`);
      } else {
        window.location.replace(`#${cameraStr}`);
      }
    });
  });
}

const { camera, layers } = parseHash();

const map = new mapboxgl.Map({
  container: 'map',
  style,
  center: camera.center,
  zoom: camera.zoom,
  bearing: camera.bearing,
  pitch: camera.pitch
});

map.on('load', () => {
  // Get all layers from the style
  allStyleLayers = map.getStyle().layers.map(l => ({ id: l.id }));
  // Store the style default visibility for each layer
  allStyleLayers.forEach(layer => {
    if (map.getLayer(layer.id)) {
      const styleLayer = map.getStyle().layers.find(l => l.id === layer.id);
      let vis = 'visible';
      if (styleLayer && styleLayer.layout && typeof styleLayer.layout.visibility !== 'undefined') {
        vis = styleLayer.layout.visibility;
      }
      styleDefaultVisibility[layer.id] = vis;
    }
  });
  // Only update the toggle list to reflect the current style visibility (do not use hash for initial state)
  createLayerControls(map, allStyleLayers.filter(l => map.getLayer(l.id) && map.getLayoutProperty(l.id, 'visibility') === 'visible').map(l => l.id));
  // Load any dynamic geojsons requested in the hash
  const { dynamicGeojsonToLoad } = parseHash();
  if (dynamicGeojsonToLoad && dynamicGeojsonToLoad.length) {
    dynamicGeojsonToLoad.forEach(name => {
      loadAndAddOrReplaceGeoJSON(name + '.geojson');
    });
  }
});

// Update hash on camera move
map.on('moveend', () => {
  // Only update camera part of hash, preserve layer toggles
  updateHash(map, []);
});

// Listen for hash changes (external navigation)
let isFreeCameraAnimating = false;
let pendingHashUpdate = null;
function followPathWithFreeCamera(map, coords, onComplete, layerId) {
  isFreeCameraAnimating = true;
  // Calculate total distance for constant speed
  function getDistance(a, b) {
    const R = 6371000;
    const toRad = Math.PI / 180;
    const dLat = (b[1] - a[1]) * toRad;
    const dLng = (b[0] - a[0]) * toRad;
    const lat1 = a[1] * toRad;
    const lat2 = b[1] * toRad;
    const aVal = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLng/2) * Math.sin(dLng/2);
    const c = 2 * Math.atan2(Math.sqrt(aVal), Math.sqrt(1-aVal));
    return R * c;
  }
  let totalDist = 0;
  for (let j = 1; j < coords.length; j++) totalDist += getDistance(coords[j-1], coords[j]);
  const duration = Math.max(2000, totalDist * 2); // ms, 2ms per meter, min 2s
  let startTime = null;
  let originalData = null;
  if (layerId) {
    const src = map.getSource(layerId);
    if (src && src._data) originalData = JSON.parse(JSON.stringify(src._data));
  }
  function getBearing(from, to) {
    // Calculate bearing in radians from point 'from' to point 'to'
    const rad = Math.PI / 180;
    const lat1 = from[1] * rad;
    const lat2 = to[1] * rad;
    const dLon = (to[0] - from[0]) * rad;
    const y = Math.sin(dLon) * Math.cos(lat2);
    const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
    let brng = Math.atan2(y, x);
    return brng;
  }

  function interpolateLine(coords, t) {
    // t in [0,1], returns the point at t along the line
    let dist = 0, segStart = coords[0], segEnd = coords[1], segIdx = 1;
    let total = 0;
    for (let j = 1; j < coords.length; j++) total += getDistance(coords[j-1], coords[j]);
    let target = t * total;
    for (let j = 1; j < coords.length; j++) {
      let segLen = getDistance(coords[j-1], coords[j]);
      if (dist + segLen >= target) {
        segStart = coords[j-1];
        segEnd = coords[j];
        segIdx = j;
        break;
      }
      dist += segLen;
    }
    let segT = (target - dist) / getDistance(segStart, segEnd);
    return [
      segStart[0] + (segEnd[0] - segStart[0]) * segT,
      segStart[1] + (segEnd[1] - segStart[1]) * segT
    ];
  }

  // Easing function (easeInOutQuad)
  function easeInOutQuad(x) {
    return x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2;
  }

  // Before animation: calculate offset of path's start from map center and preserve camera state
  const initialCamera = map.getFreeCameraOptions();
  const camAlt = initialCamera.position ? initialCamera.position.z : 6000;
  const camBearing = initialCamera.orientation && typeof initialCamera.orientation.bearing === 'number' ? initialCamera.orientation.bearing : 0;
  const camPitch = initialCamera.orientation && typeof initialCamera.orientation.pitch === 'number' ? initialCamera.orientation.pitch : 0;
  // Get current map center in Mercator
  const mapCenter = map.getCenter();
  const mapCenterMerc = mapboxgl.MercatorCoordinate.fromLngLat({lng: mapCenter.lng, lat: mapCenter.lat}, camAlt);
  // Get path start in Mercator
  const pathStartMerc = mapboxgl.MercatorCoordinate.fromLngLat({lng: coords[0][0], lat: coords[0][1]}, camAlt);
  // Offset vector from map center to path start
  const offsetX = pathStartMerc.x - mapCenterMerc.x;
  const offsetY = pathStartMerc.y - mapCenterMerc.y;
  // Camera state for smooth following
  let currentCameraPos, useOffset;
  if (Math.abs(offsetX) > 1e-10 || Math.abs(offsetY) > 1e-10) {
    currentCameraPos = new mapboxgl.MercatorCoordinate(mapCenterMerc.x, mapCenterMerc.y, mapCenterMerc.z);
    useOffset = true;
  } else {
    // If offset is zero, animate camera position along the path (classic follow)
    currentCameraPos = new mapboxgl.MercatorCoordinate(pathStartMerc.x, pathStartMerc.y, pathStartMerc.z);
    useOffset = false;
  }

  function animate(ts) {
    // Check if :follow is still present in the hash for this layer
    const hash = window.location.hash.replace('#', '');
    const [, layersStr] = hash.split('/');
    let stillFollowing = false;
    if (layersStr) {
      const tokens = layersStr.split(',');
      stillFollowing = tokens.some(token => token.match(new RegExp(`^[+~]${layerId}:follow$`)));
    }
    if (!stillFollowing) {
      isFreeCameraAnimating = false;
      if (layerId && originalData) {
        const src = map.getSource(layerId);
        if (src) src.setData(originalData);
      }
      if (typeof onComplete === 'function') onComplete();
      return;
    }
    if (!startTime) startTime = ts;
    let elapsed = ts - startTime;
    let t = Math.min(1, elapsed / duration);
    let tip = interpolateLine(coords, t);
    if (layerId) {
      const src = map.getSource(layerId);
      if (src) {
        // Find the last full point before tip
        let dist = 0, lastIdx = 0, total = 0;
        for (let j = 1; j < coords.length; j++) total += getDistance(coords[j-1], coords[j]);
        let target = t * total;
        for (let j = 1; j < coords.length; j++) {
          let segLen = getDistance(coords[j-1], coords[j]);
          if (dist + segLen >= target) {
            lastIdx = j-1;
            break;
          }
          dist += segLen;
        }
        const partialCoords = coords.slice(0, lastIdx+1).concat([tip]);
        const partialLine = {
          type: 'FeatureCollection',
          features: [
            {
              type: 'Feature',
              geometry: {
                type: 'LineString',
                coordinates: partialCoords
              },
              properties: {}
            }
          ]
        };
        src.setData(partialLine);
      }
    }
    let targetCameraPos;
    const tipMerc = mapboxgl.MercatorCoordinate.fromLngLat({lng: tip[0], lat: tip[1]}, camAlt);
    if (useOffset) {
      // Always keep the same offset from tip as original map center to path start
      targetCameraPos = new mapboxgl.MercatorCoordinate(
        tipMerc.x - offsetX,
        tipMerc.y - offsetY,
        camAlt
      );
    } else {
      // Move camera position along the path (classic follow)
      targetCameraPos = tipMerc;
    }
    const ease = 0.15;
    currentCameraPos.x += (targetCameraPos.x - currentCameraPos.x) * ease;
    currentCameraPos.y += (targetCameraPos.y - currentCameraPos.y) * ease;
    currentCameraPos.z = camAlt;
    // Set camera to always keep the same bearing and pitch as at start
    const camera = map.getFreeCameraOptions();
    camera.position = currentCameraPos;
    camera.lookAtPoint = { lng: tip[0], lat: tip[1], altitude: 0 };
    camera.orientation = {
      bearing: camBearing,
      pitch: camPitch
    };
    map.setFreeCameraOptions(camera);
    if (t < 1) {
      requestAnimationFrame(animate);
    } else {
      if (layerId && originalData) {
        const src = map.getSource(layerId);
        if (src) src.setData(originalData);
      }
      isFreeCameraAnimating = false;
      if (typeof onComplete === 'function') onComplete();
    }
  }
  requestAnimationFrame(animate);
}

window.addEventListener('hashchange', () => {
  if (!window._lastHashState) window._lastHashState = '';
  const currentHash = window.location.hash;
  if (window._lastHashState === currentHash) return;
  window._lastHashState = currentHash;

  const { camera, layers, dynamicGeojsonToLoad, followId } = parseHash();

  // If a followId is present (from +id:follow or ~id:follow), animate and block hash/camera updates until done
  // If followId is present, handle follow logic. If not, and animation is running, stop it and resume normal hash handling.
  if (!followId && isFreeCameraAnimating) {
    isFreeCameraAnimating = false;
  }
  if (followId && !isFreeCameraAnimating) {
    // 1. Check if the layer is loaded
    const source = map.getSource(followId);
    let layerLoaded = false;
    if (source && source._data && source._data.features) {
      layerLoaded = true;
    }
    if (!layerLoaded) {
      // Remove :follow from the hash
      const hash = window.location.hash.replace('#', '');
      const parts = hash.split('/');
      if (parts[1]) {
        parts[1] = parts[1].replace(new RegExp(`([+~]${followId}):follow`), '$1');
        window.location.replace('#' + parts.join('/'));
      }
      // Wait for the source to be fully loaded, then add :follow back
      const onSourceData = (e) => {
        if (e.sourceId === followId) {
          map.off('sourcedata', onSourceData);
          // Add :follow back to the hash
          const hash2 = window.location.hash.replace('#', '');
          const parts2 = hash2.split('/');
          if (parts2[1]) {
            // Find the token for this layer and add :follow
            parts2[1] = parts2[1].replace(new RegExp(`([+~]${followId})(?!:follow)`), `$1:follow`);
            window.location.replace('#' + parts2.join('/'));
          }
        }
      };
      map.on('sourcedata', onSourceData);
      return;
    }
    // If already loaded, proceed as before
    // 1. Set location using the hash camera location (immediately, no animation)
    const setOpts = {
      center: [camera.center[0], camera.center[1]],
      zoom: camera.zoom,
      bearing: camera.bearing,
      pitch: camera.pitch,
      animate: false
    };
    map.jumpTo(setOpts);
    console.log('[FOLLOW] 1. Set location using hash camera:', setOpts.center, 'zoom:', setOpts.zoom);

    // 2. Change visibility of existing layers
    const hashStr = window.location.hash.replace('#', '');
    const [, layersStr] = hashStr.split('/');
    const explicitState = {};
    if (layersStr) {
      layersStr.split(',').forEach(token => {
        const match = token.match(/^([+~])([^:]+)(:follow)?$/);
        if (!match) return;
        const [, sign, lname] = match;
        explicitState[lname] = sign;
      });
    }
    let removedIds = [];
    allStyleLayers.slice().forEach(layer => {
      const id = layer.id;
      if (!map.getStyle().layers.some(l => l.id === id) && explicitState[id] !== '+') {
        if (map.getLayer(id)) map.removeLayer(id);
        if (map.getSource(id)) map.removeSource(id);
        removedIds.push(id);
        delete styleDefaultVisibility[id];
      }
    });
    allStyleLayers = allStyleLayers.filter(l => !removedIds.includes(l.id));
    Object.entries(explicitState).forEach(([id, sign]) => {
      if (map.getLayer(id)) {
        if (sign === '+') {
          if (map.getLayoutProperty(id, 'visibility') !== 'visible') {
            map.setLayoutProperty(id, 'visibility', 'visible');
          }
        } else if (sign === '~') {
          if (map.getLayoutProperty(id, 'visibility') !== 'none') {
            map.setLayoutProperty(id, 'visibility', 'none');
          }
        }
      }
    });
    console.log('[FOLLOW] 2. Changed visibility of existing layers');

    // 3. Layer is now loaded (this function)
    console.log(`[FOLLOW] 3. Layer loaded: ${followId}`);

    // 4. Start following the line (after layer is loaded)
    function startFollow() {
      // Helper to extract coordinates from a source
      function getCoordsFromSource(source) {
        let coords = [];
        if (source && source._data && source._data.features) {
          source._data.features.forEach(f => {
            if (!f.geometry) return;
            if (f.geometry.type === 'LineString') coords = coords.concat(f.geometry.coordinates);
            if (f.geometry.type === 'Polygon') coords = coords.concat(f.geometry.coordinates[0]);
            if (f.geometry.type === 'MultiLineString') coords = coords.concat(...f.geometry.coordinates);
            if (f.geometry.type === 'MultiPolygon') coords = coords.concat(...f.geometry.coordinates.map(ring => ring[0]));
          });
        }
        return coords;
      }
      const source = map.getSource(followId);
      const coords = getCoordsFromSource(source);
      if (coords.length > 1) {
        console.log(`[FOLLOW] 4. Follow initiated for layer: ${followId}`);
        pendingHashUpdate = { camera, layers, dynamicGeojsonToLoad };
        followPathWithFreeCamera(map, coords, () => {
          pendingHashUpdate = null;
          // Remove :follow from the hash for this layer
          let hash = window.location.hash.replace('#', '');
          const parts = hash.split('/');
          if (parts[1]) {
            parts[1] = parts[1].replace(new RegExp(`([+~]${followId}):follow`), '$1');
          }
          window.location.replace('#' + parts.join('/'));
        }, followId);
      }
    }
    startFollow();
    return;
  }

  // If animating, do not update camera/hash
  if (isFreeCameraAnimating) return;

  // ...existing code for camera/layer/hash update...
  // If allStyleLayers is empty (e.g. on direct hash change before map load), repopulate it
  if (!allStyleLayers.length) {
    allStyleLayers = map.getStyle().layers.map(l => ({ id: l.id, name: l.name }));
    allStyleLayers.forEach(layer => {
      if (map.getLayer(layer.id)) {
        const styleLayer = map.getStyle().layers.find(l => l.id === layer.id);
        let vis = 'visible';
        if (styleLayer && styleLayer.layout && typeof styleLayer.layout.visibility !== 'undefined') {
          vis = styleLayer.layout.visibility;
        }
        styleDefaultVisibility[layer.id] = vis;
      }
    });
  }
  const flyOpts = {
    center: [camera.center[0], camera.center[1]],
    zoom: camera.zoom,
    bearing: camera.bearing,
    pitch: camera.pitch,
    duration: 1200
  };
  map.flyTo(flyOpts);

  // Only update visibility for layers explicitly in the hash as +id or ~id
  const hashStr = window.location.hash.replace('#', '');
  const [, layersStr] = hashStr.split('/');
  const explicitState = {};
  if (layersStr) {
    layersStr.split(',').forEach(token => {
      const match = token.match(/^([+~])(.+)$/);
      if (!match) return;
      const [, sign, lname] = match;
      explicitState[lname] = sign;
    });
  }

  let removedIds = [];
  allStyleLayers.slice().forEach(layer => {
    const id = layer.id;
    if (!map.getStyle().layers.some(l => l.id === id) && explicitState[id] !== '+') {
      if (map.getLayer(id)) map.removeLayer(id);
      if (map.getSource(id)) map.removeSource(id);
      removedIds.push(id);
      delete styleDefaultVisibility[id];
    }
  });
  allStyleLayers = allStyleLayers.filter(l => !removedIds.includes(l.id));

  Object.entries(explicitState).forEach(([id, sign]) => {
    if (map.getLayer(id)) {
      if (sign === '+') {
        if (map.getLayoutProperty(id, 'visibility') !== 'visible') {
          map.setLayoutProperty(id, 'visibility', 'visible');
        }
      } else if (sign === '~') {
        if (map.getLayoutProperty(id, 'visibility') !== 'none') {
          map.setLayoutProperty(id, 'visibility', 'none');
        }
      }
    }
  });

  if (dynamicGeojsonToLoad && dynamicGeojsonToLoad.length) {
    const { layers: layersOn } = parseHash();
    dynamicGeojsonToLoad.forEach(name => {
      if (!allStyleLayers.some(l => l.id === name)) {
        allStyleLayers.push({ id: name, name });
        styleDefaultVisibility[name] = 'visible';
      }
      // If not visible (not in layersOn), load as invisible
      if (!layersOn.includes(name)) {
        loadAndAddOrReplaceGeoJSON(name + '.geojson', { visibility: 'none' });
      } else {
        loadAndAddOrReplaceGeoJSON(name + '.geojson');
      }
    });
  }
  createLayerControls(map, allStyleLayers.filter(l => map.getLayer(l.id) && map.getLayoutProperty(l.id, 'visibility') === 'visible').map(l => l.id));
});
</script>
</body>
</html>