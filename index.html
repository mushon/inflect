<!DOCTYPE html>
<html>
<head>    
    <meta charset="UTF-8">
    <link rel="icon" type="image/svg+xml" sizes="any" href="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20100%20100%22%3E%3Ctext%20y%3D%221em%22%20font-size%3D%2290%22%3E%F0%9F%93%84%3C%2Ftext%3E%3C%2Fsvg%3E">

    <title>!nflect · Modulating Visualizations to Tell Stories with Data</title>
    <meta property="og:url" content="https://uclab.fh-potsdam.de/inflect/">
    <meta property="og:title" content="B'tselem / Displacement Journeys: Nibal Al-Hessi">
    <meta property="og:description" content="Web-based framework for inflections that bridge data exploration and storytelling">
    <meta property="og:image" content="https://uclab.fh-potsdam.de/inflect/img/cover.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">

    <script src="src/marked.min.js"></script>

    <link rel="stylesheet" href="src/base.css">
    <style>
        /* Layout is controlled by external CSS files: base.css is always loaded.
           Per-page theme files can be requested from Markdown via a marker; the
           JS below will detect and load them dynamically. */
    </style>
</head>

<body>

<div><iframe id="if"></iframe></div>

<main></main>

<script>
    // Track last path (excluding hash)
    let lastIframePath = null;
    let firstFrame = true;
    const iframe = document.getElementById('if');
    // Store per-element typewriter state (array of {node, original})
    const typewriterStore = new WeakMap();

    

    // Fade in once the iframe finishes loading
    iframe.addEventListener('load', () => {
      iframe.style.opacity = '1';
    });

    // Function to fetch and render the markdown
    async function renderMarkdown() {
        try {
            const hash = window.location.hash.substring(1); // Remove '#' from hash
            const file = hash ? hash : 'README';

            var title = document.title.split(" · ")[0];
            document.title = (file === "README") 
                             ? title
                             : `${title} · ${file}`;

            const response = await fetch(file + ".md"); 
            let text = await response.text();

            // --- Per-page CSS marker parsing ---
            function extractPageCssMarker(t) {
                // YAML front matter: look for css: path
                const fmRe = /^\s*---\n([\s\S]*?)\n---\s*\n?/;
                const fm = t.match(fmRe);
                if (fm) {
                    const body = fm[1];
                    const cssMatch = body.match(/^\s*css:\s*(.+)\s*$/m);
                    if (cssMatch) {
                        const path = cssMatch[1].trim().replace(/^['\"]|['\"]$/g, '');
                        t = t.replace(fmRe, '');
                        return { text: t, css: path };
                    }
                }

                // Single-line marker: {.css(src/path.css)} or {.css src/path.css}
                const markerRe = /^\s*\{\.css(?:\(\s*([^\)]+?)\s*\)|\s+([^\}\r\n]+))\}\s*(?:\r?\n){1,2}/;
                const m = t.match(markerRe);
                if (m) {
                    const path = (m[1] || m[2] || '').trim().replace(/^['\"]|['\"]$/g, '');
                    t = t.replace(markerRe, '');
                    return { text: t, css: path };
                }

                return { text: t, css: null };
            }

            function isSafeCssPath(p) {
                if (!p) return false;
                if (/^[a-zA-Z]+:\/\//.test(p) || p.startsWith('data:')) return false;
                if (p.includes('..')) return false;
                if (!/^(src|css|pages)\/[A-Za-z0-9_\-\/\.]+\.css$/.test(p)) return false;
                return true;
            }

            function applyPageCss(cssPath) {
                const id = 'page-css';
                const existing = document.getElementById(id);
                if (existing) existing.remove();
                if (!cssPath) return;
                if (!isSafeCssPath(cssPath)) { console.warn('Rejected unsafe page css path:', cssPath); return; }
                const link = document.createElement('link');
                link.id = id;
                link.rel = 'stylesheet';
                link.href = cssPath;
                document.head.appendChild(link);
            }

            const extracted = extractPageCssMarker(text);
            text = extracted.text;
            // Defer applying the page CSS until after render so it overrides base.
            const pageCssPath = extracted.css;
            // --- end per-page CSS marker parsing ---

                        // Detect and strip a leading body-class marker from the raw markdown before we wrap sections
                        // e.g. a file starting with `{.ltr}` should set body classes, not produce an empty section.
                        let pageBodyClasses = null;
                        // accept marker followed by either a blank line or just a single newline
                        const rawBodyMarkerRe = /^\s*\{\.([A-Za-z0-9_\- ]+)\}\s*(?:\r?\n){1,2}/;
                        const rawBm = text.match(rawBodyMarkerRe);
                        if (rawBm) {
                            pageBodyClasses = rawBm[1].trim().replace(/\s+/g, ' ');
                            text = text.replace(rawBodyMarkerRe, '');
                        }

                        // split sections by two empty lines (existing behavior)
                        text = text.replace(/\s*\n\s*\n\s*\n\s*/g, '\n\n</section>\n\n<section>\n\n');
                        text = "<section>\n\n" + text + "\n\n</section>";

                        // Preprocess section class markers: lines like `{.lead}` placed alone
                        // immediately after a section break will attach that class to the following <section>
                        function applySectionClasses(t) {
                            // 1) Marker immediately AFTER an opening <section> (attach class to that opening tag)
                            t = t.replace(/<section>\s*\n\s*\{\.([A-Za-z0-9_\- ]+)\}\s*\n\s*/g, (m, cls) => {
                                return `<section class="${cls.trim().replace(/\s+/g,' ')}">\n\n`;
                            });

                            // 2) Marker that appears right after a section split: close/open pair followed by marker
                            t = t.replace(/<\/section>\s*\n\s*<section>\s*\n\s*\{\.([A-Za-z0-9_\- ]+)\}\s*\n\s*/g, (m, cls) => {
                                return `</section>\n\n<section class="${cls.trim().replace(/\s+/g,' ')}">\n\n`;
                            });

                            // 3) Fallback: marker between paragraphs - create a new section with the class
                            t = t.replace(/\n\n\s*\{\.([A-Za-z0-9_\- ]+)\}\s*\n\n/g, (m, cls) => {
                                return `\n\n<section class="${cls.trim().replace(/\s+/g,' ')}">\n\n`;
                            });

                            return t;
                        }

                        text = applySectionClasses(text);
            
                        // (Previously we injected a `dontinflect` class into anchors. Revert that
                        // behavior so external links or arbitrary hrefs can be treated as
                        // inflection links. Leave anchors as authored.)

            // render markdown into HTML           
            let html = marked.parse(text);

            // skip footer when on inflect page
            if (document.URL!="https://uclab.fh-potsdam.de/inflect/") html = html + "\n<footer>a story made with <strong><a class='dontinflect' href='https://uclab.fh-potsdam.de/inflect/'>!nflect</a></strong></footer>";

                        document.querySelector('main').innerHTML = html;

                        // apply per-page css after rendering
                        try { applyPageCss(pageCssPath); } catch (e) { console.warn('Failed to apply page CSS', e); }

                        // If the markdown included a leading body-class marker, apply it to <body>
                        // Remove any previously applied classes from earlier renders (kept in data-body-classes)
                        try {
                            if (pageBodyClasses) {
                                const prev = document.body.getAttribute('data-body-classes');
                                if (prev) prev.split(' ').forEach(c => document.body.classList.remove(c));
                                pageBodyClasses.split(' ').forEach(c => document.body.classList.add(c));
                                document.body.setAttribute('data-body-classes', pageBodyClasses);
                            }
                        } catch (e) {
                            console.warn('Failed to apply body classes from markdown marker', e);
                        }

            // Convert plain images or image links that reference /img/ into
            // explicit links the parent page can observe. This function used
            // to exist and was removed during edits; reintroduce a small,
            // defensive implementation so callers don't throw.
            try {
                transformInflectionImages();
            } catch (e) {
                // Provide a lightweight fallback implementation inline
                (function transformInflectionImagesFallback() {
                    try {
                        const imgs = Array.from(document.querySelectorAll('img'));
                        imgs.forEach(img => {
                            const src = img.getAttribute('src') || '';
                            if (!src) return;
                            // If the image src appears to be inside the /img/ folder,
                            // ensure it's wrapped by an anchor so intersection/click
                            // handlers can detect it.
                            if (src.includes('/img/') || src.includes('/map/')) {
                                const parent = img.parentElement;
                                if (parent && parent.tagName.toLowerCase() === 'a') return;
                                const a = document.createElement('a');
                                a.href = src;
                                a.appendChild(img.cloneNode(true));
                                parent.replaceChild(a, img);
                            }
                        });
                    } catch (inner) {
                        // swallow — best-effort only
                    }
                })();
            }

            initializeObservers();

                // Setup typewriter animation: register elements; actual start is triggered
                // when the section's link becomes the active link and is loaded into the iframe.
                setupTypewriterAnimations();

            // return to old position
            if (location.hostname=="localhost") window.scrollTo(0, sessionStorage.getItem("scrollPosition") || 0);
        } catch (error) {
            console.error('Error fetching or rendering the markdown file:', error);
        }
    }

    // Update markdown when hash changes
        // Fade in new content only on path change
        function setIframeIfPathChanged(newHref) {
            const parsedURL = new URL(newHref, window.location.origin);
            const originalHash = parsedURL.hash || '';
            // compute path-only URL for comparison
            const pathOnly = new URL(parsedURL.href);
            pathOnly.hash = '';
            const newPath = pathOnly.href;

            if (newPath !== lastIframePath) {
                if (firstFrame) {
                    firstFrame = false;
                    iframe.style.opacity = '1';
                    iframe.src = newHref;
                } else {
                    if (iframe.style.opacity !== '0') {
                        iframe.style.opacity = '0';
                        setTimeout(() => {
                            iframe.src = newHref;
                        }, 400); // match transition duration
                    } else {
                        iframe.src = newHref;
                    }
                }
                lastIframePath = newPath;
            } else {
                // Only hash changed — assign src to force the iframe to pick up the
                // full hash token. This is more robust and avoids cross-window
                // access issues in browsers/environments used in tests.
                iframe.src = newHref;
            }
        }

    // Setup typewriter animation: find elements with .typewriter and animate them
    // in a simple, self-contained way. This replaces an earlier more complex
    // implementation that left stray variables in the file during a revert.
    function setupTypewriterAnimations() {
        const els = document.querySelectorAll('.typewriter');
        els.forEach(el => {
            // Store original HTML/text for later replay and mark as not started
            if (!typewriterStore.has(el)) {
                typewriterStore.set(el, { original: el.innerHTML, started: false });
            }
            // Do not start here — starts are triggered when the containing section
            // becomes active (its link is visible and forwarded to the iframe). 
        });
    }

    // Start typewriter animation for a single element if not already started.
    function startTypewriter(el) {
        if (!el) return;
        const info = typewriterStore.get(el) || { original: el.innerHTML, started: false };
        if (info.started) return;
        // If element contains an anchor with class 'active', do not animate it
        const anchor = el.querySelector('a');
        if (anchor && anchor.classList.contains('active')) return;

        // Begin animation
        info.started = true;
        typewriterStore.set(el, info);
        el.classList.add('cursor');

        if (anchor) {
            const anchorText = (anchor.textContent || '').trim();
            anchor.textContent = '';
            let idx = 0;
            const speed = 40;
            (function step() {
                if (idx <= anchorText.length) {
                    anchor.textContent = anchorText.slice(0, idx);
                    idx++;
                    setTimeout(step, speed);
                }
            })();
            return;
        }

        const text = (info.original || '').replace(/<[^>]+>/g, '').trim();
        el.textContent = '';
        let idx = 0;
        const speed = 40;
        (function step() {
            if (idx <= text.length) {
                el.textContent = text.slice(0, idx);
                idx++;
                setTimeout(step, speed);
            }
        })();
    }

    function startTypewriterForSection(section) {
        if (!section) return;
        const els = section.querySelectorAll('.typewriter');
        els.forEach(el => startTypewriter(el));
    }

    // with IntersectionObserver we can check what is visible    
    function initializeObservers() {
        const observer = new IntersectionObserver((entries) => {

            entries.forEach(entry => {
                if (entry.isIntersecting) {                    
                    // Add active class only to the visible link
                    const visibleLink = entry.target;
                    if (!visibleLink.classList.contains("dontinflect") && visibleLink.getAttribute("href") != "") {
                        visibleLink.classList.add('active');
                        // Update iframe, ignoring just changes
                        setIframeIfPathChanged(visibleLink.href);
                        // Start any typewriter animation for the section that contains this link
                        // after the iframe has been asked to load the path. Use a short delay
                        // to allow the iframe transition to start.
                        try {
                            const section = visibleLink.closest('section') || document.querySelector('main');
                            setTimeout(() => startTypewriterForSection(section), 450);
                        } catch (e) { /* swallow */ }
                    }
                }
                else entry.target.classList.remove("active")
            });
        });

        // Add observer to all links and attach click handlers to inflection links
        const inflectLinks = document.querySelectorAll('a');
        inflectLinks.forEach(link => {
            observer.observe(link);
            const hrefAttr = (link.getAttribute('href') || '').trim();
            // Treat any non-empty href as an inflection-link candidate. This allows
            // external URLs as well as local paths to be handled by the iframe
            // forwarding logic. Skip empty hrefs or javascript/mailto pseudo-links.
            const isInflection = hrefAttr && !hrefAttr.toLowerCase().startsWith('javascript:') && !hrefAttr.toLowerCase().startsWith('mailto:');
            if (isInflection) {
                // Add event listener to manually handle click
                link.addEventListener('click', function(event) {
                    document.querySelectorAll('a').forEach(a => a.classList.remove('active'));
                    link.classList.add('active');
                    setIframeIfPathChanged(link.href);
                    // Start typewriter for the section containing this link after a short delay
                    try { const sec = link.closest('section') || document.querySelector('main'); setTimeout(() => startTypewriterForSection(sec), 450); } catch (e) {}
                });
            } else {
                // mark external/non-inflection links so they can be styled differently
                link.classList.add('dontinflect');
            }
        });

        const firstLink = document.querySelector('main a:not(.dontinflect)');
        if (firstLink) {
            firstLink.classList.add('active');
            setIframeIfPathChanged(firstLink.href);
        }

    }

    // scroll up when pressing Escape
    document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape') {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
    });

    // Load, parse, and display markdown on page load
    renderMarkdown();
</script>
</body>
</html>
