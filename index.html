<!DOCTYPE html>
<html>
<head>    
    <meta charset="UTF-8">
    <link rel="icon" type="image/svg+xml" sizes="any" href="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20100%20100%22%3E%3Ctext%20y%3D%221em%22%20font-size%3D%2290%22%3E%F0%9F%93%84%3C%2Ftext%3E%3C%2Fsvg%3E">

    <title>!nflect · Modulating Visualizations to Tell Stories with Data</title>
    <meta property="og:url" content="https://uclab.fh-potsdam.de/inflect/">
    <meta property="og:title" content="B'tselem / Displacement Journeys: Nibal Al-Hessi">
    <meta property="og:description" content="the reality of millions in Gaza, told through the journey of one woman.">
    <meta property="og:image" content="img/cover.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">

    <script src="src/marked.min.js"></script>

    <base href="./">

    <link rel="stylesheet" href="src/base.css">
    <!-- Chapter navigation styles and behavior (global so scripts run reliably) -->
    <link rel="stylesheet" href="src/chapters.css">
    <script src="src/chapters.js" defer></script>
    <script src="src/hide-empty-anchors.js" defer></script>
    <style>
        /* Layout is controlled by external CSS files: base.css is always loaded.
           Per-page theme files can be requested from Markdown via a marker; the
           JS below will detect and load them dynamically. */

        /* Ensure the iframe itself uses a transparent background and fades
           smoothly without revealing an abrupt color behind it. */
        #if {
            background: transparent;
            transition: opacity 0.4s ease;
            opacity: 0; /* default to hidden until first frame shown */
            border: none;
            display: block;
            width: 100%;
            height: 100%;
        }

          /* We will adjust only the transparency (alpha) of the body's
              background during iframe fades via inline styles. Avoid making a
              permanent change to the default background color here. */
    </style>
</head>

<body>

<div><iframe id="if"></iframe></div>

<main></main>

<script>
        // Enable verbose debug logs during this investigation
        try { window.__inflectDebug = true; console.info('inflect: __inflectDebug = true'); } catch(e){}
        // Global smooth scroll helper used by both nav clicks and snap gestures.
        // Animates with an ease-out curve and duration proportional to distance
        // so the programmatic snap feels like a continuation of the user's
        // scroll gesture rather than an abrupt jump.
        window.__smoothScrollTo = function(scroller, to, opts) {
            try {
                opts = opts || {};
                const start = (scroller === document.scrollingElement || scroller === document.documentElement) ? (window.pageYOffset || document.documentElement.scrollTop || 0) : (scroller.scrollTop || 0);
                const distance = Math.max(-start, to - start); // clamp to avoid negative over-scroll
                const absDist = Math.abs(distance);
                // Duration grows with distance but is clamped so long trips don't feel slow
                const duration = opts.duration || Math.min(900, Math.max(300, Math.round(absDist * 0.45) + 150));
                const startTime = performance.now();

                // cubic ease-out
                function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }

                // Suppress other snap/scroll handlers while animating
                window.__snapSuppressUntil = Date.now() + duration + 80;
                window.__chaptersAnimating = true;
                window.__scrollAnimating = true;

                function step(now) {
                    const elapsed = Math.min(duration, Math.max(0, now - startTime));
                    const progress = easeOutCubic(elapsed / duration);
                    const cur = Math.round(start + (distance * progress));
                    try {
                        if (scroller === document.scrollingElement || scroller === document.documentElement) {
                            window.scrollTo(0, cur);
                        } else if (typeof scroller.scrollTo === 'function') {
                            scroller.scrollTo({ top: cur });
                        } else {
                            scroller.scrollTop = cur;
                        }
                    } catch(e) { /* swallow */ }

                    if (elapsed < duration) {
                        requestAnimationFrame(step);
                    } else {
                        // finish
                        try { if (scroller === document.scrollingElement || scroller === document.documentElement) window.scrollTo(0, to); else scroller.scrollTo({ top: to }); } catch(e){}
                        window.__chaptersAnimating = false;
                        window.__scrollAnimating = false;
                    }
                }

                requestAnimationFrame(step);
            } catch (e) { /* swallow */ }
        };
    // Track last path (excluding hash)
    let lastIframePath = null;
    let firstFrame = true;
    const iframe = document.getElementById('if');
    // (typewriter functionality removed)

    

    // Ensure iframe prefers a transparent background and allow transparency
    iframe.setAttribute('allowtransparency', 'true');
    iframe.setAttribute('frameborder', '0');
    iframe.style.background = 'transparent';

    // No body background modifications: fades should affect only the iframe
    // opacity. Keeping the code minimal and non-invasive avoids changing the
    // default body color under any circumstances.

        // Fade in once the iframe finishes loading. We only change the iframe's
        // opacity; do not modify the body's background or any other color.
        iframe.addEventListener('load', () => {
            iframe.style.opacity = '1';
        });

    // Function to fetch and render the markdown
    async function renderMarkdown() {
        // Prevent concurrent or re-entrant runs which can lead to duplicate
        // fetches and noisy logs (observed on some hosts / redirects).
        if (window.__renderMarkdownRunning) {
            console.debug('renderMarkdown: already running, skipping');
            return;
        }
        // Short suppression window: if we rendered successfully very recently,
        // skip to reduce console noise (2s).
        try {
            const now = Date.now();
            if (window.__lastRenderSuccessAt && (now - window.__lastRenderSuccessAt) < 2000) {
                console.debug('renderMarkdown: suppressed because successful render occurred within last 2s');
                return;
            }
        } catch(e){}
        window.__renderMarkdownRunning = true;
        try {
            const hash = window.location.hash.substring(1); // Remove '#' from hash
            // Strip :number suffix (e.g., 'draft:36' -> 'draft') for section jumping
            const file = hash ? hash.replace(/:\d+$/, '') : 'README';

            var title = document.title.split(" · ")[0];
            document.title = (file === "README") 
                             ? title
                             : `${title} · ${file}`;

            // Resolve candidate paths robustly for both GitHub Pages (repo subpath)
            // and local development. Build absolute URLs using location.origin + basePath
            // which points to the repository root directory for the current path.
            const origin = location.origin || ('https://' + location.host);
            const basePath = (location.pathname.endsWith('/') ? location.pathname : location.pathname.replace(/\/[^/]*$/, '/'));
            let candidatePaths = [];
            // Detect GitHub Pages hosting (served from github.io) to prefer HTML README
            const isGitHubPages = (location.hostname || '').endsWith('github.io') || (origin || '').includes('github.io');
            if (file === 'README') {
                // Try absolute paths first (handles GH Pages repo subpath).
                // On GitHub Pages prefer README.html early to avoid 404 noise when README.html is served.
                if (isGitHubPages) {
                    candidatePaths = [
                        origin + basePath + 'README.html',
                        origin + basePath + 'readme.md',
                        origin + basePath + 'README.md',
                        './README.html',
                        './readme.md',
                        './README.md',
                        'README.html',
                        'readme.md',
                        'README.md'
                    ];
                } else {
                    // Local/dev: prefer lowercase readme.md first then README variants and HTML
                    candidatePaths = [
                        origin + basePath + 'readme.md',
                        origin + basePath + 'README.md',
                        origin + basePath + 'README.html',
                        './README.html',
                        './readme.md',
                        './README.md',
                        'README.html',
                        'readme.md',
                        'README.md'
                    ];
                }
            } else {
                // For other files, try absolute HTML then MD, then relative fallbacks
                candidatePaths = [
                    origin + basePath + file + '.html',
                    origin + basePath + file + '.md',
                    file + '.html',
                    './' + file + '.html',
                    file + '.md',
                    './' + file + '.md',
                    origin + basePath + 'README.html',
                    origin + basePath + 'readme.md',
                    'README.html',
                    'README.md'
                ];
            }
            // Deduplicate candidatePaths while preserving order to avoid redundant fetches
            candidatePaths = candidatePaths.filter((v, i, a) => a.indexOf(v) === i);

            // If we recently rendered successfully and the same candidate is in the
            // candidate list, skip this run to avoid duplicate fetches/console noise.
            try {
                const now = Date.now();
                if (window.__lastRenderSuccessAt && (now - window.__lastRenderSuccessAt) < 2000 && window.__lastRenderSuccessCandidate) {
                    const last = window.__lastRenderSuccessCandidate;
                    if (candidatePaths.indexOf(last) !== -1) {
                        console.debug('renderMarkdown: skipping because recent successful render of', last);
                        try { window.__renderMarkdownRunning = false; } catch(e){}
                        return;
                    }
                }
            } catch(e){}
            let response = null;
            let text = null;
            let successPath = null;
            for (const p of candidatePaths) {
                try {
                    if (window && window.__inflectDebug) console.debug('renderMarkdown: trying', p);
                    response = await fetch(p, {cache: 'no-store'});
                    if (response && response.ok) {
                        text = await response.text();
                        if (window && window.__inflectDebug) console.debug('renderMarkdown: fetched', p);
                        successPath = p;
                        break;
                    } else {
                        if (window && window.__inflectDebug) console.debug('renderMarkdown: not ok', p, response && response.status);
                    }
                } catch (e) {
                    if (window && window.__inflectDebug) console.debug('renderMarkdown: fetch error', p, e && e.message);
                    // ignore and try next
                }
            }
            if (!text) {
                if (window && window.__inflectDebug) console.debug('renderMarkdown: no candidate succeeded');
            }

            if (!text) {
                console.error('renderMarkdown: failed to fetch any candidate path. Tried:', candidatePaths);
                throw new Error('Could not fetch markdown for: ' + file + ' (checked ' + candidatePaths.join(', ') + ')');
            }

            // --- Per-page front-matter and CSS marker parsing ---
            // Extract YAML front-matter keys `css` and `body-class` (simple, line-based)
            function extractFrontMatter(t) {
                const fmRe = /^\s*---\n([\s\S]*?)\n---\s*\n?/;
                const fm = t.match(fmRe);
                if (fm) {
                    const body = fm[1];
                    const cssMatch = body.match(/^\s*css:\s*(.+)\s*$/m);
                    const bcMatch = body.match(/^\s*body-class:\s*(.+)\s*$/m);
                    const cssPath = cssMatch ? cssMatch[1].trim().replace(/^['\"]|['\"]$/g, '') : null;
                    const bodyClass = bcMatch ? bcMatch[1].trim().replace(/^['\"]|['\"]$/g, '') : null;
                    t = t.replace(fmRe, '');
                    return { text: t, css: cssPath, bodyClass };
                }

                // Single-line marker: {.css(src/path.css)} or {.css src/path.css}
                const markerRe = /^\s*\{\.css(?:\(\s*([^\)]+?)\s*\)|\s+([^\}\r\n]+))\}\s*(?:\r?\n){1,2}/;
                const m = t.match(markerRe);
                if (m) {
                    const path = (m[1] || m[2] || '').trim().replace(/^['\"]|['\"]$/g, '');
                    t = t.replace(markerRe, '');
                    return { text: t, css: path, bodyClass: null };
                }

                return { text: t, css: null, bodyClass: null };
            }

            function isSafeCssPath(p) {
                if (!p) return false;
                if (/^[a-zA-Z]+:\/\//.test(p) || p.startsWith('data:')) return false;
                if (p.includes('..')) return false;
                if (!/^(src|css|pages)\/[A-Za-z0-9_\-\/\.]+\.css$/.test(p)) return false;
                return true;
            }

            function applyPageCss(cssPath) {
                const id = 'page-css';
                const existing = document.getElementById(id);
                if (existing) existing.remove();
                if (!cssPath) return;
                if (!isSafeCssPath(cssPath)) { console.warn('Rejected unsafe page css path:', cssPath); return; }
                const link = document.createElement('link');
                link.id = id;
                link.rel = 'stylesheet';
                link.href = cssPath;
                document.head.appendChild(link);
            }

            const extracted = extractFrontMatter(text);
            text = extracted.text;
            // Defer applying the page CSS until after render so it overrides base.
            const pageCssPath = extracted.css;
            const fmBodyClass = extracted.bodyClass;
            // --- end per-page CSS marker parsing ---

                // On GitHub Pages the repository is often served as generated HTML
                // which may not include the original `css: src/theme.css` marker.
                // As a fallback, attempt to load `src/theme.css` from the repo root
                // (origin + basePath) if it exists — this ensures our fonts and
                // theme definitions load when the page was built by Jekyll.
                async function tryApplyRepoTheme(){
                    try {
                        if (pageCssPath) return; // page explicitly requested CSS, respect it
                        // Only try for README on GitHub Pages or when basePath looks repo-rootish
                        const themeCandidates = [
                            origin + basePath + 'src/theme.css',
                            origin + basePath + 'src/theme.min.css',
                            origin + basePath + 'src/base.css'
                        ];
                        for (const tc of themeCandidates) {
                            try {
                                const r = await fetch(tc, { method: 'HEAD', cache: 'no-store' });
                                if (r && r.ok) {
                                    // inject link if not already present
                                    if (!document.querySelector('link[href="' + tc + '"]')) {
                                        const l = document.createElement('link');
                                        l.rel = 'stylesheet';
                                        l.href = tc;
                                        l.id = 'repo-theme-css';
                                        document.head.appendChild(l);
                                    }
                                    return;
                                }
                            } catch(e) { /* ignore and try next */ }
                        }
                    } catch(e) { /* swallow */ }
                }

                        // Detect and strip a leading body-class marker from the raw markdown before we wrap sections
                        // e.g. a file starting with `{.ltr}` should set body classes, not produce an empty section.
                        // Prefer body-class from YAML front-matter if present, otherwise accept the inline `{.cls}` marker.
                        let pageBodyClasses = fmBodyClass || null;
                        // accept marker followed by either a blank line or just a single newline
                        const rawBodyMarkerRe = /^\s*\{\.([A-Za-z0-9_\- ]+)\}\s*(?:\r?\n){1,2}/;
                        const rawBm = text.match(rawBodyMarkerRe);
                        if (rawBm) {
                            pageBodyClasses = rawBm[1].trim().replace(/\s+/g, ' ');
                            text = text.replace(rawBodyMarkerRe, '');
                        }

                        // split sections by two empty lines (existing behavior)
                        text = text.replace(/\s*\n\s*\n\s*\n\s*/g, '\n\n</section>\n\n<section>\n\n');
                        text = "<section>\n\n" + text + "\n\n</section>";

                        // Preprocess section class markers: lines like `{.lead}` placed alone
                        // immediately after a section break will attach that class to the following <section>
                        function applySectionClasses(t) {
                            // 1) Marker immediately AFTER an opening <section> (attach class to that opening tag)
                            t = t.replace(/<section>\s*\n\s*\{\.([A-Za-z0-9_\- ]+)\}\s*\n\s*/g, (m, cls) => {
                                return `<section class="${cls.trim().replace(/\s+/g,' ')}">\n\n`;
                            });

                            // 2) Marker that appears right after a section split: close/open pair followed by marker
                            t = t.replace(/<\/section>\s*\n\s*<section>\s*\n\s*\{\.([A-Za-z0-9_\- ]+)\}\s*\n\s*/g, (m, cls) => {
                                return `</section>\n\n<section class="${cls.trim().replace(/\s+/g,' ')}">\n\n`;
                            });

                            // 3) Fallback: marker between paragraphs - create a new section with the class
                            t = t.replace(/\n\n\s*\{\.([A-Za-z0-9_\- ]+)\}\s*\n\n/g, (m, cls) => {
                                return `\n\n<section class="${cls.trim().replace(/\s+/g,' ')}">\n\n`;
                            });

                            return t;
                        }

                        text = applySectionClasses(text);
            
                        // (Previously we injected a `dontinflect` class into anchors. Revert that
                        // behavior so external links or arbitrary hrefs can be treated as
                        // inflection links. Leave anchors as authored.)

            // If the fetched resource looks like a full HTML page (GitHub Pages or Jekyll
            // may serve HTML instead of raw markdown), parse it and extract the
            // body/main content. Otherwise treat as markdown and render via marked.
            let html = '';
            try {
                const looksLikeHtml = /(^\s*<!doctype)|(<html[\s>])|(<body[\s>])/i.test(text);
                if (looksLikeHtml) {
                    const dp = new DOMParser();
                    const doc = dp.parseFromString(text, 'text/html');
                    // Prefer an explicit <main> if present in the fetched HTML
                    const mainEl = doc.querySelector('main');
                    html = mainEl ? mainEl.innerHTML : (doc.body ? doc.body.innerHTML : text);
                    // If the fetched HTML carried stylesheet links in its head, import
                    // them safely (only same-origin or clearly safe relative paths).
                    try {
                        const headLinks = Array.from(doc.querySelectorAll('link[rel="stylesheet"]'));
                        headLinks.forEach(l => {
                            const href = l.getAttribute('href');
                            if (href && /^(\/|\.\/|\.\.\/|src\/|css\/)/.test(href)) {
                                const id = 'page-css-' + btoa(href).replace(/=/g,'');
                                if (!document.getElementById(id)) {
                                    const link = document.createElement('link'); link.rel = 'stylesheet'; link.href = href; link.id = id; document.head.appendChild(link);
                                }
                            }
                        });
                    } catch(e){}
                } else {
                    html = marked.parse(text);
                }
            } catch(e) {
                html = marked.parse(text);
            }

            // Strip any <meta> or <link rel="stylesheet"> tags that may have been
            // included in the content. Injecting these into the document body
            // creates warnings and causes browsers to ignore CSP meta tags that
            // appear outside of <head>. Remove them from the rendered HTML.
            try {
                html = html.replace(/<meta[\s\S]*?>/gi, '');
                html = html.replace(/<link[^>]*rel=["']?stylesheet["']?[^>]*>/gi, '');
            } catch (e) { /* swallow */ }

            // skip footer when on inflect page
            if (document.URL!="https://uclab.fh-potsdam.de/inflect/") html = html + "\n<footer>a story made with <strong><a class='dontinflect' href='https://uclab.fh-potsdam.de/inflect/'>!nflect</a></strong></footer>";

                        document.querySelector('main').innerHTML = html;
                        try { console.info('renderMarkdown: rendered', successPath || '(inferred)', 'body-class=', pageBodyClasses || '(none)'); } catch(e){}

                        // Record successful render so immediate duplicate invocations can be skipped
                        try { window.__lastRenderSuccessAt = Date.now(); window.__lastRenderSuccessCandidate = successPath || null; } catch(e){}

                        // apply per-page css after rendering
                            try { applyPageCss(pageCssPath); } catch (e) { console.warn('Failed to apply page CSS', e); }
                            try { tryApplyRepoTheme(); } catch(e){}

                        // If the markdown included a leading body-class marker, apply it to <body>
                        // Remove any previously applied classes from earlier renders (kept in data-body-classes)
                        try {
                            if (pageBodyClasses) {
                                const prev = document.body.getAttribute('data-body-classes');
                                if (prev) prev.split(' ').forEach(c => document.body.classList.remove(c));
                                pageBodyClasses.split(' ').forEach(c => document.body.classList.add(c));
                                document.body.setAttribute('data-body-classes', pageBodyClasses);
                            }
                        } catch (e) {
                            console.warn('Failed to apply body classes from markdown marker', e);
                        }

            // Convert plain images or image links that reference /img/ into
            // explicit links the parent page can observe. This function used
            // to exist and was removed during edits; reintroduce a small,
            // defensive implementation so callers don't throw.
            try {
                transformInflectionImages();
            } catch (e) {
                // Provide a lightweight fallback implementation inline
                (function transformInflectionImagesFallback() {
                    try {
                        const imgs = Array.from(document.querySelectorAll('img'));
                        imgs.forEach(img => {
                            const src = img.getAttribute('src') || '';
                            if (!src) return;
                            // If the image src appears to be inside the /img/ folder,
                            // ensure it's wrapped by an anchor so intersection/click
                            // handlers can detect it.
                            if (src.includes('/img/') || src.includes('/map/')) {
                                const parent = img.parentElement;
                                if (parent && parent.tagName.toLowerCase() === 'a') return;
                                const a = document.createElement('a');
                                a.href = src;
                                a.appendChild(img.cloneNode(true));
                                parent.replaceChild(a, img);
                            }
                        });
                    } catch (inner) {
                        // swallow — best-effort only
                    }
                })();
            }

            try { console.info('initializeObservers: about to run'); } catch(e){}
            initializeObservers();
            // Observe sections so empty/anchor-only links inside sections are detected
            try {
                const secs = Array.from(document.querySelectorAll('main section'));
                secs.forEach(s => {
                    try { if (s.querySelector('a:not(.dontinflect)')) sectionObserver.observe(s); } catch(e){}
                });
            } catch(e){}

                // Pin behavior removed: no automatic scroll-to-`.pin` is performed.

                // (typewriter functionality removed)

            // return to old position (don't override explicit hash navigation)
            try{
                const hasExplicitHash = (window.location.hash || '').length > 1;
                if (location.hostname === 'localhost' && !hasExplicitHash) {
                    window.scrollTo(0, sessionStorage.getItem('scrollPosition') || 0);
                }
            }catch(e){}
        } catch (error) {
            console.error('Error fetching or rendering the markdown file:', error);
        }
    }

    // Update markdown when hash changes
        // Fade in new content only on path change
        function setIframeIfPathChanged(newHref) {
            const parsedURL = new URL(newHref, window.location.origin);
            const originalHash = parsedURL.hash || '';
            // compute path-only URL for comparison
            const pathOnly = new URL(parsedURL.href);
            pathOnly.hash = '';
            const newPath = pathOnly.href;

            if (newPath !== lastIframePath) {
                if (firstFrame) {
                    firstFrame = false;
                    iframe.style.opacity = '1';
                    iframe.src = newHref;
                } else {
                    if (iframe.style.opacity !== '0') {
                        // Only fade the iframe itself to transparent; do not touch
                        // the body's background color.
                        iframe.style.opacity = '0';
                        setTimeout(() => {
                            iframe.src = newHref;
                        }, 400); // match transition duration
                    } else {
                        iframe.src = newHref;
                    }
                }
                lastIframePath = newPath;
            } else {
                // Only hash changed — assign src to force the iframe to pick up the
                // full hash token. This is more robust and avoids cross-window
                // access issues in browsers/environments used in tests.
                iframe.src = newHref;
            }
        }

        // Schedule iframe updates slightly later to allow DOM mutations (e.g. typewriter)
        let __iframeNextTimeout = null;
        function setIframeNext(href, delay = 60, waitForSection = true){
            try { if (__iframeNextTimeout) clearTimeout(__iframeNextTimeout); } catch(e){}
            __iframeNextTimeout = setTimeout(() => {
                // Try to find the anchor in the document and its containing section
                try {
                    if (waitForSection) {
                        let resolved = null;
                        try {
                            const targetURL = new URL(href, window.location.href).href;
                            // Iterate anchors and normalize their href attributes to compare
                            const as = Array.from(document.querySelectorAll('a'));
                            for (const a of as) {
                                const raw = a.getAttribute && a.getAttribute('href');
                                if (!raw) continue;
                                try {
                                    const norm = new URL(raw, window.location.href).href;
                                    if (norm === targetURL) { resolved = a; break; }
                                } catch(e) { /* ignore invalid hrefs */ }
                            }
                            try { if (window && window.__inflectDebug) console.debug('setIframeNext resolved anchor for', href, '->', resolved); } catch(e){}
                        } catch(e) { /* ignore */ }
                        if (resolved) {
                            const sec = resolved.closest && resolved.closest('section');
                            if (sec && sec.getAttribute('data-tw-active') === '1') {
                                // wait for typewriter:done (event), fallback to timeout
                                let done = false;
                                const onDone = () => { if (!done) { done = true; try { sec.removeEventListener('typewriter:done', onDone); } catch(e){}; setIframeIfPathChanged(href); __iframeNextTimeout = null; } };
                                try { sec.addEventListener('typewriter:done', onDone); } catch(e){}
                                try { if (window && window.__inflectDebug) console.debug('setIframeNext waiting for typewriter:done on', sec); } catch(e){}
                                const maxWait = 1400;
                                setTimeout(() => { if (!done) { done = true; try { sec.removeEventListener('typewriter:done', onDone); } catch(e){}; try { if (window && window.__inflectDebug) console.debug('setIframeNext timeout while waiting for', sec); } catch(e){}; setIframeIfPathChanged(href); __iframeNextTimeout = null; } }, maxWait);
                                return;
                            }
                        }
                    }
                } catch(e) { /* swallow */ }
                try { setIframeIfPathChanged(href); } catch(e){}
                __iframeNextTimeout = null;
            }, delay);
        }

    // (typewriter functionality removed)

    // Track recent direct user input (wheel/touch/keyboard/pointer) so we can
    // distinguish user gestures from programmatic navigation. This is used by
    // the section observer to decide whether a section entering view should
    // trigger a programmatic centering scroll (same function used by navbar).
    window.__userInputAt = 0;
    function __markUserInput(e) {
        // For key events, only treat navigation keys as user gestures
        if (e && e.type === 'keydown') {
            if (!['ArrowUp','ArrowDown','PageUp','PageDown',' '].includes(e.key)) return;
        }
        try { window.__userInputAt = Date.now(); } catch (err) { /* swallow */ }
    }
    ['wheel','touchstart','touchmove','pointerdown','keydown'].forEach(evt => {
        try { window.addEventListener(evt, __markUserInput, { passive: true }); } catch(e){}
    });

    // with IntersectionObserver we can check what is visible    
    function initializeObservers() {
        const observer = new IntersectionObserver((entries) => {

            entries.forEach(entry => {
                if (entry.isIntersecting) {                    
                    // Add active class only to the visible link
                    const visibleLink = entry.target;
                        if (!visibleLink.classList.contains("dontinflect") && visibleLink.getAttribute("href") != "") {
                        visibleLink.classList.add('active');
                        // Use the raw href attribute to avoid races where scripts
                        // (e.g. the typewriter) mutate link textContent or href.
                        const rawHref = visibleLink.getAttribute('href');
                        try { const full = new URL(rawHref, window.location.href).href; setIframeNext(full); } catch(e){ setIframeNext(visibleLink.href); }
                        // Start any typewriter animation for the section that contains this link
                        // after the iframe has been asked to load the path. Use a short delay
                        // to allow the iframe transition to start.
                        try {
                            const section = visibleLink.closest('section') || document.querySelector('main');
                            // (typewriter removed)
                        } catch (e) { /* swallow */ }
                    }
                }
                else entry.target.classList.remove("active")
            });
        });

        // Also observe sections: some markdown creates empty anchors inside
        // section blocks (e.g. `[](vid/#...)` with no link text). Empty anchors
        // have no layout box and won't trigger the link observer. Observe
        // sections and when a section enters view, pick its first inflection
        // link and update the iframe accordingly.
        const sectionObserver = new IntersectionObserver((entries) => {
            entries.forEach(en => {
                if (en.isIntersecting) {
                    try {
                        const sec = en.target;
                        const a = sec.querySelector('a:not(.dontinflect)');
                        if (!a) return;
                        const raw = a.getAttribute('href') || '';
                        if (!raw) return;
                        // Determine whether this intersection was likely caused by
                        // a direct user gesture (scroll/trackpad/keyboard) rather
                        // than a programmatic navigation (nav click / scripted scroll).
                        const now = Date.now();
                        const recentUser = (now - (window.__userInputAt || 0)) < 700; // ms
                        const programmaticScrollActive = !!(window.__scrollAnimating || (window.__snapSuppressUntil && now < window.__snapSuppressUntil));

                        // If a recent user gesture occurred and no programmatic
                        // scroll suppression is active, perform the same centering
                        // calculation used by navbar buttons. We intentionally
                        // duplicate the minimal centering logic here rather than
                        // depending on a global helper so this page works even if
                        // `chapters.js` hasn't exposed a function.
                        if (recentUser && !programmaticScrollActive) {
                            try {
                                const scroller = document.querySelector('main') || document.scrollingElement || document.documentElement;
                                const viewportHeight = (scroller && scroller.clientHeight) || window.innerHeight;
                                const targetTop = sec.getBoundingClientRect().top + (scroller ? scroller.scrollTop : (window.pageYOffset || 0));
                                const centeredTop = targetTop - (viewportHeight / 2) + (sec.offsetHeight / 2);

                                // Suppress other snap/key handlers while animating
                                window.__snapSuppressUntil = Date.now() + 700;
                                window.__chaptersAnimating = true;

                                if (window.__smoothScrollTo) {
                                    window.__smoothScrollTo(scroller, centeredTop, { source: 'observer' });
                                } else {
                                    try {
                                        if (scroller === document.scrollingElement || scroller === document.documentElement) {
                                            window.scrollTo({ top: centeredTop, behavior: 'smooth' });
                                        } else {
                                            scroller.scrollTo({ top: centeredTop, behavior: 'smooth' });
                                        }
                                    } catch(e){}
                                    setTimeout(() => { window.__chaptersAnimating = false; }, 1000);
                                }
                            } catch (e) { /* swallow */ }
                        }

                        try { const full = new URL(raw, window.location.href).href; setIframeNext(full); } catch(e){ setIframeNext(a.href); }
                    } catch(e) { /* swallow */ }
                    sectionObserver.unobserve(en.target);
                }
            });
        }, { threshold: 0.25 });

        // If the page requests `body.snap`, enable page-centering snap behavior.
        // This magnetizes sections to the center of the viewport and installs
        // wheel/keyboard handlers to flip between sections.
        if (document.body.classList && document.body.classList.contains('snap')) {
            // Choose the element that actually scrolls. Prefer <main> only if it
            // is scrollable; fall back to the document scrolling element otherwise.
            function chooseScroller() {
                const mainEl = document.querySelector('main');
                try {
                    if (mainEl && mainEl.scrollHeight > (mainEl.clientHeight || 0)) return mainEl;
                } catch(e){}
                return (document.scrollingElement || document.documentElement);
            }
            const scroller = chooseScroller();
            try { console.info('snap: attached to scroller ->', scroller && (scroller.tagName || scroller.nodeName)); } catch(e){}

            // Helper to compute the index of the section closest to scroller center
            function _snapCurrentIndex() {
                const secs = Array.from(scroller.querySelectorAll('section'));
                if (!secs.length) return 0;
                const viewCenter = (scroller.clientHeight || window.innerHeight) / 2;
                const scrollTop = scroller.scrollTop || 0;
                let best = 0, bestDist = Infinity;
                secs.forEach((s, i) => {
                    const secCenter = s.offsetTop + s.offsetHeight / 2;
                    const d = Math.abs(secCenter - (scrollTop + viewCenter));
                    if (d < bestDist) { bestDist = d; best = i; }
                });
                return best;
            }

            function _snapToSection(sec, smooth = true) {
                try {
                    const top = Math.max(0, sec.offsetTop - Math.round((scroller.clientHeight - sec.offsetHeight) / 2));
                    // If our global helper exists, use it for a softer, velocity-like animation
                    if (window.__smoothScrollTo && smooth) {
                        window.__smoothScrollTo(scroller, top, { source: 'snap' });
                    } else {
                        // fallback to native smooth behavior
                        try { window.__snapSuppressUntil = Date.now() + 700; } catch(e){}
                        if (scroller === document.scrollingElement || scroller === document.documentElement) {
                            window.scrollTo({ top, behavior: smooth ? 'smooth' : 'auto' });
                        } else {
                            scroller.scrollTo({ top, behavior: smooth ? 'smooth' : 'auto' });
                        }
                    }
                } catch (e) { /* swallow */ }
            }

            // Observe sections within the scroller
            const snapObserver = new IntersectionObserver((entries) => {
                entries.forEach(en => {
                    if (en.isIntersecting) {
                        try {
                            const sec = en.target;
                            const now = Date.now() || 0;
                            // Avoid snapping while programmatic snap suppression is active
                            if (now > (window.__snapSuppressUntil || 0)) {
                                _snapToSection(sec, true);
                            }
                        } catch (e) {}
                    }
                });
            }, { root: scroller, threshold: 0.55 });

            // Attach snap observer to each section
            try {
                const _secs = Array.from(scroller.querySelectorAll('section'));
                _secs.forEach(s => snapObserver.observe(s));
            } catch(e) { /* swallow */ }

            // Non-passive wheel listener to intercept and flip pages — attach to scroller
            try {
                // Accumulator for small trackpad deltas: many trackpads emit many
                // small wheel events that never cross the per-event threshold. We
                // accumulate small deltas over a short window and when the total
                // exceeds `smallGestureThreshold` we treat it as an intentional
                // flick and snap to the next/previous section.
                let __gestureAccumulator = 0;
                let __gestureLastDir = 0;
                let __gestureTimer = null;
                const __smallGestureThreshold = 60; // px accumulated
                const __gestureTimeoutMs = 140; // ms to wait for gesture series to finish

                scroller.addEventListener('wheel', (ev) => {
                    try {
                        if (Date.now() < (window.__snapSuppressUntil || 0)) return;
                        // mark that scroller-level wheel events are being observed
                        try { window.__snapListenerConfirmed = true; } catch(e){}

                        // If event originated inside an element that should not snap (e.g. maps), skip
                        const path = ev.composedPath && ev.composedPath();
                        for (const node of (path || [])) {
                            if (!node || !node.nodeType) continue;
                            const el = node;
                            if (el.classList && (el.classList.contains('no-snap') || el.closest && el.closest('.no-snap'))) return;
                        }

                        const delta = ev.deltaY || 0;
                        const abs = Math.abs(delta);
                        const dir = delta > 0 ? 1 : -1;

                        // Fast, large wheel deltas: immediate snap (mouse wheel)
                        if (abs >= 16) {
                            try { ev.preventDefault(); ev.stopPropagation(); } catch(e){}
                            const secs = Array.from(scroller.querySelectorAll('section'));
                            if (!secs.length) return;
                            const idx = _snapCurrentIndex();
                            const nextIdx = delta > 0 ? Math.min(secs.length - 1, idx + 1) : Math.max(0, idx - 1);
                            if (nextIdx !== idx) _snapToSection(secs[nextIdx], true);
                            try { console.info('snap: immediate wheel snap to', nextIdx); } catch(e){}
                            // clear any in-progress accumulator state
                            __gestureAccumulator = 0; __gestureLastDir = 0; if (__gestureTimer) { clearTimeout(__gestureTimer); __gestureTimer = null; }
                            return;
                        }

                        // Small deltas (typical of trackpads): accumulate briefly
                        if (abs > 0) {
                            if (__gestureLastDir && __gestureLastDir !== dir) {
                                // direction changed — reset accumulator to avoid mixing
                                __gestureAccumulator = 0;
                            }
                            __gestureLastDir = dir;
                            __gestureAccumulator += abs;

                            // If accumulator crosses threshold now, snap immediately
                            if (__gestureAccumulator >= __smallGestureThreshold) {
                                try { ev.preventDefault(); ev.stopPropagation(); } catch(e){}
                                const secs = Array.from(scroller.querySelectorAll('section'));
                                if (secs.length) {
                                    const idx = _snapCurrentIndex();
                                    const nextIdx = __gestureLastDir > 0 ? Math.min(secs.length - 1, idx + 1) : Math.max(0, idx - 1);
                                    if (nextIdx !== idx) {
                                        window.__snapSuppressUntil = Date.now() + 700;
                                        try { console.info('snap: accumulated immediate snap to', nextIdx, 'acc=', __gestureAccumulator); } catch(e){}
                                        _snapToSection(secs[nextIdx], true);
                                    }
                                }
                                // reset accumulator and clear timer
                                __gestureAccumulator = 0; __gestureLastDir = 0; if (__gestureTimer) { clearTimeout(__gestureTimer); __gestureTimer = null; }
                                return;
                            }

                            // Schedule evaluation shortly after the last wheel event (fallback)
                            if (__gestureTimer) clearTimeout(__gestureTimer);
                            __gestureTimer = setTimeout(() => {
                                try {
                                    if (__gestureAccumulator >= __smallGestureThreshold) {
                                        const secs = Array.from(scroller.querySelectorAll('section'));
                                        if (secs.length) {
                                            const idx = _snapCurrentIndex();
                                            const nextIdx = __gestureLastDir > 0 ? Math.min(secs.length - 1, idx + 1) : Math.max(0, idx - 1);
                                            if (nextIdx !== idx) {
                                                window.__snapSuppressUntil = Date.now() + 700;
                                                try { console.info('snap: accumulated snap to', nextIdx, 'acc=', __gestureAccumulator); } catch(e){}
                                                _snapToSection(secs[nextIdx], true);
                                            }
                                        }
                                    }
                                } catch(e) { /* swallow */ }
                                // reset accumulator
                                __gestureAccumulator = 0; __gestureLastDir = 0; __gestureTimer = null;
                            }, __gestureTimeoutMs);
                        }
                    } catch(e) { /* swallow */ }
                }, { passive: false, capture: true });
            } catch(e) { /* swallow */ }

            // Install a window-level fallback listener as well. Some browsers
            // or embedded content route wheel events to the window/document
            // instead of the scroller element — installing both handlers is
            // safe as each handler checks `window.__snapSuppressUntil` and
            // the scroller handler marks `window.__snapListenerConfirmed` so
            // the window handler can avoid double-acting when not needed.
            try {
                let __w_acc = 0, __w_dir = 0, __w_timer = null;
                const __w_thresh = 60, __w_timeout = 140;
                window.addEventListener('wheel', (wev) => {
                    try {
                        // If scroller already handled wheel events recently, skip
                        if (window.__snapListenerConfirmed) return;
                        if (Date.now() < (window.__snapSuppressUntil || 0)) return;

                        const delta = wev.deltaY || 0;
                        const abs = Math.abs(delta);
                        const dir = delta > 0 ? 1 : -1;

                        // Large deltas: immediate snap
                        if (abs >= 16) {
                            try { wev.preventDefault(); wev.stopPropagation(); } catch(e){}
                            const secs = Array.from((document.scrollingElement || document.documentElement).querySelectorAll('section'));
                            if (!secs.length) return;
                            const idx = _snapCurrentIndex();
                            const nextIdx = delta > 0 ? Math.min(secs.length - 1, idx + 1) : Math.max(0, idx - 1);
                            if (nextIdx !== idx) {
                                try { console.info('snap: window immediate wheel snap to', nextIdx); } catch(e){}
                                _snapToSection(secs[nextIdx], true);
                            }
                            __w_acc = 0; __w_dir = 0; if (__w_timer) { clearTimeout(__w_timer); __w_timer = null; }
                            return;
                        }

                        if (abs > 0) {
                            if (__w_dir && __w_dir !== dir) __w_acc = 0;
                            __w_dir = dir; __w_acc += abs;

                            // If accumulated crosses threshold immediately, snap now
                            if (__w_acc >= __w_thresh) {
                                try { wev.preventDefault(); wev.stopPropagation(); } catch(e){}
                                const secs = Array.from((document.scrollingElement || document.documentElement).querySelectorAll('section'));
                                if (secs.length) {
                                    const idx = _snapCurrentIndex();
                                    const nextIdx = __w_dir > 0 ? Math.min(secs.length - 1, idx + 1) : Math.max(0, idx - 1);
                                    if (nextIdx !== idx) {
                                        try { console.info('snap: window accumulated immediate snap to', nextIdx, 'acc=', __w_acc); } catch(e){}
                                        window.__snapSuppressUntil = Date.now() + 700;
                                        _snapToSection(secs[nextIdx], true);
                                    }
                                }
                                __w_acc = 0; __w_dir = 0; if (__w_timer) { clearTimeout(__w_timer); __w_timer = null; }
                                return;
                            }

                            if (__w_timer) clearTimeout(__w_timer);
                            __w_timer = setTimeout(() => {
                                try {
                                    if (__w_acc >= __w_thresh) {
                                        const secs = Array.from((document.scrollingElement || document.documentElement).querySelectorAll('section'));
                                        if (secs.length) {
                                            const idx = _snapCurrentIndex();
                                            const nextIdx = __w_dir > 0 ? Math.min(secs.length - 1, idx + 1) : Math.max(0, idx - 1);
                                            if (nextIdx !== idx) {
                                                try { console.info('snap: window accumulated snap to', nextIdx, 'acc=', __w_acc); } catch(e){}
                                                window.__snapSuppressUntil = Date.now() + 700;
                                                _snapToSection(secs[nextIdx], true);
                                            }
                                        }
                                    }
                                } catch(e){}
                                __w_acc = 0; __w_dir = 0; __w_timer = null;
                            }, __w_timeout);
                        }
                    } catch(e) { /* swallow */ }
                }, { passive: true, capture: true });
            } catch(e) { /* swallow */ }

            // Keyboard navigation for snapping (remain on document)
            document.addEventListener('keydown', (ev) => {
                try {
                    if (Date.now() < (window.__snapSuppressUntil || 0)) return;
                    if (!['ArrowDown','PageDown',' ','ArrowUp','PageUp'].includes(ev.key)) return;
                    // Ignore when focus is on an input/textarea/select
                    const tag = (document.activeElement && document.activeElement.tagName || '').toLowerCase();
                    if (['input','textarea','select'].includes(tag)) return;
                    ev.preventDefault();
                    ev.stopPropagation();
                    const secs = Array.from(scroller.querySelectorAll('section'));
                    if (!secs.length) return;
                    const idx = _snapCurrentIndex();
                    if (ev.key === 'ArrowDown' || ev.key === 'PageDown' || ev.key === ' ') {
                        const next = Math.min(secs.length - 1, idx + 1);
                        if (next !== idx) _snapToSection(secs[next], true);
                    } else if (ev.key === 'ArrowUp' || ev.key === 'PageUp') {
                        const prev = Math.max(0, idx - 1);
                        if (prev !== idx) _snapToSection(secs[prev], true);
                    }
                } catch(e) { /* swallow */ }
            }, true);
        }

        // Add observer to all links and attach click handlers to inflection links
        const inflectLinks = document.querySelectorAll('a');
        inflectLinks.forEach(link => {
            observer.observe(link);
            const hrefAttr = (link.getAttribute('href') || '').trim();
            // Treat any non-empty href as an inflection-link candidate. This allows
            // external URLs as well as local paths to be handled by the iframe
            // forwarding logic. Skip empty hrefs or javascript/mailto pseudo-links.
            const isInflection = hrefAttr && !hrefAttr.toLowerCase().startsWith('javascript:') && !hrefAttr.toLowerCase().startsWith('mailto:');
                if (isInflection) {
                // Add event listener to manually handle click
                link.addEventListener('click', function(event) {
                    document.querySelectorAll('a').forEach(a => a.classList.remove('active'));
                    link.classList.add('active');
                    const rawHref = link.getAttribute('href');
                    try { const full = new URL(rawHref, window.location.href).href; setIframeNext(full); } catch(e){ setIframeNext(link.href); }
                    // (typewriter removed)
                });
            } else {
                // mark external/non-inflection links so they can be styled differently
                link.classList.add('dontinflect');
            }
        });

        const firstLink = document.querySelector('main a:not(.dontinflect)');
        if (firstLink) {
            firstLink.classList.add('active');
            const rawHref = firstLink.getAttribute('href');
            try { const full = new URL(rawHref, window.location.href).href; setIframeNext(full); } catch(e){ setIframeNext(firstLink.href); }
        }

    }

    // scroll up when pressing Escape
    document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape') {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
    });

    // Load, parse, and display markdown on page load (debounced scheduler prevents rapid duplicate runs)
    (function(){
        window.__renderMarkdownTimer = null;
        window.scheduleRenderMarkdown = function(delay){
            try { if (window.__renderMarkdownTimer) clearTimeout(window.__renderMarkdownTimer); } catch(e){}
            window.__renderMarkdownTimer = setTimeout(() => { try { renderMarkdown(); } catch(e){}; window.__renderMarkdownTimer = null; }, (typeof delay === 'number' ? delay : 50));
        };
    })();
    window.scheduleRenderMarkdown(0);
        // Load external typewriter script (handles its own initialization)
        (function(){
            const s = document.createElement('script');
            s.src = 'src/typewriter.js';
            s.defer = true;
            document.head.appendChild(s);
        })();
</script>
</body>
</html>
