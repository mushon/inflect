<!DOCTYPE html>
<html>
<head>    
    <meta charset="UTF-8">
    <link rel="icon" type="image/svg+xml" sizes="any" href="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20100%20100%22%3E%3Ctext%20y%3D%221em%22%20font-size%3D%2290%22%3E%F0%9F%93%84%3C%2Ftext%3E%3C%2Fsvg%3E">
    <title>!nflect</title>
    <script src="src/marked.min.js"></script>
    
    <style>
        :root {
            scroll-behavior: smooth;
        }

        body {
            font-family: "HelveticaNeueLight", "HelveticaNeue-Light", "Helvetica Neue Light", 
                         "HelveticaNeue", "Helvetica Neue", 'TeXGyreHerosRegular', "Arial", sans-serif;
            font-weight: 200;
            font-size: calc(1vw + 1vh);
            background-color: #ddd;
            margin: 0;
            padding: 0;
        }

        #orientationWarning {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background: black;
            color: white;
            font-weight: bold;
            text-align: center;
            padding: 1em;
            z-index: 100;
        }

        iframe, #frameBox {
            top: 0;
            left: 0;
            height: 100vh;
            width: 50vw;
            position: fixed;
            background-color: #fff;
            border: 0;
            margin: 0;
            padding: 0;            
        }

        iframe {
            opacity: 0;
            transition: opacity 0.1s ease-in;
        }

        h1 { font-size: 2em; font-weight: 100;}
        h2 { font-size: 1.33em; }
        h3 { font-size: 1.11em; }

        main {
            box-sizing: border-box;
            position: absolute;
            right: 0;
            width: 50vw;
            padding: 0 3vh;
            margin: 0;            
        }

        section {
            min-height: 100vh;
        }
        
        p {
            font-size: 1em;
            line-height: 1.5em;
        }

        a {
            color: #000;
        }

        ul, ol {
            padding-left: 1.5em;
        }

        li {
            padding-bottom: 0.5em;
            line-height: 1.25em;
        }

        a.dontinflect { color: #777;}
        a.dontinflect:hover { color: #000;}

        a.active {
            border-radius: .25em;
            background: #eee;
            text-decoration: none;
            padding: 0 .1em;
            margin: 0 -.1em;
        }

        a.active:hover {
            background: #fff;
        }

    </style>
</head>

<body>

<div id="orientationWarning">Please turn your device around or widen your browser window.</div>

<div id="frameBox"><iframe id="if"></iframe></div>

<main></main>

<script>
    // Track last path (excluding hash)
    let lastIframePath = null;
    const iframe = document.getElementById('if');

    // Fade in new content 
    function setIframeIfPathChanged(newHref) {
      const newURL = new URL(newHref, window.location.origin);
      newURL.hash = ''; // remove hash for path comparison
      const newPath = newURL.href;

      // If path changes, set iframe to 0 opacity
      if (newPath !== lastIframePath) {
        iframe.style.opacity = '0';
        iframe.src = newHref;
        lastIframePath = newPath;
      } 
      else {
        // Otherwise just update src as needed (rare case)
        iframe.src = newHref;
      }
    }

    // Fade in once the iframe finishes loading
    iframe.addEventListener('load', () => {
      iframe.style.opacity = '1';
    });

    // Function to fetch and render the markdown
    async function renderMarkdown() {
        try {
            const hash = window.location.hash.substring(1); // Remove '#' from hash
            const file = hash ? hash : 'README';

            document.title = (file === "README") 
                             ? "!nflect" 
                             : `!nflect Â· ${file}`;

            const response = await fetch(file + ".md"); 
            let readme = await response.text();

            // split sections by two empty lines
            readme = readme.replace(/\s*\n\s*\n\s*\n\s*/g, '\n\n</section>\n\n<section>\n\n');
            readme = "<section>\n\n" + readme + "\n\n</section>";
            
            // add class dontinflect to regular html links
            readme = readme.replace(/<a\b([^>]*)>/gi, (m, attrs) => 
              `<a${/class\s*=\s*["']([^"']*)["']/i.test(attrs) 
                  ? attrs.replace(/class\s*=\s*["']([^"']*)["']/i, 
                                  (m, c) => `class="${c} dontinflect"`) 
                  : ` class="dontinflect"${attrs}`}>`
            );

            // Render the markdown into HTML
            const html = marked.parse(readme); 
            document.querySelector('main').innerHTML = html;

            initializeObservers();
        } catch (error) {
            console.error('Error fetching or rendering the markdown file:', error);
        }
    }

    // Update markdown when hash changes
    window.addEventListener('hashchange', function() {
        window.scrollTo(0, 0);
        renderMarkdown();        
    });

    // with IntersectionObserver we can check what is visible    
    function initializeObservers() {
        const observer = new IntersectionObserver((entries) => {
            // Remove active class from all links
            // document.querySelectorAll('a').forEach(a => a.classList.remove('active'));

            entries.forEach(entry => {
                if (entry.isIntersecting) {                    
                    // Add active class only to the visible link
                    const visibleLink = entry.target;
                    if (!visibleLink.classList.contains("dontinflect")) {
                        visibleLink.classList.add('active');
                        // Update iframe, ignoring just hash changes
                        setIframeIfPathChanged(visibleLink.href);
                    }
                }
                else entry.target.classList.remove("active")
            });
        });

        // Add observer to all inflect links
        const inflectLinks = document.querySelectorAll('a');
        inflectLinks.forEach(link => {
            observer.observe(link);

            // ignore local links to markdown files
            if (!link.classList.contains("dontinflect")) {
                // Add event listener to manually handle click
                link.addEventListener('click', function(event) {                    
                    document.querySelectorAll('a').forEach(a => a.classList.remove('active'));
                    link.classList.add('active');
                    setIframeIfPathChanged(link.href);
                });
            }
        });
    }

    // scroll up when pressing Escape
    document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape') {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
    });

    // Show/hide orientation warning when window is taller than wide
    function resize() {
        const warning = document.getElementById('orientationWarning');
        if (window.innerHeight > window.innerWidth) warning.style.display = 'block';
        else warning.style.display = 'none';
    }
    window.addEventListener('resize', resize);
    resize();

    // Load, parse, and display markdown on page load
    renderMarkdown();
</script>
</body>
</html>