<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Inflect SVG Viewer</title>
<style>
  html,body{height:100%;margin:0;background:#111;color:#fff;font-family:Helvetica,Arial,sans-serif}
  #app{position:relative;height:100vh;overflow:hidden}
  #canvas{width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:#222}
  #controls{position:absolute;right:8px;top:8px;background:rgba(255,255,255,0.06);padding:8px;border-radius:6px;color:#fff;font-size:13px}
  #controls label{display:block;margin-bottom:6px;font-size:12px}
  #controls input[type=range]{width:140px}
  #status{position:absolute;left:8px;top:8px;background:rgba(0,0,0,0.5);padding:6px 8px;border-radius:6px;font-size:12px}
  /* when embedded in an iframe we hide the UI chrome */
  .embedded #controls, .embedded #status{ display:none !important; }
  /* layer list inside controls */
  #layerList{ max-height:200px; overflow:auto; margin-top:6px; font-size:13px }
  #layerList label{ display:flex; align-items:center; gap:8px; margin:4px 0 }
  svg{max-width:100%;max-height:100%;}
</style>
<style>
  /* Force an exception child to remain visible without transitions to avoid flicker */
  .inflect-exception-visible { opacity: 1 !important; visibility: visible !important; transition: none !important; }
</style>
</head>
<body>
<div id="app">
  <div id="canvas"><div id="svgContainer"></div></div>
  <div id="controls">
    <button id="reset">Reset view</button>
    <div style="margin-top:8px;font-weight:600">Layers</div>
    <div id="layerList" aria-live="polite"></div>
  <button id="copyLink" style="margin-top:8px">Copy link</button>
  </div>
  <div id="status">loading...</div>
</div>
<script>
// detect if running inside an iframe and toggle embedded UI
try {
  if (window.top && window.top !== window.self) {
    document.documentElement.classList.add('embedded');
  }
} catch(e) {
  // cross-origin top access may throw; assume embedded in that case
  try { document.documentElement.classList.add('embedded'); } catch(e){}
}

// Simple inflect-style hash parser: fields separated by & with url in 5th slot.
// Parse hash and tolerate a url token that may include @param pairs: url@k=v@k2=v2
function parseUrlField(urlField) {
  if (!urlField) return { url: '', params: {}, vis: { show: [], hide: [] } };
  // support optional trailing visibility tokens after a slash, e.g. 'file.svg/~layer+other'
  let base = String(urlField);
  let vis = { show: [], hide: [] };
  const slashIdx = base.indexOf('/');
  if (slashIdx !== -1) {
    const visPart = base.slice(slashIdx + 1);
    base = base.slice(0, slashIdx);
    // tokens start with + or ~; capture sequences like +name, ~name
    const re = /([+~])([^+~\/]+)/g;
    let m;
    while ((m = re.exec(visPart)) !== null) {
      const sym = m[1]; const name = decodeURIComponent(m[2]);
        // resolve short label (no slash) to full hierarchical key if unique
        let resolved = name;
        if (!name.includes('/')){
          // find keys whose last segment matches name
          const matches = [];
          for (const k of layerKeyMap.keys()){
            if (String(k).split('/').pop() === name) matches.push(k);
          }
          if (matches.length === 1) resolved = matches[0];
        }
        if (sym === '+') vis.show.push(resolved);
        else if (sym === '~') vis.hide.push(resolved);
    }
  }
  const parts = base.split('@').map(s => s.trim()).filter(Boolean);
  const url = parts[0] || '';
  const params = {};
  parts.slice(1).forEach(p => {
    const eq = p.indexOf('=');
    if (eq === -1) return;
    const k = p.slice(0, eq);
    const v = p.slice(eq+1);
    if (!k) return;
    params[k] = isNaN(Number(v)) ? v : Number(v);
  });
  return { url, params, vis };
}

function buildUrlField(url, params, vis){
  let token = url || '';
  if (params) for (const k of Object.keys(params)) token += `@${k}=${encodeURIComponent(String(params[k]))}`;
  // Hide-only semantics: only serialize hidden layer keys as ~key
    if (vis) {
      let seg = '';
      // helper to pick a short label if unique (last segment), otherwise use full key
      function shortOrFull(k) {
        if (!k) return k;
        const last = String(k).split('/').pop();
        // check uniqueness among layerKeyMap keys' last segments
        let count = 0;
        for (const kk of layerKeyMap.keys()) if ((String(kk).split('/').pop()) === last) count++;
        return count === 1 ? last : k;
      }
      // Hide-only semantics: by default serialize hidden layers as ~key. However,
      // when there are explicit show (+) tokens present we prefer to serialize only
      // the +tokens (so additional checks produce +A+B) and omit explicit ~ siblings
      // that would otherwise be emitted like +A+B~C~D.
      let hideList = (vis.hide || []).slice();
      let showList = (vis.show || []).slice();
      try {
        // Only attempt compression when there are no explicit shows; if shows are
        // present, skip compression and we will omit ~ tokens below.
        if (!showList.length) {
          const hideSet = new Set(hideList);
          for (const parentKey of Array.from(layerKeyMap.keys())){
            const children = getDirectChildrenKeys(parentKey);
            if (children.length < 2) continue;
            const hiddenChildren = children.filter(c => hideSet.has(c));
            const shownChildren = children.filter(c => showList.includes(c));
            if (hiddenChildren.length === children.length - 1 && shownChildren.length === 1){
              hideList = hideList.filter(h => !hiddenChildren.includes(h));
              hideList.push(parentKey);
            }
          }
        }
      } catch(e) { /* ignore compression failures */ }

      // If explicit shows are present, prefer emitting only +tokens and skip ~tokens
      if (showList && showList.length) {
        showList.forEach(s => { seg += `+${encodeURIComponent(String(shortOrFull(s)))}`; });
      } else {
        if (hideList && hideList.length) hideList.forEach(h => { seg += `~${encodeURIComponent(String(shortOrFull(h)))}`; });
      }
      if (seg) token += '/' + seg;
  }
  return token;
}

function parseHash(){
  const raw = location.hash.slice(1).trim();
  if (!raw) return { url: '', params: {}, view: null };
  // New compact format: filename/x,y,zoom/layers
  // filename may be a path containing .svg; layers is optional (encoded after a slash)
  const compactRe = /^(?<file>[^\/,]+\.svg|\/[^\/,]+\.svg|[^\/,]+\.svg)\/(?<xyzoom>[\d\-\.]+,[\d\-\.]+,[\d\-\.]+)(?:\/(?<layers>.*))?$/i;
  const m = raw.match(compactRe);
  if (m && m.groups && m.groups.file){
    const file = m.groups.file;
    const xyzoom = m.groups.xyzoom || '';
    const layers = m.groups.layers || '';
    const parts = xyzoom.split(',').map(Number);
    const x = !isNaN(parts[0]) ? parts[0] : null;
    const y = !isNaN(parts[1]) ? parts[1] : null;
    const s = !isNaN(parts[2]) ? parts[2] : null;
    // parse layers section which follows same +/~ tokens optionally
    const vis = { show: [], hide: [] };
    if (layers) {
      const re = /([+~])([^+~\/]+)/g;
      let mm;
      while ((mm = re.exec(layers)) !== null){
        const sym = mm[1]; const name = decodeURIComponent(mm[2]);
        if (sym === '+') vis.show.push(name); else vis.hide.push(name);
      }
    }
    const params = {};
    if (s !== null) params.s = s;
    if (x !== null) params.x = x;
    if (y !== null) params.y = y;
    return { url: file, params: params, view: null, vis: vis };
  }

  // backward compatibility: old ampersand-separated format
  if (!raw.includes('&') && (raw.indexOf('.svg') !== -1 || raw.startsWith('/') || /^\w[\w\-\.]*\.svg$/i.test(raw))) {
    const parsed = parseUrlField(raw);
    return { url: parsed.url, params: parsed.params || {}, view: null, vis: parsed.vis || { show: [], hide: [] } };
  }
  const parts = raw.split('&');
  let rawUrlField = parts[4] || '';
  // tolerant shift
  if (!rawUrlField && parts.length>=5 && parts[3] && (parts[3].includes('.svg')||parts[3].startsWith('svg/'))) {
    rawUrlField = parts[3];
  }
  const parsed = parseUrlField(rawUrlField);
  return { url: parsed.url, params: parsed.params || {}, view: null, vis: parsed.vis || { show: [], hide: [] } };
}
function layersToUrlField(u){ return u || ''; }

function buildCompactHash(file, params, vis){
  // params: { x, y, s }
  const x = (params && typeof params.x === 'number') ? Math.round(params.x) : 0;
  const y = (params && typeof params.y === 'number') ? Math.round(params.y) : 0;
  const s = (params && typeof params.s === 'number') ? (Math.round(params.s*100)/100) : 1;
  // If params match the default canonical view (0,0,1), omit them from the hash
  let token = String(file || '');
  const paramsAreDefault = (x === 0 && y === 0 && (Math.abs(s - 1) < 1e-6));
  if (!paramsAreDefault) token += `/${x},${y},${s}`;
  // append visibility tokens after either the params (if present) or the filename
  if (vis && ((Array.isArray(vis.show) && vis.show.length) || (Array.isArray(vis.hide) && vis.hide.length))){
    let seg = '';
    // When serializing layer keys into the compact hash, only include the
    // local label (last path segment) to keep tokens short and avoid
    // exposing group prefixes. If the short label is non-unique the
    // parser will resolve it against available keys on load.
    function shortLabel(k){
      if (!k) return k;
      const s = String(k).split('/').pop();
      return s;
    }
    if (vis.show && vis.show.length) vis.show.forEach(item => seg += `+${encodeURIComponent(String(shortLabel(item)))}`);
    else if (vis.hide && vis.hide.length) vis.hide.forEach(item => seg += `~${encodeURIComponent(String(shortLabel(item)))}`);
    if (seg) token += `/${seg}`;
  }
  return token;
}

let svgContainer = document.getElementById('svgContainer');
let status = document.getElementById('status');
let resetBtn = document.getElementById('reset');

let svgEl = null; // the embedded svg root
let wrapperG = null; // group we apply transforms to
let bbox = null;
// animation timing (ms) for fades; make configurable
// Use a longer duration and a soft cubic-bezier to produce buttery transitions
const FADE_DURATION = 1800;
const SOFT_EASE = 'cubic-bezier(0.22,1,0.36,1)';
let state = { tx:0, ty:0, scale:1 };
let view = null; // { topLeft:[x,y], bottomRight:[x,y] } in svg coords
let isDragging=false, dragStart=null, dragStartState=null;
 let pendingVis = null; // visibility instructions to apply after load
let layerKeyMap = new Map();
let showExceptions = new Set(); // keys explicitly shown despite ancestor hide
let defaultSvgParams = null; // captured after load to represent the 'fit' defaults

function getDirectChildrenKeys(parentKey){
  const res = [];
  const prefix = parentKey + '/';
  for (const k of layerKeyMap.keys()){
    if (!k.startsWith(prefix)) continue;
    const rest = k.slice(prefix.length);
    if (rest.indexOf('/') === -1) res.push(k);
  }
  return res;
}

function getKeyForElement(el){
  for (const [k, v] of layerKeyMap.entries()){
    if (v === el) return k;
  }
  return null;
}

function setStatus(s){ status.textContent = s; }

async function loadSVG(url){
  if (!url) { setStatus('no url'); return; }
  try {
    setStatus('loading '+url);
    const res = await fetch(url);
    if (!res.ok) throw new Error('fetch failed '+res.status);
    const text = await res.text();
    svgContainer.innerHTML = text;
    svgEl = svgContainer.querySelector('svg');
    if (!svgEl) throw new Error('no <svg> in file');
    // ensure width/height viewBox exists
    if (!svgEl.getAttribute('viewBox')) {
      const w = svgEl.getAttribute('width')||svgEl.clientWidth||300;
      const h = svgEl.getAttribute('height')||svgEl.clientHeight||150;
      svgEl.setAttribute('viewBox','0 0 '+w+' '+h);
    }
  // we will manipulate the SVG using CSS transforms on the svg element
  // Keep the svg in the document flow (not absolute) so its container has
  // a layout size. The transform-origin should be top-left (0 0).
  try { svgContainer.style.position = svgContainer.style.position || 'relative'; } catch(e){}
  svgEl.style.display = svgEl.style.display || 'block';
  svgEl.style.maxWidth = svgEl.style.maxWidth || '100%';
  svgEl.style.maxHeight = svgEl.style.maxHeight || '100%';
  svgEl.style.transformOrigin = '0 0';
    // compute bbox after a tick and derive initial fit values
    await new Promise(r => setTimeout(r,20));
    try { bbox = svgEl.getBBox(); } catch(e) { bbox = { x:0,y:0,width:svgEl.clientWidth||300,height:svgEl.clientHeight||150 }; }
    fitToContainer();
  // leave scale as default; caller may override via params
  // UI sliders removed — keep internal state but do not update controls
    render();
  // Capture the default params (scale/tx/ty) after fitting so
  // missing hash params can animate toward these defaults.
  try { defaultSvgParams = { s: state.scale, x: state.tx, y: state.ty }; } catch(e){}
    setStatus('ready');
    window.viewerReady = true;
  // build layer list UI so user can show/hide layers
  try { buildLayerList(); } catch(e) { console.warn('build layer list failed', e); }
  // apply any pending visibility instructions now that layers exist
  try { if (pendingVis) { applyVisibilityFromVis(pendingVis, { animate: false }); pendingVis = null; } } catch(e) { console.warn('apply pending vis failed', e); }
    try { window.layerKeyMap = layerKeyMap; } catch(e){}
  } catch (e) {
    console.error(e);
    setStatus('error');
    window.viewerReady = false;
  }
}

// animate opacity values for a set of elements (obj map name->elem)
// build a simple layer list UI from top-level svg children
function buildLayerList(){
  if (!svgEl) return;
  const layerList = document.getElementById('layerList');
  if (!layerList) return;
  layerList.innerHTML = '';

  // exclude non-visual/definition tags and elements defined under <defs>
  const excluded = new Set([
    'SCRIPT','STYLE','DEFS','METADATA','TITLE','PATTERN',
    'LINEARGRADIENT','RADIALGRADIENT','CLIPPATH','MASK','FILTER','MARKER','SYMBOL','VIEW','FONT'
  ]);

  function getLabel(el, idx){
    // Only include elements that have an explicit id. Elements without an
    // id should not appear in the layer checklist per user request.
    return el.id || null;
  }

  function makeNode(el, idx, parentKey){
    // Skip elements that do not have an id — we only expose id'd elements
    // in the layer list.
    const baseKey = getLabel(el, idx);
    if (!baseKey) return null;

    const li = document.createElement('div');
    li.style.marginLeft = '0px';
    const label = document.createElement('label');
    label.style.display = 'flex'; label.style.alignItems = 'center'; label.style.gap = '8px';
    const cb = document.createElement('input'); cb.type = 'checkbox';
    const computed = window.getComputedStyle(el);
    cb.checked = !(computed.display === 'none' || computed.visibility === 'hidden');
    // compute a stable key and ensure uniqueness
    // baseKey already retrieved above
    let key = parentKey ? `${parentKey}/${baseKey}` : baseKey;
    // ensure uniqueness
    let uniqueKey = key; let suffix = 1;
    while (layerKeyMap.has(uniqueKey)) { uniqueKey = key + '_' + (suffix++); }
    key = uniqueKey;
    cb.dataset.layerKey = key;
    label.dataset.layerKey = key;
    layerKeyMap.set(key, el);
  cb.addEventListener('change', () => {
    const key = cb.dataset.layerKey;
    // If no key, fallback to direct toggle
    if (!key) { toggleLayerVisibility(el, cb.checked, { animate: true }); updateHashFromLayerList(); refreshLayerListCheckboxes(); return; }

    // If the user checked the checkbox, treat this as an explicit "show" (exception)
    // and add it to showExceptions so the hash emits a +token for this layer. Do not
    // implicitly hide other layers as a side-effect.
    if (cb.checked === true) {
      // add as explicit exception/show
      showExceptions.add(key);
      // ensure ancestor chain is visible so this layer can be seen
      const parts = key.split('/');
      for (let i = 0; i < parts.length - 1; i++) {
        const ancestor = parts.slice(0, i+1).join('/');
        if (layerKeyMap.has(ancestor)) {
          try { toggleLayerVisibility(layerKeyMap.get(ancestor), true, { animate: false }); } catch(e){}
        }
      }
      // show this element
      toggleLayerVisibility(el, true, { animate: true });
      refreshLayerListCheckboxes(); updateHashFromLayerList();
      return;
    }

    // If the user unchecked the checkbox and it was previously an explicit exception,
    // remove it from showExceptions and reapply parsed visibility.
    if (cb.checked === false && showExceptions.has(key)) {
      // Remove explicit +token for this key from the hash and in-memory exceptions.
      showExceptions.delete(key);
      try {
        // Parse current hash and remove this key from parsed.vis.show
        const parsed = parseHash();
        parsed.vis = parsed.vis || { show: [], hide: [] };
        parsed.vis.show = (parsed.vis.show || []).filter(s => String(s) !== String(key));
        // write new token into the hash using compact format
        const token = buildCompactHash(parsed.url, parsed.params, parsed.vis);
  suppressHashFor(120);
        location.hash = '#'+token;
        // apply new visibility immediately so UI updates without waiting for hashchange
        try { applyVisibilityFromVis(parsed.vis || { hide: [], show: [] }, { animate: true }); } catch(e){}
      } catch(e) {
        // fallback: reapply current parsed vis
        try { applyVisibilityFromVis(parseHash().vis || { hide: [], show: [] }, { animate: true }); } catch(e){}
      }
      refreshLayerListCheckboxes(); updateHashFromLayerList();
      return;
    }

    // Existing behavior for toggling parents/children when unchecking a parent
    const direct = getDirectChildrenKeys(key);
    if (direct.length > 0 && cb.checked === false) {
      // detect if any direct child is in showExceptions OR currently visible
      const exceptions = direct.filter(dk => showExceptions.has(dk));
      const visibleChildren = direct.filter(dk => {
        const el = layerKeyMap.get(dk);
        if (!el) return false;
        const cs = window.getComputedStyle(el);
        const op = parseFloat(cs.opacity || '1');
        return cs.display !== 'none' && cs.visibility !== 'hidden' && op > 0;
      });
      if (exceptions.length > 0 || visibleChildren.length > 0) {
        // keep parent visible
        toggleLayerVisibility(el, true, { animate: false });
        // ensure checkbox shows unchecked state (user intent) while parent remains visible
        try { cb.checked = false; } catch(e){}
        // for each child: if it's an exception, ensure visible immediately; else fade out
        const fadePromises = [];
        direct.forEach(childKey => {
          const childEl = layerKeyMap.get(childKey);
          if (!childEl) return;
          if (showExceptions.has(childKey) || visibleChildren.includes(childKey)) {
            // protect exception child
            if (childEl.classList) childEl.classList.add('inflect-exception-visible');
            toggleLayerVisibility(childEl, true, { animate: false });
            const prev = __fadeCancels.get(childEl); if (prev) prev();
          } else {
            fadePromises.push(animateLayerVisibility(childEl, false));
          }
        });
        Promise.all(fadePromises).then(() => {
          // ensure non-exception children are hidden
          direct.forEach(childKey => {
            if (showExceptions.has(childKey)) return;
            const childEl = layerKeyMap.get(childKey);
            if (!childEl) return;
            toggleLayerVisibility(childEl, false, { animate: false });
          });
          refreshLayerListCheckboxes(); updateHashFromLayerList();
        }).catch(() => { refreshLayerListCheckboxes(); updateHashFromLayerList(); });
        return;
      }
    }
    // default behavior: toggle element visibility directly
    toggleLayerVisibility(el, cb.checked, { animate: true }); updateHashFromLayerList(); refreshLayerListCheckboxes();
  });
    // "Only" button: make this the only visible layer (implements +key semantics)
    const onlyBtn = document.createElement('button');
    onlyBtn.type = 'button';
    onlyBtn.className = 'only-btn';
    onlyBtn.title = 'Only ⊙ — show only this layer (hide siblings)';
    onlyBtn.textContent = '⊙';
    onlyBtn.style.marginLeft = '6px';
    onlyBtn.style.background = 'transparent';
    onlyBtn.style.border = 'none';
    onlyBtn.style.color = 'inherit';
    onlyBtn.style.cursor = 'pointer';
    onlyBtn.style.fontSize = '14px';
    onlyBtn.addEventListener('click', (ev) => {
      ev.preventDefault(); ev.stopPropagation();
      const theKey = key;
      if (!theKey) return;
      // If this is a top-level (root) node (no parentKey), interpret Only as
      // a reset: clear any visibility tokens from the hash and clear exceptions
      // so the default SVG visibility is restored.
      if (!parentKey) {
  suppressHashFor(120);
        // Clear in-memory exceptions
        showExceptions.clear();
        // remove vis token by writing compact hash without vis
        const parsed = parseHash();
        parsed.vis = { show: [], hide: [] };
        const token = buildCompactHash(parsed.url, parsed.params, parsed.vis);
        location.hash = '#'+token;
        // Reapply parsed visibility (which is now empty) so UI updates
        try { applyVisibilityFromVis({ show: [], hide: [] }, { animate: true }); } catch(e){}
        refreshLayerListCheckboxes();
        return;
      }

      // Non-root behavior: keep existing +token semantics (show only this subtree)
      const vis = { show: [theKey], hide: [] };
      try { applyVisibilityFromVis(vis, { animate: true }); } catch(e){ console.warn('applyVisibilityFromVis failed', e); }
      // update the hash token similarly to updateHashFromLayerList but using our vis
  suppressHashFor(120);
      const parsed = parseHash();
      const token = buildCompactHash(parsed.url, parsed.params, vis);
      location.hash = '#'+token;
      // Refresh UI to reflect new visibility
      refreshLayerListCheckboxes();
    });
    // allow clicking the label when checkbox is disabled to create a show-exception
    label.addEventListener('click', (e) => {
      // only intercept when the input is currently disabled (i.e., ancestor controls it)
      if (!cb.disabled) return;
      e.preventDefault(); e.stopPropagation();
      const key = cb.dataset.layerKey;
      if (!key) return;
      const parentParts = key.split('/').slice(0, -1);
      const parentKey = parentParts.length ? parentParts.join('/') : null;
      // toggle exception
      if (showExceptions.has(key)) {
        showExceptions.delete(key);
        // remove exception-visible marker
        const excOld = layerKeyMap.get(key);
        if (excOld && excOld.classList) excOld.classList.remove('inflect-exception-visible');
        // reapply visibility from parsed vis (which may hide parent again)
        try { applyVisibilityFromVis(parseHash().vis || { hide: [], show: [] }, { animate: false }); } catch(e){}
      } else {
        showExceptions.add(key);
        // if parent exists and is currently hidden by vis, reveal parent and hide siblings
        if (parentKey && layerKeyMap.has(parentKey)){
          const parentEl = layerKeyMap.get(parentKey);
          // show parent element immediately so child can be rendered (no animation)
          toggleLayerVisibility(parentEl, true, { animate: false });
          // Ensure the exception child is visible immediately (no animation) so it
          // doesn't flicker while we manipulate the parent/other siblings.
          const excEl = layerKeyMap.get(key);
          if (excEl) {
            // mark as exception-visible to protect from animation/hide
            if (excEl.classList) excEl.classList.add('inflect-exception-visible');
            // show immediately with no transition
            toggleLayerVisibility(excEl, true, { animate: false });
            try { excEl.style.transition = 'none'; excEl.style.opacity = '1'; } catch(e){}
            // cancel any pending fade on this element
            const prev = __fadeCancels.get(excEl); if (prev) prev();
          }
          // fade out siblings first (animate), then once faded set their display none and
          // keep the exception child visible (no animate in) to avoid blink.
          const children = getDirectChildrenKeys(parentKey);
          const fadeOutPromises = [];
          children.forEach(childKey => {
            if (childKey === key) return; // skip exception child for now
            const childEl = layerKeyMap.get(childKey);
            if (!childEl) return;
            // animate fade out
            fadeOutPromises.push(animateLayerVisibility(childEl, false));
          });
          // when all siblings have finished fading out, ensure they're hidden and then show exception
          Promise.all(fadeOutPromises).then(() => {
            children.forEach(childKey => {
              const childEl = layerKeyMap.get(childKey);
              if (!childEl) return;
              if (childKey === key) return;
              // ensure hidden immediately (no animation)
              toggleLayerVisibility(childEl, false, { animate: false });
            });
            // ensure the exception child remains visible (no animation)
            const excEl2 = layerKeyMap.get(key);
            if (excEl2) toggleLayerVisibility(excEl2, true, { animate: false });
            // finally update hash/UI
            refreshLayerListCheckboxes(); updateHashFromLayerList();
          }).catch(() => {
            // fallback: immediate apply
            children.forEach(childKey => {
              const childEl = layerKeyMap.get(childKey);
              if (!childEl) return;
              if (childKey === key) return;
              toggleLayerVisibility(childEl, false, { animate: false });
            });
            const excEl3 = layerKeyMap.get(key); if (excEl3) toggleLayerVisibility(excEl3, true, { animate: false });
            refreshLayerListCheckboxes(); updateHashFromLayerList();
          });
        } else {
          // no parent: just show this layer (user action)
            toggleLayerVisibility(el, true, { animate: true });
        }
      }
      refreshLayerListCheckboxes();
      updateHashFromLayerList();
    });
  const span = document.createElement('span');
  // display only the local label (omit parent prefix) for readability
  const displayLabel = parentKey ? baseKey : baseKey;
  span.textContent = displayLabel;
    label.appendChild(cb); label.appendChild(span);
  // append only button after label contents
  label.appendChild(onlyBtn);
    li.appendChild(label);
    // if element has element children, show nested list
    const childElems = Array.from(el.children).filter(c => c.nodeType===1 && !excluded.has((c.tagName||'').toUpperCase()) && !c.closest('defs'));
    if (childElems.length > 0){
      const container = document.createElement('div');
      container.style.marginLeft = '12px';
      childElems.forEach((c, ci) => {
        const node = makeNode(c, ci, key);
        if (node) container.appendChild(node);
      });
      li.appendChild(container);
    }
    return li;
  }

  const topChildren = Array.from(svgEl.children).filter(c => c.nodeType===1 && !excluded.has((c.tagName||'').toUpperCase()) && !c.closest('defs'));
  layerKeyMap.clear();
  topChildren.forEach((el, idx) => {
    const node = makeNode(el, idx, null);
    if (node) layerList.appendChild(node);
  });
  // enforce parent/child checkbox disabled state after building
  refreshLayerListCheckboxes();
  // expose for debugging/tests
  try { window.layerKeyMap = layerKeyMap; } catch(e){}
}

function toggleLayerVisibility(el, show, opts){
  if (!el) return;
  // If this element is explicitly marked as an exception-visible, never hide it
  try { if (!show && el.classList && el.classList.contains('inflect-exception-visible')) return; } catch(e){}
  // If this element corresponds to a parent (has direct children), do not hide the parent
  try {
    const key = getKeyForElement(el);
    if (!show && key && getDirectChildrenKeys(key).length > 0) return;
  } catch(e){}
  // Determine current computed visibility so we can avoid re-animating
  // elements whose visible state already matches the requested state.
  function isCurrentlyVisible(element){
    try {
      const cs = window.getComputedStyle(element);
      const op = parseFloat(cs.opacity || '1');
      return cs.display !== 'none' && cs.visibility !== 'hidden' && op > 0.001;
    } catch(e) { return true; }
  }
  const animate = !(opts && opts.animate === false);
  const currentlyVisible = isCurrentlyVisible(el);
  // If the element is already in the desired visibility state, skip animation.
  if (currentlyVisible && show) {
    return animate ? Promise.resolve() : undefined;
  }
  if (!currentlyVisible && !show) {
    return animate ? Promise.resolve() : undefined;
  }
  if (animate) {
    return animateLayerVisibility(el, show);
  } else {
    // immediate apply without animation
    if (show) {
      el.style.transition = '';
      el.style.opacity = '';
      el.style.display = '';
      el.style.visibility = '';
    } else {
      // If this is a parent (has children), don't remove it — children will be hidden individually.
      try {
        const key = getKeyForElement(el);
        if (key && getDirectChildrenKeys(key).length > 0) {
          // leave parent visible but non-interactive; children control visibility
          el.style.pointerEvents = 'none';
          // do not set opacity/display so children remain rendered
        } else {
          el.style.transition = '';
          el.style.opacity = '';
          el.style.display = 'none';
        }
      } catch(e) {
        el.style.display = 'none';
      }
    }
  }
}

// animate opacity for an element when showing/hiding
const __fadeCancels = new WeakMap();
function animateLayerVisibility(el, show, duration = FADE_DURATION){
  if (!el) return;
  // If this element maps to a parent node with direct children, do not animate it;
  // children will be animated individually. Avoid setting parent opacity which
  // would affect child rendering.
  try {
    const key = getKeyForElement(el);
    if (!show && key && getDirectChildrenKeys(key).length > 0) return Promise.resolve();
  } catch(e){}
  // if element is marked as an exception visible, don't animate hiding it or toggling
  if (el.classList && el.classList.contains('inflect-exception-visible')) {
    if (show) {
      // ensure visible immediately
      el.style.transition = '';
      el.style.opacity = '';
      el.style.display = '';
      el.style.visibility = '';
    } else {
      // do not hide exception-marked elements
      return Promise.resolve();
    }
  }
  return new Promise((resolve) => {
  // cancel previous transition if any
  const prevCancel = __fadeCancels.get(el);
  if (prevCancel) prevCancel();

  const computedDisplay = window.getComputedStyle(el).display;
  // show: ensure element is displayed and fade to opacity 1
  if (show) {
  // make element visible before starting fade. For SVG elements there may
  // be an explicit display="none" attribute; remove it and set an inline
  // CSS display so the element becomes visible.
  try { el.removeAttribute && el.removeAttribute('display'); } catch(e){}
  el.style.display = 'inline';
    el.style.visibility = '';
    // ensure starting opacity 0
    el.style.transition = 'none';
    el.style.opacity = '0';
    // force layout
    void el.getBoundingClientRect();
    // then transition to 1
  el.style.transition = `opacity ${duration}ms ${SOFT_EASE}`; 
    let finished = false;
    const onEnd = (ev) => {
      if (ev && ev.propertyName !== 'opacity') return;
      if (finished) return;
      finished = true;
      el.removeEventListener('transitionend', onEnd);
      // cleanup
      el.style.transition = '';
      el.style.opacity = '';
      __fadeCancels.delete(el);
      resolve();
    };
    el.addEventListener('transitionend', onEnd);
    // start fade
    requestAnimationFrame(() => { el.style.opacity = '1'; });
    // store cancel function
    __fadeCancels.set(el, () => {
      if (!finished) { el.removeEventListener('transitionend', onEnd); finished = true; }
      __fadeCancels.delete(el);
      el.style.transition = '';
      el.style.opacity = '';
      resolve();
    });
    return;
  }

  // hide: fade to 0 then set display none
  el.style.transition = `opacity ${duration}ms ${SOFT_EASE}`;
  // ensure starting opacity is 1
  if (!el.style.opacity) {
    // if no inline opacity, set to computed value or 1
    const comp = window.getComputedStyle(el).opacity;
    el.style.opacity = comp || '1';
  }
  let finished = false;
  const onEndHide = (ev) => {
    if (ev && ev.propertyName !== 'opacity') return;
    if (finished) return;
    finished = true;
    el.removeEventListener('transitionend', onEndHide);
    el.style.transition = '';
    el.style.opacity = '';
    // If this element is a parent with direct children, avoid removing it
    // from layout (display:none) because that would hide its children
    // momentarily. Instead keep it in the DOM but make it non-interactive.
    try {
      const key = getKeyForElement(el);
      if (key && getDirectChildrenKeys(key).length > 0) {
        el.style.pointerEvents = 'none';
        // ensure opacity remains 0
        try { el.style.opacity = '0'; } catch(e){}
  // avoid setting SVG display attribute; rely on inline styles only
      } else {
        el.style.display = 'none';
  // avoid setting SVG display attribute; rely on inline styles only
      }
    } catch(e) {
      el.style.display = 'none';
      try { el.setAttribute && el.setAttribute('display', 'none'); } catch(e){}
    }
    __fadeCancels.delete(el);
    resolve();
  };
  el.addEventListener('transitionend', onEndHide);
  // start fade out
  requestAnimationFrame(() => { el.style.opacity = '0'; });
  __fadeCancels.set(el, () => {
    if (!finished) { el.removeEventListener('transitionend', onEndHide); finished = true; }
    __fadeCancels.delete(el);
    el.style.transition = '';
    el.style.opacity = '';
    try {
      const key = getKeyForElement(el);
      if (key && getDirectChildrenKeys(key).length > 0) {
        el.style.pointerEvents = 'none';
        try { el.style.opacity = '0'; } catch(e){}
  // avoid setting SVG display attribute; rely on inline styles only
      } else {
        el.style.display = 'none';
  // avoid setting SVG display attribute; rely on inline styles only
      }
    } catch(e) {
      el.style.display = 'none';
      try { el.setAttribute && el.setAttribute('display', 'none'); } catch(e){}
    }
    resolve();
  });
  });
}

// apply vis object { show:[], hide:[] } to the SVG layers (matching by id/data-name/prefix)
function applyVisibilityFromVis(vis, opts){
  const animateGlobally = opts && opts.animate === true;
  if (!svgEl) return;
  // Resolve short vis tokens (like 'princess') against layerKeyMap by last-segment
  const rawHides = (vis && Array.isArray(vis.hide)) ? vis.hide.slice() : [];
  const rawShows = (vis && Array.isArray(vis.show)) ? vis.show.slice() : [];
  const resolveToken = (tok) => {
    if (!tok) return tok;
    if (String(tok).includes('/')) return tok;
    // find keys whose last segment matches tok
    const matches = [];
    for (const k of layerKeyMap.keys()){
      if (String(k).split('/').pop() === tok) matches.push(k);
    }
    return matches.length === 1 ? matches[0] : tok;
  };
  const hides = rawHides.map(resolveToken);
  const shows = rawShows.map(resolveToken);
  // Sync in-memory exceptions with parsed vis.show so parsed state wins
  showExceptions = new Set(shows);
  // Ancestor-preserve behavior for +tokens: for each shown key, walk up its
  // ancestor chain and hide all direct sibling branches at each ancestor level
  // (unless those siblings are explicitly shown or marked as exceptions).
  try {
    const ancestorHideAdditions = new Set();
    function addDescendantsToSet(baseKey, set){
      for (const k of layerKeyMap.keys()){
        if (k === baseKey || k.startsWith(baseKey + '/')) set.add(k);
      }
    }
    for (const s of shows){
      if (!s) continue;
      const parts = String(s).split('/');
      // top-level: hide other top-level keys
      if (parts.length === 1){
        for (const k of layerKeyMap.keys()){
          if (String(k).split('/').length !== 1) continue;
          if (k === s) continue;
          if (shows.includes(k)) continue; // don't hide other requested shows
          if (showExceptions.has(k)) continue;
          addDescendantsToSet(k, ancestorHideAdditions);
        }
      } else {
        // for each ancestor (parent, grandparent, ...)
        for (let i = parts.length - 1; i >= 1; i--) {
          const ancestorKey = parts.slice(0, i).join('/');
          const nextSeg = parts[i];
          const childToKeep = ancestorKey + '/' + nextSeg;
          const children = getDirectChildrenKeys(ancestorKey);
          for (const childKey of children) {
            if (childKey === childToKeep) continue;
            if (shows.includes(childKey)) continue;
            if (showExceptions.has(childKey)) continue;
            addDescendantsToSet(childKey, ancestorHideAdditions);
          }
        }
      }
    }
    // merge additions into hides (avoid duplicates)
    for (const k of ancestorHideAdditions) if (!hides.includes(k) && !shows.includes(k)) hides.push(k);
  } catch(e){ console.warn('ancestor-preserve merge failed', e); }
  // Build sets for quick lookup
  const hideSet = new Set();
  const showSet = new Set();
  for (const h of hides) {
    for (const k of layerKeyMap.keys()){
      if (k === h || k.startsWith(h + '/')) hideSet.add(k);
    }
    // also hide the parent itself if it's a key
    if (layerKeyMap.has(h)) hideSet.add(h);
  }
  // Ensure ~parent hides the entire subtree: explicitly expand hides to include
  // all descendant keys (in case some logic later treats parents specially).
  const expandedHideSet = new Set(hideSet);
  for (const h of hides) {
    if (!h) continue;
    for (const k of layerKeyMap.keys()){
      if (k.startsWith(h + '/')) expandedHideSet.add(k);
    }
    if (layerKeyMap.has(h)) expandedHideSet.add(h);
  }
  for (const s of shows) {
    for (const k of layerKeyMap.keys()){
      if (k === s || k.startsWith(s + '/')) showSet.add(k);
    }
    if (layerKeyMap.has(s)) showSet.add(s);
  }

  // detect parents that are hidden but have a shown descendant
  const parentsWithExceptions = new Set();
  for (const h of hides){
    for (const s of shows){
      if (s === h) continue;
      if (String(s).startsWith(String(h) + '/')) parentsWithExceptions.add(h);
    }
  }

  // Apply initial visibility: default visible unless hidden, but show parents that have exceptions
  for (const [key, el] of layerKeyMap.entries()){
    // If this key is a parent (has direct children), we normally keep the parent
    // visible to avoid blinking. However, if the parent (or its ancestor) is in
    // the expandedHideSet (i.e. ~parent requested), hide the parent as well
    // (unless it's explicitly shown). We apply parent hides immediately to
    // avoid conflicts with animation guards.
    const directChildren = getDirectChildrenKeys(key);
    if (directChildren.length > 0) {
      const parentIsHidden = expandedHideSet.has(key) && !(showSet.has(key) || showExceptions.has(key));
      if (parentIsHidden) {
        // hide parent immediately (no animation)
        try {
          el.style.transition = '';
          el.style.opacity = '0';
          el.style.pointerEvents = 'none';
        } catch(e){}
        try { const cb = document.querySelector(`input[data-layer-key="${key}"]`); if (cb) cb.checked = false; } catch(e){}
        // still continue to next entry; children will be handled below
        continue;
      }
      // otherwise keep parent visible; children control visibility
      toggleLayerVisibility(el, true, { animate: false });
      try { const cb = document.querySelector(`input[data-layer-key="${key}"]`); if (cb) cb.checked = true; } catch(e){}
      continue;
    }

    let visible = true;
    if (showExceptions.has(key) || showSet.has(key)) visible = true;
  else if (parentsWithExceptions.has(key)) visible = true;
  else if (expandedHideSet.has(key)) visible = false;
    else visible = true;
    toggleLayerVisibility(el, visible, { animate: animateGlobally ? true : false });
    // update corresponding checkbox immediately if present
    try { const cb = document.querySelector(`input[data-layer-key="${key}"]`); if (cb) cb.checked = Boolean(visible); } catch(e){}
  }

  // For each parent with exceptions, hide its direct children except the ones explicitly shown
  parentsWithExceptions.forEach(parentKey => {
    const children = getDirectChildrenKeys(parentKey);
    children.forEach(childKey => {
      const childEl = layerKeyMap.get(childKey);
      if (!childEl) return;
      const vis = (showSet.has(childKey) || showExceptions.has(childKey));
      toggleLayerVisibility(childEl, vis, { animate: animateGlobally ? true : false });
      try { const cb = document.querySelector(`input[data-layer-key="${childKey}"]`); if (cb) cb.checked = Boolean(vis); } catch(e){}
    });
  });
  // Additionally, for any parent that is explicitly hidden (~parent), hide its direct
  // children as well (unless those children are explicitly shown). This ensures
  // that ~parent hides the entire subtree even when parents remain visible to
  // avoid layout blinking.
  for (const parentKey of Array.from(layerKeyMap.keys())){
    const children = getDirectChildrenKeys(parentKey);
    if (!children.length) continue;
    if (!expandedHideSet.has(parentKey)) continue;
    children.forEach(childKey => {
      const childEl = layerKeyMap.get(childKey);
      if (!childEl) return;
      // If the child is explicitly shown, respect that
      const shouldShow = showSet.has(childKey) || showExceptions.has(childKey);
      toggleLayerVisibility(childEl, shouldShow, { animate: animateGlobally ? true : false });
      try { const cb = document.querySelector(`input[data-layer-key="${childKey}"]`); if (cb) cb.checked = Boolean(shouldShow); } catch(e){}
    });
  }
  // finally refresh checkboxes to set disabled/indeterminate states
  refreshLayerListCheckboxes();
  // refresh checkboxes
  refreshLayerListCheckboxes();
}

function refreshLayerListCheckboxes(){
  const layerList = document.getElementById('layerList'); if (!layerList) return;
  // traverse labels and update checkboxes based on element's computed visibility
  const inputs = Array.from(layerList.querySelectorAll('input[type=checkbox]'));
  // build a map key -> input for ancestor lookups
  const inputMap = new Map();
  inputs.forEach(cb => { if (cb.dataset && cb.dataset.layerKey) inputMap.set(cb.dataset.layerKey, cb); });

  // first, set each checkbox to reflect the element's computed visibility and enable it
  inputs.forEach(cb => {
    const key = cb.dataset.layerKey;
    if (!key) return;
    const el = layerKeyMap.get(key);
    if (!el) return;
    // do not override cb.checked here — leave checked as the authoritative state (user or programmatic)
    cb.disabled = false;
  });

  // then, for each checkbox, if any ancestor parent checkbox exists and is unchecked,
  // mark this checkbox as checked and disabled to indicate it's controlled by the parent
  inputs.forEach(cb => {
    const key = cb.dataset.layerKey; if (!key) return;
    // walk up the key path
    const parts = key.split('/');
    for (let i = parts.length - 1; i > 0; i--) {
      const ancestorKey = parts.slice(0, i).join('/');
      const ancestorInput = inputMap.get(ancestorKey);
      if (ancestorInput) {
          if (!ancestorInput.checked) {
            // parent is unchecked -> child should appear checked but disabled immediately
            cb.checked = true;
            cb.disabled = true;
          }
          break; // stop at nearest ancestor found
        }
    }
  });

  // now compute indeterminate state for parents: if a parent has some direct children
  // that are shown as exceptions (or mixed), mark the parent.indeterminate = true
  for (const [key, ancestorInput] of inputMap.entries()){
    const children = getDirectChildrenKeys(key);
    if (!children.length) { ancestorInput.indeterminate = false; continue; }
    let exceptions = 0, visible = 0, hidden = 0;
    children.forEach(childKey => {
      const cb = inputMap.get(childKey);
      if (!cb) return;
      if (cb.disabled && showExceptions.has(childKey)) exceptions++;
      if (cb.checked) visible++; else hidden++;
    });
    // parent is indeterminate if some children are exceptions or mixed visibility
    ancestorInput.indeterminate = (exceptions>0) || (visible>0 && hidden>0);
  }
}

function findElementByLabel(name){
  // prefer layerKeyMap lookup
  if (layerKeyMap.has(name)) return layerKeyMap.get(name);
  // fallback: prefix match
  for (const [k, el] of layerKeyMap.entries()){
    if (k === name || k.startsWith(name)) return el;
  }
  return null;
}

function collectVisibilityFromList(){
  const layerList = document.getElementById('layerList'); if (!layerList) return { show:[], hide:[] };
  // Hide-only: collect only the keys that are currently unchecked (i.e., hidden)
  const res = { hide: [], show: [] };
  const inputs = Array.from(layerList.querySelectorAll('input[type=checkbox]'));
  inputs.forEach(cb => {
    const key = cb.dataset.layerKey; if (!key) return;
    if (!cb.checked) res.hide.push(key);
  });
  // include explicit exceptions
  for (const k of showExceptions) res.show.push(k);
  return res;
}

function updateHashFromLayerList(){
  // read existing parsed hash to preserve params
  const parsed = parseHash();
  const vis = collectVisibilityFromList();
  const token = buildCompactHash(parsed.url || '', parsed.params || {}, vis);
  // we need to preserve original 6-field style when present; if not, just write #token
  // Debounce writing the hash so ongoing animations are not cancelled by an
  // immediate hashchange handler. We still mark the write as originating
  // locally so the next hashchange is ignored.
  try { if (__hashWriteTimeout) clearTimeout(__hashWriteTimeout); } catch(e){}
  __hashWriteTimeout = setTimeout(() => {
  suppressHashFor(120);
    // Write the new compact token directly
    location.hash = '#'+token;
    __hashWriteTimeout = null;
  }, 260);
}

document.addEventListener('DOMContentLoaded', ()=>{
  const cp = document.getElementById('copyLink');
  if (cp) {
    cp.addEventListener('click', (ev) => {
      try {
        // If a hash is already present in the URL, copy it exactly (prefixed
        // by the relative 'svg/' path). This ensures we don't re-serialize or
        // modify the current hash when the user wants an exact link.
        let text = '';
        if (location && location.hash && location.hash.length > 1) {
          text = `svg/${location.hash}`;
        } else {
          const url = currentUrl || '';
          const params = { s: Math.round(state.scale*100)/100, x: Math.round(state.tx*100)/100, y: Math.round(state.ty*100)/100 };
          const vis = collectVisibilityFromList();
          const token = buildCompactHash(url, params, vis);
          text = `svg/#${token}`;
        }
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(text).then(()=> setStatus('link copied'))
            .catch(() => { throw new Error('clipboard failed'); });
        } else {
          // fallback
          const ta = document.createElement('textarea'); ta.value = text; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); document.body.removeChild(ta); setStatus('link copied');
        }
      } catch(e){
        try { setStatus('copy failed'); } catch(e){}
      }
    });
  }
});

function fitToContainer(){
  if (!svgEl || !bbox) return;
  const containerRect = svgContainer.getBoundingClientRect();
  const cw = containerRect.width || window.innerWidth;
  const ch = containerRect.height || window.innerHeight;
  // compute a "view" in svg coords that fits the bbox inside the container
  // This mirrors the image viewer logic: determine a scale then derive the
  // visible svg rect (view) so that panning/zooming can operate in svg coords.
  const sx = cw / bbox.width; const sy = ch / bbox.height;
  const s = Math.min(sx, sy) * 0.9; // leave margins
  // display size of the bbox when scaled
  const displayWidth = bbox.width * s;
  const displayHeight = bbox.height * s;
  const offsetX = (cw - displayWidth) / 2;
  const offsetY = (ch - displayHeight) / 2;
  // view.topLeft such that the bbox is centered with margins
  const topLeftX = bbox.x - (offsetX / s);
  const topLeftY = bbox.y - (offsetY / s);
  const viewWidth = cw / s;
  const viewHeight = ch / s;
  view = { topLeft: [ topLeftX, topLeftY ], bottomRight: [ topLeftX + viewWidth, topLeftY + viewHeight ] };
  // derive state.scale/tx/ty from view so render() can continue to use state
  state.scale = s || 1;
  const cx = view.topLeft[0] + (view.bottomRight[0] - view.topLeft[0]) / 2;
  const cy = view.topLeft[1] + (view.bottomRight[1] - view.topLeft[1]) / 2;
  state.tx = (cw/2) - cx * state.scale;
  state.ty = (ch/2) - cy * state.scale;
}

function render(){
  if (!svgEl || !bbox) return;
  // We'll compute a CSS transform that applies translate(tx,ty) in pixels,
  // then scale around the top-left (we set transform-origin to 0 0 on load),
  // and then rotate around the center of the bbox by translating to center,
  // rotating, and translating back.
  const cx = bbox.x + bbox.width/2;
  const cy = bbox.y + bbox.height/2;
  // Compose: translate (pixel pan) -> scale
  const translatePart = `translate(${Math.round(state.tx)}px, ${Math.round(state.ty)}px)`;
  const scalePart = `scale(${state.scale})`;
  svgEl.style.transform = `${translatePart} ${scalePart}`;
}

// simple tweening helper for numeric state transitions
let __svg_tween_cancel = null;
function tweenProps(from, to, duration = 400, onUpdate){
  if (__svg_tween_cancel) __svg_tween_cancel();
  const start = performance.now();
  const keys = Object.keys(to);
  let rafId = null;
  let cancelled = false;
  // build a cubic-bezier easing function (approximation via Newton-Raphson)
  const bezier = (function(){
    function cubicBezier(p1x,p1y,p2x,p2y){
      const cx = 3 * p1x, bx = 3 * (p2x - p1x) - cx, ax = 1 - cx - bx;
      const cy = 3 * p1y, by = 3 * (p2y - p1y) - cy, ay = 1 - cy - by;
      function sampleCurveX(t){ return ((ax * t + bx) * t + cx) * t; }
      function sampleCurveY(t){ return ((ay * t + by) * t + cy) * t; }
      function sampleCurveDerivativeX(t){ return (3 * ax * t + 2 * bx) * t + cx; }
      function solveCurveX(x){
        let t2 = x;
        for (let i = 0; i < 8; i++){
          const x2 = sampleCurveX(t2) - x;
          const d = sampleCurveDerivativeX(t2);
          if (Math.abs(x2) < 1e-6) return t2;
          if (Math.abs(d) < 1e-6) break;
          t2 = t2 - x2 / d;
        }
        // fallback to bisection
        let t0 = 0, t1 = 1; t2 = x;
        while (t0 < t1){
          const x2 = sampleCurveX(t2);
          if (Math.abs(x2 - x) < 1e-6) return t2;
          if (x > x2) t0 = t2; else t1 = t2;
          t2 = (t1 - t0) * 0.5 + t0;
        }
        return t2;
      }
      return function(x){ return sampleCurveY(solveCurveX(x)); };
    }
    return cubicBezier(0.22, 1, 0.36, 1);
  })();

  function step(now){
    const t = Math.min(1, (now - start) / duration);
    const eased = bezier(t);
    const cur = {};
    keys.forEach(k => {
      const a = typeof from[k]==='number' ? from[k] : 0;
      const b = typeof to[k]==='number' ? to[k] : a;
      cur[k] = a + (b - a) * eased;
    });
    try { onUpdate(cur); } catch(e){}
    if (t < 1 && !cancelled) rafId = requestAnimationFrame(step);
    else {
      // final commit
      try { onUpdate(Object.assign({}, to)); } catch(e){}
      __svg_tween_cancel = null;
    }
  }
  rafId = requestAnimationFrame(step);
  __svg_tween_cancel = () => { cancelled = true; if (rafId) cancelAnimationFrame(rafId); __svg_tween_cancel = null; };
  return __svg_tween_cancel;
}

// animate to target params (s, x, y, r)
function animateTo(params, duration = 900){
  if (!params) return Promise.resolve();
  const target = {
    scale: typeof params.s === 'number' ? params.s : state.scale,
    tx: typeof params.x === 'number' ? params.x : state.tx,
    ty: typeof params.y === 'number' ? params.y : state.ty,
    // rotation intentionally omitted (viewer is pan/zoom-only)
  };
  return new Promise(resolve => {
    tweenProps({ scale: state.scale, tx: state.tx, ty: state.ty },
               { scale: target.scale, tx: target.tx, ty: target.ty },
               duration,
               (cur) => {
                 state.scale = cur.scale; state.tx = cur.tx; state.ty = cur.ty;
                 // update UI controls during animation
                 // UI sliders removed — internal state updated but controls absent
                 // Keep view consistent with state for subsequent interactions
                 try { syncViewFromState(); } catch(e){}
                 render();
               });
    // resolve after duration (plus tiny buffer)
    setTimeout(() => { resolve(); }, duration + 20);
  });
}

// Merge provided params with captured defaults so missing fields animate to defaults
function mergeWithDefaults(params){
  const defs = defaultSvgParams || { s: state.scale, x: state.tx, y: state.ty };
  const p = params && typeof params === 'object' ? params : {};
  return {
    s: (typeof p.s === 'number') ? p.s : defs.s,
    x: (typeof p.x === 'number') ? p.x : defs.x,
    y: (typeof p.y === 'number') ? p.y : defs.y
  };
}

// Keep `view` consistent with `state` so interactions operate in svg coords.
function syncViewFromState(){
  if (!svgContainer || !bbox) return;
  try {
    const rect = svgContainer.getBoundingClientRect();
    if (!rect.width || !rect.height) return;
    const viewWidth = rect.width / state.scale;
    const viewHeight = rect.height / state.scale;
    const cx = (rect.width/2 - state.tx) / state.scale;
    const cy = (rect.height/2 - state.ty) / state.scale;
    view = { topLeft: [ cx - viewWidth/2, cy - viewHeight/2 ], bottomRight: [ cx + viewWidth/2, cy + viewHeight/2 ] };
  } catch(e) { /* ignore sync errors */ }
}

// interaction
// Drag-to-pan using `view` in SVG coords (mirrors img/index.html behavior)
svgContainer.addEventListener('mousedown', (e)=>{
  // ensure view exists (defensive): if the viewer wasn't fit yet, initialize it
  if (!view) try { fitToContainer(); } catch(e){}
  isDragging=true;
  const rect = svgContainer.getBoundingClientRect();
  const x = (e.clientX - rect.left);
  const y = (e.clientY - rect.top);
  dragStart = [x, y];
  svgContainer.style.cursor = 'grabbing';
  try { setStatus('drag:start'); } catch(e){}
});
window.addEventListener('mouseup', ()=>{ if (isDragging){ isDragging=false; svgContainer.style.cursor=''; commitHash(); }});
window.addEventListener('mousemove', (e)=>{
  if (!isDragging || !view) return;
  const rect = svgContainer.getBoundingClientRect();
  const x = (e.clientX - rect.left);
  const y = (e.clientY - rect.top);
  const dx = x - dragStart[0];
  const dy = y - dragStart[1];
  const vw = (view.bottomRight[0] - view.topLeft[0]);
  const vh = (view.bottomRight[1] - view.topLeft[1]);
  // convert pixel delta to svg coord delta
  const svgDx = (dx * vw) / rect.width;
  const svgDy = (dy * vh) / rect.height;
  view.topLeft[0] -= svgDx; view.topLeft[1] -= svgDy;
  view.bottomRight[0] -= svgDx; view.bottomRight[1] -= svgDy;
  // update state from view (derive scale/tx/ty for render)
  const cw = rect.width; const ch = rect.height;
  state.scale = cw / (view.bottomRight[0] - view.topLeft[0]);
  const cx = view.topLeft[0] + (view.bottomRight[0] - view.topLeft[0]) / 2;
  const cy = view.topLeft[1] + (view.bottomRight[1] - view.topLeft[1]) / 2;
  state.tx = (cw/2) - cx * state.scale;
  state.ty = (ch/2) - cy * state.scale;
  dragStart = [x, y];
  render();
  try { setStatus(`drag view ${JSON.stringify({topLeft:view.topLeft,bottomRight:view.bottomRight})}`); } catch(e){}
});

// wheel zoom centered at mouse
// Wheel-based zoom that updates `view` (mirrors img/index.html behavior)
svgContainer.addEventListener('wheel', (e)=>{
  if (!view) try { fitToContainer(); } catch(e){}
  if (!view) return;
  e.preventDefault();
  const rect = svgContainer.getBoundingClientRect();
  if (!rect.width || !rect.height) return;
  const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
  const pointerX = (e.clientX - rect.left) / rect.width;
  const pointerY = (e.clientY - rect.top) / rect.height;
  const centerX = view.topLeft[0] + pointerX * (view.bottomRight[0] - view.topLeft[0]);
  const centerY = view.topLeft[1] + pointerY * (view.bottomRight[1] - view.topLeft[1]);
  const vw = (view.bottomRight[0] - view.topLeft[0]) * zoomFactor;
  const vh = (view.bottomRight[1] - view.topLeft[1]) * zoomFactor;
  view.topLeft = [ Math.floor(centerX - vw * pointerX), Math.floor(centerY - vh * pointerY) ];
  view.bottomRight = [ Math.floor(centerX + vw * (1 - pointerX)), Math.floor(centerY + vh * (1 - pointerY)) ];
  // derive state from view so existing render/commit logic uses current values
  state.scale = rect.width / (view.bottomRight[0] - view.topLeft[0]);
  const cx = view.topLeft[0] + (view.bottomRight[0] - view.topLeft[0]) / 2;
  const cy = view.topLeft[1] + (view.bottomRight[1] - view.topLeft[1]) / 2;
  state.tx = (rect.width/2) - cx * state.scale;
  state.ty = (rect.height/2) - cy * state.scale;
  render();
  try { setStatus(`wheel view ${JSON.stringify({topLeft:view.topLeft,bottomRight:view.bottomRight,scale:state.scale})}`); } catch(e){}
  // persist new view/scale to the hash after user stops zooming
  try { scheduleViewHashWrite(100); } catch(e){}
},{ passive: false });

// rotate/zoom input controls removed per user preference

resetBtn.addEventListener('click', ()=>{
  // Animate back to the captured defaults (fit-to-container) then remove view params
  const parsed = parseHash();
  const defs = defaultSvgParams || { s: state.scale, x: state.tx, y: state.ty };
  // animateTo will merge with defaults, but we call with explicit defaults here
  animateTo({ s: defs.s, x: defs.x, y: defs.y }, 700).catch(()=>{}).then(() => {
    // After animation, write a compact hash that preserves url and visibility but omits view params
    try { suppressHashFor(120); } catch(e){}
    const token = buildCompactHash(parsed.url || '', {}, parsed.vis || { show: [], hide: [] });
    location.hash = '#'+token;
  });
});

// Hash management: only write final state on interaction end or reset
let hashTimeout = null;
function commitHash(){
  const url = currentUrl || '';
  const parsed = parseHash();
  const annotations = (parsed && parsed.annotations) ? parsed.annotations : { boxes:[], lines:[], color:'ff0000' };
  // Use same 6-field format for compatibility: view&opacity&boxes&lines&url&<rotation-slot>
  const viewParam = '';
  const opacity = 100;
  // Serialize params into url token
  function buildUrlToken(url, params) {
    let token = url || '';
    for (const k of Object.keys(params || {})) {
      token += `@${k}=${encodeURIComponent(String(params[k]))}`;
    }
    return token;
  }
  const params = { s: Math.round(state.scale*100)/100, x: Math.round(state.tx*100)/100, y: Math.round(state.ty*100)/100 };
  const token = buildCompactHash(url, params, parsed.vis || { show: [], hide: [] });
  suppressHashFor(120);
  console.debug('commitHash: writing compact hash', token);
  location.hash = '#'+token;
}

let currentUrl = '';

// When we write location.hash from a UI interaction, the browser fires a hashchange
// event which can re-apply visibility programmatically and cancel in-progress
// animations. Use a timestamp guard so brief UI-originated writes are ignored
// by the hashchange handler for a short window.
try { window.__suppressHashChangeUntil = 0; } catch(e){}
function suppressHashFor(ms){ try { window.__suppressHashChangeUntil = Date.now() + (ms || 120); } catch(e){} }
// debounced hash write to avoid immediate reapplication during animations
let __hashWriteTimeout = null;
let __viewHashTimeout = null;

function scheduleViewHashWrite(delay = 100){
  try { if (__viewHashTimeout) clearTimeout(__viewHashTimeout); } catch(e){}
  __viewHashTimeout = setTimeout(() => {
    try { commitHash(); } catch(e){}
    __viewHashTimeout = null;
  }, delay);
}

// Public: accept messy hrefs like parent does
window.acceptViewerHash = function(raw){
  try{
    if (!raw || typeof raw !== 'string') return false;
    const s = raw.trim();
    const ampIdx = s.indexOf('&&&');
    if (ampIdx !== -1) {
      const after = s.slice(ampIdx+3);
      const token = after.split('&')[0] || '';
      if (!token) return false;
      // parse the legacy token into parsed fields and re-emit in compact form
      const parsed = parseHash.call({ location: { hash: '#'+token } }) || parseHash();
      const params = parsed.params || { s: state.scale, x: state.tx, y: state.ty };
      const compact = buildCompactHash(parsed.url || token, params, parsed.vis || { show: [], hide: [] });
      location.hash = '#'+compact;
      return true;
    }
  const urlMatch = s.match(/(https?:\/\/[^#\s]+|\/[^#\s]+|[^#\s]+\.svg)/i);
    if (urlMatch && urlMatch[0]){
      let url = urlMatch[0];
      try{ const u = new URL(url, location.origin); url = u.pathname + (u.search||''); } catch(e){}
      // emit compact hash using current view/state
      const params = { s: state.scale, x: Math.round(state.tx), y: Math.round(state.ty) };
      const compact = buildCompactHash(url, params, { show: [], hide: [] });
      location.hash = '#'+compact; return true;
    }
    return false;
  } catch(e){ return false; }
}

// Initial load (guarded startup to tolerate injected scripts that may throw)
function startViewer(){
  try {
    const parsed = parseHash();
    let url = parsed.url || '';
    // Only load if an explicit .svg filename is present in the hash
    if (!url || url.indexOf('.svg') === -1) {
      setStatus('waiting for #file.svg');
      window.viewerReady = false;
      return Promise.resolve();
    }
    currentUrl = url;
  // Apply params if present (scale/tx/ty) after load
    // queue visibility to apply after load if present
    if (parsed.vis) pendingVis = parsed.vis;
    return loadSVG(url).then(() => {
      try {
        if (parsed.params) {
              // animate into the requested params rather than snapping. Merge
              // missing fields with captured defaults so unspecified values
              // animate toward the default fit-to-container state.
              return animateTo(mergeWithDefaults(parsed.params), 900).catch(()=>{}).then(()=>{ try { syncViewFromState(); } catch(e){} });
            }
      } catch (e) {
        console.warn('Applying params failed', e);
      }
    }).catch(e => {
      console.warn('Initial load failed', e);
      pendingVis = null;
    });
  } catch (e) {
    console.warn('startViewer caught', e);
    return Promise.resolve();
  }
}

// Global non-fatal error handler: log but don't let injected scripts abort viewer startup
window.addEventListener('error', (ev) => {
  // Keep default behavior but ensure it's logged to console for tests
  try { console.warn('PAGE ERROR (non-fatal):', ev && ev.message ? ev.message : ev); } catch(e){}
  // do not call ev.preventDefault() so other handlers can run; we only avoid throwing here
});

// Kick off startup asynchronously (guarded)
setTimeout(() => { startViewer(); }, 0);

// respond to external hash changes
window.addEventListener('hashchange', ()=>{
  // If this hashchange was caused by our own UI write, skip re-applying
  // visibility/state to avoid cancelling user-initiated animations.
  if (typeof window.__suppressHashChangeUntil === 'number' && Date.now() < window.__suppressHashChangeUntil) { console.debug('hashchange: suppressed by timestamp'); return; }
  console.debug('hashchange: applying parsed hash');
  const parsed = parseHash();
  if (!parsed) return;
  // if URL changed, load new svg immediately
  if (parsed.url && parsed.url !== currentUrl) {
    currentUrl = parsed.url;
    loadSVG(currentUrl);
    return;
  }
  // if same URL but params changed, animate to new params
  if (parsed.url === currentUrl) {
  if (parsed.params) animateTo(mergeWithDefaults(parsed.params), 800).catch(()=>{});
    if (parsed.vis) {
      if (!svgEl) { pendingVis = parsed.vis; }
      else { try { applyVisibilityFromVis(parsed.vis, { animate: true }); } catch(e){} }
    }
  }
});

window.viewerReady = false;
</script>
</body>
</html>
