<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Inflect SVG Viewer</title>
<style>
  html,body{height:100%;margin:0;background:#111;color:#fff;font-family:Helvetica,Arial,sans-serif}
  #app{position:relative;height:100vh;overflow:hidden}
  #canvas{width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:#222}
  #controls{position:absolute;right:8px;top:8px;background:rgba(255,255,255,0.06);padding:8px;border-radius:6px;color:#fff;font-size:13px}
  #controls label{display:block;margin-bottom:6px;font-size:12px}
  #controls input[type=range]{width:140px}
  #status{position:absolute;left:8px;top:8px;background:rgba(0,0,0,0.5);padding:6px 8px;border-radius:6px;font-size:12px}
  /* when embedded in an iframe we hide the UI chrome */
  .embedded #controls, .embedded #status{ display:none !important; }
  /* layer list inside controls */
  #layerList{ max-height:200px; overflow:auto; margin-top:6px; font-size:13px }
  #layerList label{ display:flex; align-items:center; gap:8px; margin:4px 0 }
  svg{max-width:100%;max-height:100%;}
</style>
<style>
  /* Force an exception child to remain visible without transitions to avoid flicker */
  .inflect-exception-visible { opacity: 1 !important; visibility: visible !important; transition: none !important; }
</style>
</head>
<body>
<div id="app">
  <div id="canvas"><div id="svgContainer"></div></div>
  <div id="controls">
    <label>Rotate <input id="rotate" type="range" min="-180" max="180" value="0"></label>
    <label>Zoom <input id="zoom" type="range" min="10" max="500" value="100"></label>
    <button id="reset">Reset</button>
    <div style="margin-top:8px;font-weight:600">Layers</div>
    <div id="layerList" aria-live="polite"></div>
    <button id="diagToggle" style="margin-top:8px">Diagnostics</button>
    <pre id="diagPanel" style="display:none;white-space:pre-wrap;max-height:200px;overflow:auto;background:rgba(0,0,0,0.3);padding:8px;margin-top:8px;font-size:12px"></pre>
  </div>
  <div id="status">loading...</div>
</div>
<script>
// detect if running inside an iframe and toggle embedded UI
try {
  if (window.top && window.top !== window.self) {
    document.documentElement.classList.add('embedded');
  }
} catch(e) {
  // cross-origin top access may throw; assume embedded in that case
  try { document.documentElement.classList.add('embedded'); } catch(e){}
}

// Simple inflect-style hash parser: fields separated by & with url in 5th slot.
// Parse hash and tolerate a url token that may include @param pairs: url@k=v@k2=v2
function parseUrlField(urlField) {
  if (!urlField) return { url: '', params: {}, vis: { show: [], hide: [] } };
  // support optional trailing visibility tokens after a slash, e.g. 'file.svg/~layer+other'
  let base = String(urlField);
  let vis = { show: [], hide: [] };
  const slashIdx = base.indexOf('/');
  if (slashIdx !== -1) {
    const visPart = base.slice(slashIdx + 1);
    base = base.slice(0, slashIdx);
    // tokens start with + or ~; capture sequences like +name, ~name
    const re = /([+~])([^+~\/]+)/g;
    let m;
    while ((m = re.exec(visPart)) !== null) {
      const sym = m[1]; const name = decodeURIComponent(m[2]);
        // resolve short label (no slash) to full hierarchical key if unique
        let resolved = name;
        if (!name.includes('/')){
          // find keys whose last segment matches name
          const matches = [];
          for (const k of layerKeyMap.keys()){
            if (String(k).split('/').pop() === name) matches.push(k);
          }
          if (matches.length === 1) resolved = matches[0];
        }
        if (sym === '+') vis.show.push(resolved);
        else if (sym === '~') vis.hide.push(resolved);
    }
  }
  const parts = base.split('@').map(s => s.trim()).filter(Boolean);
  const url = parts[0] || '';
  const params = {};
  parts.slice(1).forEach(p => {
    const eq = p.indexOf('=');
    if (eq === -1) return;
    const k = p.slice(0, eq);
    const v = p.slice(eq+1);
    if (!k) return;
    params[k] = isNaN(Number(v)) ? v : Number(v);
  });
  return { url, params, vis };
}

function buildUrlField(url, params, vis){
  let token = url || '';
  if (params) for (const k of Object.keys(params)) token += `@${k}=${encodeURIComponent(String(params[k]))}`;
  // Hide-only semantics: only serialize hidden layer keys as ~key
    if (vis) {
      let seg = '';
      // helper to pick a short label if unique (last segment), otherwise use full key
      function shortOrFull(k) {
        if (!k) return k;
        const last = String(k).split('/').pop();
        // check uniqueness among layerKeyMap keys' last segments
        let count = 0;
        for (const kk of layerKeyMap.keys()) if ((String(kk).split('/').pop()) === last) count++;
        return count === 1 ? last : k;
      }
      // attempt to compress pattern: if vis.hide contains all direct children of a parent
      // except one child which is in vis.show, prefer serializing ~parent and +child
      let hideList = (vis.hide || []).slice();
      let showList = (vis.show || []).slice();
      try {
        // build a set for quick lookup
        const hideSet = new Set(hideList);
        for (const parentKey of Array.from(layerKeyMap.keys())){
          const children = getDirectChildrenKeys(parentKey);
          if (children.length < 2) continue;
          // find which children are hidden and which are shown
          const hiddenChildren = children.filter(c => hideSet.has(c));
          const shownChildren = children.filter(c => showList.includes(c));
          if (hiddenChildren.length === children.length - 1 && shownChildren.length === 1){
            // compress: remove hiddenChildren from hideList, add parentKey to hideList
            hideList = hideList.filter(h => !hiddenChildren.includes(h));
            hideList.push(parentKey);
            // ensure the shown child stays in showList as full key
          }
        }
      } catch(e) { /* ignore compression failures */ }

      if (showList && showList.length) showList.forEach(s => { seg += `+${encodeURIComponent(String(shortOrFull(s)))}`; });
      if (hideList && hideList.length) hideList.forEach(h => { seg += `~${encodeURIComponent(String(shortOrFull(h)))}`; });
      if (seg) token += '/' + seg;
  }
  return token;
}

function parseHash(){
  const hash = location.hash.slice(1);
  if (!hash) return { url: '', params: {}, view: null, rotation:0 };
  // If the hash is a bare path like 'opening.svg' or '/svg/opening.svg', accept it directly
  if (!hash.includes('&') && (hash.indexOf('.svg') !== -1 || hash.startsWith('/') || /^\w[\w\-\.]*\.svg$/i.test(hash))) {
    const parsed = parseUrlField(hash);
    return { url: parsed.url, params: parsed.params || {}, view: null, rotation: (parsed.params && parsed.params.r) || 0, vis: parsed.vis || { show: [], hide: [] } };
  }
  const parts = hash.split('&');
  let rawUrlField = parts[4] || '';
  // tolerant shift
  if (!rawUrlField && parts.length>=5 && parts[3] && (parts[3].includes('.svg')||parts[3].startsWith('svg/'))) {
    rawUrlField = parts[3];
  }
  const parsed = parseUrlField(rawUrlField);
  let rotation = 0;
  if (parts[5] && !isNaN(parseFloat(parts[5]))) rotation = parseFloat(parts[5]);
  // rotation may also be in params
  if (parsed.params && typeof parsed.params.r === 'number') rotation = parsed.params.r;
  return { url: parsed.url, params: parsed.params || {}, view: null, rotation, vis: parsed.vis || { show: [], hide: [] } };
}
function layersToUrlField(u){ return u || ''; }

let svgContainer = document.getElementById('svgContainer');
let status = document.getElementById('status');
let rotateInput = document.getElementById('rotate');
let zoomInput = document.getElementById('zoom');
let resetBtn = document.getElementById('reset');

let svgEl = null; // the embedded svg root
let wrapperG = null; // group we apply transforms to
let bbox = null;
// animation timing (ms) for fades; make configurable
const FADE_DURATION = 1200;
let state = { tx:0, ty:0, scale:1, rotation:0 };
let isDragging=false, dragStart=null, dragStartState=null;
 let pendingVis = null; // visibility instructions to apply after load
let layerKeyMap = new Map();
let showExceptions = new Set(); // keys explicitly shown despite ancestor hide

function getDirectChildrenKeys(parentKey){
  const res = [];
  const prefix = parentKey + '/';
  for (const k of layerKeyMap.keys()){
    if (!k.startsWith(prefix)) continue;
    const rest = k.slice(prefix.length);
    if (rest.indexOf('/') === -1) res.push(k);
  }
  return res;
}

function getKeyForElement(el){
  for (const [k, v] of layerKeyMap.entries()){
    if (v === el) return k;
  }
  return null;
}

function setStatus(s){ status.textContent = s; }

async function loadSVG(url){
  if (!url) { setStatus('no url'); return; }
  try {
    setStatus('loading '+url);
    const res = await fetch(url);
    if (!res.ok) throw new Error('fetch failed '+res.status);
    const text = await res.text();
    svgContainer.innerHTML = text;
    svgEl = svgContainer.querySelector('svg');
    if (!svgEl) throw new Error('no <svg> in file');
    // ensure width/height viewBox exists
    if (!svgEl.getAttribute('viewBox')) {
      const w = svgEl.getAttribute('width')||svgEl.clientWidth||300;
      const h = svgEl.getAttribute('height')||svgEl.clientHeight||150;
      svgEl.setAttribute('viewBox','0 0 '+w+' '+h);
    }
    // we will manipulate the SVG using CSS transforms on the svg element
    // ensure the svg is positioned absolutely inside the container so CSS
    // translate/scale/rotate behaves in pixel coordinates
    svgEl.style.position = 'absolute';
    svgEl.style.left = '0';
    svgEl.style.top = '0';
    svgEl.style.transformOrigin = '0 0';
    // compute bbox after a tick and derive initial fit values
    await new Promise(r => setTimeout(r,20));
    try { bbox = svgEl.getBBox(); } catch(e) { bbox = { x:0,y:0,width:svgEl.clientWidth||300,height:svgEl.clientHeight||150 }; }
    fitToContainer();
    // leave rotation/scale as default; caller may override via params
    rotateInput.value = 0;
    zoomInput.value = Math.round(state.scale*100);
    render();
    setStatus('ready');
    window.viewerReady = true;
  // build layer list UI so user can show/hide layers
  try { buildLayerList(); } catch(e) { console.warn('build layer list failed', e); }
  // apply any pending visibility instructions now that layers exist
  try { if (pendingVis) { applyVisibilityFromVis(pendingVis, { animate: false }); pendingVis = null; } } catch(e) { console.warn('apply pending vis failed', e); }
    try { window.layerKeyMap = layerKeyMap; } catch(e){}
  } catch (e) {
    console.error(e);
    setStatus('error');
    window.viewerReady = false;
  }
}

// animate opacity values for a set of elements (obj map name->elem)
// build a simple layer list UI from top-level svg children
function buildLayerList(){
  if (!svgEl) return;
  const layerList = document.getElementById('layerList');
  if (!layerList) return;
  layerList.innerHTML = '';

  // exclude non-visual/definition tags and elements defined under <defs>
  const excluded = new Set([
    'SCRIPT','STYLE','DEFS','METADATA','TITLE','PATTERN',
    'LINEARGRADIENT','RADIALGRADIENT','CLIPPATH','MASK','FILTER','MARKER','SYMBOL','VIEW','FONT'
  ]);

  function getLabel(el, idx){
    return el.id || el.getAttribute('data-name') || `${el.tagName.toLowerCase()}_${idx}`;
  }

  function makeNode(el, idx, parentKey){
    const li = document.createElement('div');
    li.style.marginLeft = '0px';
    const label = document.createElement('label');
    label.style.display = 'flex'; label.style.alignItems = 'center'; label.style.gap = '8px';
    const cb = document.createElement('input'); cb.type = 'checkbox';
    const computed = window.getComputedStyle(el);
    cb.checked = !(computed.display === 'none' || computed.visibility === 'hidden');
    // compute a stable key and ensure uniqueness
    const baseKey = getLabel(el, idx);
    let key = parentKey ? `${parentKey}/${baseKey}` : baseKey;
    // ensure uniqueness
    let uniqueKey = key; let suffix = 1;
    while (layerKeyMap.has(uniqueKey)) { uniqueKey = key + '_' + (suffix++); }
    key = uniqueKey;
    cb.dataset.layerKey = key;
    label.dataset.layerKey = key;
    layerKeyMap.set(key, el);
  cb.addEventListener('change', () => {
    const key = cb.dataset.layerKey;
    if (!key) { toggleLayerVisibility(el, cb.checked, { animate: true }); updateHashFromLayerList(); refreshLayerListCheckboxes(); return; }
    // If this node has direct children, and the user is unchecking it, but some
    // direct children are marked as showExceptions (should remain visible), then
    // avoid hiding the parent element (which may cause children to blink). Instead
    // hide only the siblings while preserving the exception child immediately.
    const direct = getDirectChildrenKeys(key);
    if (direct.length > 0 && cb.checked === false) {
      // detect if any direct child is in showExceptions OR currently visible
      const exceptions = direct.filter(dk => showExceptions.has(dk));
      const visibleChildren = direct.filter(dk => {
        const el = layerKeyMap.get(dk);
        if (!el) return false;
        const cs = window.getComputedStyle(el);
        const op = parseFloat(cs.opacity || '1');
        return cs.display !== 'none' && cs.visibility !== 'hidden' && op > 0;
      });
      if (exceptions.length > 0 || visibleChildren.length > 0) {
        // keep parent visible
        toggleLayerVisibility(el, true, { animate: false });
        // ensure checkbox shows unchecked state (user intent) while parent remains visible
        try { cb.checked = false; } catch(e){}
        // for each child: if it's an exception, ensure visible immediately; else fade out
        const fadePromises = [];
        direct.forEach(childKey => {
          const childEl = layerKeyMap.get(childKey);
          if (!childEl) return;
          if (showExceptions.has(childKey) || visibleChildren.includes(childKey)) {
            // protect exception child
            if (childEl.classList) childEl.classList.add('inflect-exception-visible');
            toggleLayerVisibility(childEl, true, { animate: false });
            const prev = __fadeCancels.get(childEl); if (prev) prev();
          } else {
            fadePromises.push(animateLayerVisibility(childEl, false));
          }
        });
        Promise.all(fadePromises).then(() => {
          // ensure non-exception children are hidden
          direct.forEach(childKey => {
            if (showExceptions.has(childKey)) return;
            const childEl = layerKeyMap.get(childKey);
            if (!childEl) return;
            toggleLayerVisibility(childEl, false, { animate: false });
          });
          refreshLayerListCheckboxes(); updateHashFromLayerList();
        }).catch(() => { refreshLayerListCheckboxes(); updateHashFromLayerList(); });
        return;
      }
    }
    // default behavior: toggle element visibility directly
    toggleLayerVisibility(el, cb.checked, { animate: true }); updateHashFromLayerList(); refreshLayerListCheckboxes();
  });
    // allow clicking the label when checkbox is disabled to create a show-exception
    label.addEventListener('click', (e) => {
      // only intercept when the input is currently disabled (i.e., ancestor controls it)
      if (!cb.disabled) return;
      e.preventDefault(); e.stopPropagation();
      const key = cb.dataset.layerKey;
      if (!key) return;
      const parentParts = key.split('/').slice(0, -1);
      const parentKey = parentParts.length ? parentParts.join('/') : null;
      // toggle exception
      if (showExceptions.has(key)) {
        showExceptions.delete(key);
        // remove exception-visible marker
        const excOld = layerKeyMap.get(key);
        if (excOld && excOld.classList) excOld.classList.remove('inflect-exception-visible');
        // reapply visibility from parsed vis (which may hide parent again)
        try { applyVisibilityFromVis(parseHash().vis || { hide: [], show: [] }, { animate: false }); } catch(e){}
      } else {
        showExceptions.add(key);
        // if parent exists and is currently hidden by vis, reveal parent and hide siblings
        if (parentKey && layerKeyMap.has(parentKey)){
          const parentEl = layerKeyMap.get(parentKey);
          // show parent element immediately so child can be rendered (no animation)
          toggleLayerVisibility(parentEl, true, { animate: false });
          // Ensure the exception child is visible immediately (no animation) so it
          // doesn't flicker while we manipulate the parent/other siblings.
          const excEl = layerKeyMap.get(key);
          if (excEl) {
            // mark as exception-visible to protect from animation/hide
            if (excEl.classList) excEl.classList.add('inflect-exception-visible');
            // show immediately with no transition
            toggleLayerVisibility(excEl, true, { animate: false });
            try { excEl.style.transition = 'none'; excEl.style.opacity = '1'; } catch(e){}
            // cancel any pending fade on this element
            const prev = __fadeCancels.get(excEl); if (prev) prev();
          }
          // fade out siblings first (animate), then once faded set their display none and
          // keep the exception child visible (no animate in) to avoid blink.
          const children = getDirectChildrenKeys(parentKey);
          const fadeOutPromises = [];
          children.forEach(childKey => {
            if (childKey === key) return; // skip exception child for now
            const childEl = layerKeyMap.get(childKey);
            if (!childEl) return;
            // animate fade out
            fadeOutPromises.push(animateLayerVisibility(childEl, false));
          });
          // when all siblings have finished fading out, ensure they're hidden and then show exception
          Promise.all(fadeOutPromises).then(() => {
            children.forEach(childKey => {
              const childEl = layerKeyMap.get(childKey);
              if (!childEl) return;
              if (childKey === key) return;
              // ensure hidden immediately (no animation)
              toggleLayerVisibility(childEl, false, { animate: false });
            });
            // ensure the exception child remains visible (no animation)
            const excEl2 = layerKeyMap.get(key);
            if (excEl2) toggleLayerVisibility(excEl2, true, { animate: false });
            // finally update hash/UI
            refreshLayerListCheckboxes(); updateHashFromLayerList();
          }).catch(() => {
            // fallback: immediate apply
            children.forEach(childKey => {
              const childEl = layerKeyMap.get(childKey);
              if (!childEl) return;
              if (childKey === key) return;
              toggleLayerVisibility(childEl, false, { animate: false });
            });
            const excEl3 = layerKeyMap.get(key); if (excEl3) toggleLayerVisibility(excEl3, true, { animate: false });
            refreshLayerListCheckboxes(); updateHashFromLayerList();
          });
        } else {
          // no parent: just show this layer (user action)
            toggleLayerVisibility(el, true, { animate: true });
        }
      }
      refreshLayerListCheckboxes();
      updateHashFromLayerList();
    });
  const span = document.createElement('span');
  // display only the local label (omit parent prefix) for readability
  const displayLabel = parentKey ? baseKey : baseKey;
  span.textContent = displayLabel;
    label.appendChild(cb); label.appendChild(span);
    li.appendChild(label);
    // if element has element children, show nested list
    const childElems = Array.from(el.children).filter(c => c.nodeType===1 && !excluded.has((c.tagName||'').toUpperCase()) && !c.closest('defs'));
    if (childElems.length > 0){
      const container = document.createElement('div');
      container.style.marginLeft = '12px';
      childElems.forEach((c, ci) => {
        container.appendChild(makeNode(c, ci, key));
      });
      li.appendChild(container);
    }
    return li;
  }

  const topChildren = Array.from(svgEl.children).filter(c => c.nodeType===1 && !excluded.has((c.tagName||'').toUpperCase()) && !c.closest('defs'));
  layerKeyMap.clear();
  topChildren.forEach((el, idx) => {
    layerList.appendChild(makeNode(el, idx, null));
  });
  // enforce parent/child checkbox disabled state after building
  refreshLayerListCheckboxes();
  // expose for debugging/tests
  try { window.layerKeyMap = layerKeyMap; } catch(e){}
}

function toggleLayerVisibility(el, show, opts){
  if (!el) return;
  // If this element is explicitly marked as an exception-visible, never hide it
  try { if (!show && el.classList && el.classList.contains('inflect-exception-visible')) return; } catch(e){}
  // If this element corresponds to a parent (has direct children), do not hide the parent
  try {
    const key = getKeyForElement(el);
    if (!show && key && getDirectChildrenKeys(key).length > 0) return;
  } catch(e){}
  const animate = !(opts && opts.animate === false);
  if (animate) {
    return animateLayerVisibility(el, show);
  } else {
    // immediate apply without animation
    if (show) {
      el.style.transition = '';
      el.style.opacity = '';
      el.style.display = '';
      el.style.visibility = '';
    } else {
      // If this is a parent (has children), don't remove it — children will be hidden individually.
      try {
        const key = getKeyForElement(el);
        if (key && getDirectChildrenKeys(key).length > 0) {
          // leave parent visible but non-interactive; children control visibility
          el.style.pointerEvents = 'none';
          // do not set opacity/display so children remain rendered
        } else {
          el.style.transition = '';
          el.style.opacity = '';
          el.style.display = 'none';
        }
      } catch(e) {
        el.style.display = 'none';
      }
    }
  }
}

// animate opacity for an element when showing/hiding
const __fadeCancels = new WeakMap();
function animateLayerVisibility(el, show, duration = FADE_DURATION){
  if (!el) return;
  // If this element maps to a parent node with direct children, do not animate it;
  // children will be animated individually. Avoid setting parent opacity which
  // would affect child rendering.
  try {
    const key = getKeyForElement(el);
    if (!show && key && getDirectChildrenKeys(key).length > 0) return Promise.resolve();
  } catch(e){}
  // if element is marked as an exception visible, don't animate hiding it or toggling
  if (el.classList && el.classList.contains('inflect-exception-visible')) {
    if (show) {
      // ensure visible immediately
      el.style.transition = '';
      el.style.opacity = '';
      el.style.display = '';
      el.style.visibility = '';
    } else {
      // do not hide exception-marked elements
      return Promise.resolve();
    }
  }
  return new Promise((resolve) => {
  // cancel previous transition if any
  const prevCancel = __fadeCancels.get(el);
  if (prevCancel) prevCancel();

  const computedDisplay = window.getComputedStyle(el).display;
  // show: ensure element is displayed and fade to opacity 1
  if (show) {
  // make element visible before starting fade. For SVG elements there may
  // be an explicit display="none" attribute; remove it and set an inline
  // CSS display so the element becomes visible.
  try { el.removeAttribute && el.removeAttribute('display'); } catch(e){}
  el.style.display = 'inline';
    el.style.visibility = '';
    // ensure starting opacity 0
    el.style.transition = 'none';
    el.style.opacity = '0';
    // force layout
    void el.getBoundingClientRect();
    // then transition to 1
    el.style.transition = `opacity ${duration}ms ease`; 
    let finished = false;
    const onEnd = (ev) => {
      if (ev && ev.propertyName !== 'opacity') return;
      if (finished) return;
      finished = true;
      el.removeEventListener('transitionend', onEnd);
      // cleanup
      el.style.transition = '';
      el.style.opacity = '';
      __fadeCancels.delete(el);
      resolve();
    };
    el.addEventListener('transitionend', onEnd);
    // start fade
    requestAnimationFrame(() => { el.style.opacity = '1'; });
    // store cancel function
    __fadeCancels.set(el, () => {
      if (!finished) { el.removeEventListener('transitionend', onEnd); finished = true; }
      __fadeCancels.delete(el);
      el.style.transition = '';
      el.style.opacity = '';
      resolve();
    });
    return;
  }

  // hide: fade to 0 then set display none
  el.style.transition = `opacity ${duration}ms ease`;
  // ensure starting opacity is 1
  if (!el.style.opacity) {
    // if no inline opacity, set to computed value or 1
    const comp = window.getComputedStyle(el).opacity;
    el.style.opacity = comp || '1';
  }
  let finished = false;
  const onEndHide = (ev) => {
    if (ev && ev.propertyName !== 'opacity') return;
    if (finished) return;
    finished = true;
    el.removeEventListener('transitionend', onEndHide);
    el.style.transition = '';
    el.style.opacity = '';
    // If this element is a parent with direct children, avoid removing it
    // from layout (display:none) because that would hide its children
    // momentarily. Instead keep it in the DOM but make it non-interactive.
    try {
      const key = getKeyForElement(el);
      if (key && getDirectChildrenKeys(key).length > 0) {
        el.style.pointerEvents = 'none';
        // ensure opacity remains 0
        try { el.style.opacity = '0'; } catch(e){}
  // avoid setting SVG display attribute; rely on inline styles only
      } else {
        el.style.display = 'none';
  // avoid setting SVG display attribute; rely on inline styles only
      }
    } catch(e) {
      el.style.display = 'none';
      try { el.setAttribute && el.setAttribute('display', 'none'); } catch(e){}
    }
    __fadeCancels.delete(el);
    resolve();
  };
  el.addEventListener('transitionend', onEndHide);
  // start fade out
  requestAnimationFrame(() => { el.style.opacity = '0'; });
  __fadeCancels.set(el, () => {
    if (!finished) { el.removeEventListener('transitionend', onEndHide); finished = true; }
    __fadeCancels.delete(el);
    el.style.transition = '';
    el.style.opacity = '';
    try {
      const key = getKeyForElement(el);
      if (key && getDirectChildrenKeys(key).length > 0) {
        el.style.pointerEvents = 'none';
        try { el.style.opacity = '0'; } catch(e){}
  // avoid setting SVG display attribute; rely on inline styles only
      } else {
        el.style.display = 'none';
  // avoid setting SVG display attribute; rely on inline styles only
      }
    } catch(e) {
      el.style.display = 'none';
      try { el.setAttribute && el.setAttribute('display', 'none'); } catch(e){}
    }
    resolve();
  });
  });
}

// apply vis object { show:[], hide:[] } to the SVG layers (matching by id/data-name/prefix)
function applyVisibilityFromVis(vis, opts){
  const animateGlobally = opts && opts.animate === true;
  if (!svgEl) return;
  // Resolve short vis tokens (like 'princess') against layerKeyMap by last-segment
  const rawHides = (vis && Array.isArray(vis.hide)) ? vis.hide.slice() : [];
  const rawShows = (vis && Array.isArray(vis.show)) ? vis.show.slice() : [];
  const resolveToken = (tok) => {
    if (!tok) return tok;
    if (String(tok).includes('/')) return tok;
    // find keys whose last segment matches tok
    const matches = [];
    for (const k of layerKeyMap.keys()){
      if (String(k).split('/').pop() === tok) matches.push(k);
    }
    return matches.length === 1 ? matches[0] : tok;
  };
  const hides = rawHides.map(resolveToken);
  const shows = rawShows.map(resolveToken);
  // Sync in-memory exceptions with parsed vis.show so parsed state wins
  showExceptions = new Set(shows);
  // Build sets for quick lookup
  const hideSet = new Set();
  const showSet = new Set();
  for (const h of hides) {
    for (const k of layerKeyMap.keys()){
      if (k === h || k.startsWith(h + '/')) hideSet.add(k);
    }
    // also hide the parent itself if it's a key
    if (layerKeyMap.has(h)) hideSet.add(h);
  }
  for (const s of shows) {
    for (const k of layerKeyMap.keys()){
      if (k === s || k.startsWith(s + '/')) showSet.add(k);
    }
    if (layerKeyMap.has(s)) showSet.add(s);
  }

  // detect parents that are hidden but have a shown descendant
  const parentsWithExceptions = new Set();
  for (const h of hides){
    for (const s of shows){
      if (s === h) continue;
      if (String(s).startsWith(String(h) + '/')) parentsWithExceptions.add(h);
    }
  }

  // Apply initial visibility: default visible unless hidden, but show parents that have exceptions
  for (const [key, el] of layerKeyMap.entries()){
    // If this key is a parent (has direct children), keep the parent element visible
    const directChildren = getDirectChildrenKeys(key);
    if (directChildren.length > 0) {
      // keep parent visible to avoid blinking; children will be hidden/shown instead
      toggleLayerVisibility(el, true, { animate: false });
      try { const cb = document.querySelector(`input[data-layer-key="${key}"]`); if (cb) cb.checked = true; } catch(e){}
      continue;
    }

    let visible = true;
    if (showExceptions.has(key) || showSet.has(key)) visible = true;
    else if (parentsWithExceptions.has(key)) visible = true;
    else if (hideSet.has(key)) visible = false;
    else visible = true;
    toggleLayerVisibility(el, visible, { animate: animateGlobally ? true : false });
    // update corresponding checkbox immediately if present
    try { const cb = document.querySelector(`input[data-layer-key="${key}"]`); if (cb) cb.checked = Boolean(visible); } catch(e){}
  }

  // For each parent with exceptions, hide its direct children except the ones explicitly shown
  parentsWithExceptions.forEach(parentKey => {
    const children = getDirectChildrenKeys(parentKey);
    children.forEach(childKey => {
      const childEl = layerKeyMap.get(childKey);
      if (!childEl) return;
      const vis = (showSet.has(childKey) || showExceptions.has(childKey));
      toggleLayerVisibility(childEl, vis, { animate: animateGlobally ? true : false });
      try { const cb = document.querySelector(`input[data-layer-key="${childKey}"]`); if (cb) cb.checked = Boolean(vis); } catch(e){}
    });
  });
  // finally refresh checkboxes to set disabled/indeterminate states
  refreshLayerListCheckboxes();
  // refresh checkboxes
  refreshLayerListCheckboxes();
}

function refreshLayerListCheckboxes(){
  const layerList = document.getElementById('layerList'); if (!layerList) return;
  // traverse labels and update checkboxes based on element's computed visibility
  const inputs = Array.from(layerList.querySelectorAll('input[type=checkbox]'));
  // build a map key -> input for ancestor lookups
  const inputMap = new Map();
  inputs.forEach(cb => { if (cb.dataset && cb.dataset.layerKey) inputMap.set(cb.dataset.layerKey, cb); });

  // first, set each checkbox to reflect the element's computed visibility and enable it
  inputs.forEach(cb => {
    const key = cb.dataset.layerKey;
    if (!key) return;
    const el = layerKeyMap.get(key);
    if (!el) return;
    // do not override cb.checked here — leave checked as the authoritative state (user or programmatic)
    cb.disabled = false;
  });

  // then, for each checkbox, if any ancestor parent checkbox exists and is unchecked,
  // mark this checkbox as checked and disabled to indicate it's controlled by the parent
  inputs.forEach(cb => {
    const key = cb.dataset.layerKey; if (!key) return;
    // walk up the key path
    const parts = key.split('/');
    for (let i = parts.length - 1; i > 0; i--) {
      const ancestorKey = parts.slice(0, i).join('/');
      const ancestorInput = inputMap.get(ancestorKey);
      if (ancestorInput) {
          if (!ancestorInput.checked) {
            // parent is unchecked -> child should appear checked but disabled immediately
            cb.checked = true;
            cb.disabled = true;
          }
          break; // stop at nearest ancestor found
        }
    }
  });

  // now compute indeterminate state for parents: if a parent has some direct children
  // that are shown as exceptions (or mixed), mark the parent.indeterminate = true
  for (const [key, ancestorInput] of inputMap.entries()){
    const children = getDirectChildrenKeys(key);
    if (!children.length) { ancestorInput.indeterminate = false; continue; }
    let exceptions = 0, visible = 0, hidden = 0;
    children.forEach(childKey => {
      const cb = inputMap.get(childKey);
      if (!cb) return;
      if (cb.disabled && showExceptions.has(childKey)) exceptions++;
      if (cb.checked) visible++; else hidden++;
    });
    // parent is indeterminate if some children are exceptions or mixed visibility
    ancestorInput.indeterminate = (exceptions>0) || (visible>0 && hidden>0);
  }
}

function findElementByLabel(name){
  // prefer layerKeyMap lookup
  if (layerKeyMap.has(name)) return layerKeyMap.get(name);
  // fallback: prefix match
  for (const [k, el] of layerKeyMap.entries()){
    if (k === name || k.startsWith(name)) return el;
  }
  return null;
}

function collectVisibilityFromList(){
  const layerList = document.getElementById('layerList'); if (!layerList) return { show:[], hide:[] };
  // Hide-only: collect only the keys that are currently unchecked (i.e., hidden)
  const res = { hide: [], show: [] };
  const inputs = Array.from(layerList.querySelectorAll('input[type=checkbox]'));
  inputs.forEach(cb => {
    const key = cb.dataset.layerKey; if (!key) return;
    if (!cb.checked) res.hide.push(key);
  });
  // include explicit exceptions
  for (const k of showExceptions) res.show.push(k);
  return res;
}

function updateHashFromLayerList(){
  // read existing parsed hash to preserve params
  const parsed = parseHash();
  const vis = collectVisibilityFromList();
  const token = buildUrlField(parsed.url, parsed.params, vis);
  // we need to preserve original 6-field style when present; if not, just write #token
  // Debounce writing the hash so ongoing animations are not cancelled by an
  // immediate hashchange handler. We still mark the write as originating
  // locally so the next hashchange is ignored.
  try { if (__hashWriteTimeout) clearTimeout(__hashWriteTimeout); } catch(e){}
  __hashWriteTimeout = setTimeout(() => {
    try { window.__suppressHashChangeApply = true; } catch(e){}
    if (!location.hash || !location.hash.includes('&')) {
      location.hash = '#'+token;
    } else {
      const parts = location.hash.slice(1).split('&');
      while (parts.length < 6) parts.push('');
      parts[4] = token;
      location.hash = '#'+parts.join('&');
    }
    __hashWriteTimeout = null;
  }, 260);
}

function dumpDiagnostics(){
  const diag = document.getElementById('diagPanel'); if (!diag) return;
  const parsed = parseHash();
  const lines = [];
  lines.push('location.hash: ' + location.hash);
  lines.push('parsed: ' + JSON.stringify(parsed));
  lines.push('pendingVis: ' + JSON.stringify(pendingVis));
  lines.push('layerKeyMap keys:');
  for (const k of layerKeyMap.keys()) lines.push('  - ' + k);
  // checkbox states
  const layerList = document.getElementById('layerList');
  if (layerList){
    const inputs = Array.from(layerList.querySelectorAll('input[type=checkbox]'));
    inputs.forEach(cb => { lines.push(`cb ${cb.dataset.layerKey} => ${cb.checked}`); });
  }
  diag.textContent = lines.join('\n');
}

document.addEventListener('DOMContentLoaded', ()=>{
  const dt = document.getElementById('diagToggle');
  const dp = document.getElementById('diagPanel');
  if (dt && dp){
    dt.addEventListener('click', ()=>{
      dp.style.display = dp.style.display === 'none' ? 'block' : 'none';
      if (dp.style.display === 'block') dumpDiagnostics();
    });
  }
});

function fitToContainer(){
  if (!svgEl || !bbox) return;
  const containerRect = svgContainer.getBoundingClientRect();
  const cw = containerRect.width || window.innerWidth;
  const ch = containerRect.height || window.innerHeight;
  // compute scale to fit bbox inside container
  const sx = cw / bbox.width; const sy = ch / bbox.height;
  const s = Math.min(sx, sy) * 0.9; // leave margins
  state.scale = s || 1;
  // center in pixel coordinates: desired center point in container
  const cx = bbox.x + bbox.width/2;
  const cy = bbox.y + bbox.height/2;
  // compute tx/ty so that scaled svg's center maps to container center
  state.tx = (cw/2) - cx * state.scale;
  state.ty = (ch/2) - cy * state.scale;
}

function render(){
  if (!svgEl || !bbox) return;
  // We'll compute a CSS transform that applies translate(tx,ty) in pixels,
  // then scale around the top-left (we set transform-origin to 0 0 on load),
  // and then rotate around the center of the bbox by translating to center,
  // rotating, and translating back.
  const cx = bbox.x + bbox.width/2;
  const cy = bbox.y + bbox.height/2;
  // rotation around center: translate(cx,cy) rotate(...) translate(-cx,-cy)
  const translatePart = `translate(${Math.round(state.tx)}px, ${Math.round(state.ty)}px)`;
  const scalePart = `scale(${state.scale})`;
  const rotatePart = `translate(${cx}px, ${cy}px) rotate(${state.rotation}deg) translate(${-cx}px, ${-cy}px)`;
  // Compose: translate (pixel pan) -> translate to center & rotate -> scale
  svgEl.style.transform = `${translatePart} ${rotatePart} ${scalePart}`;
}

// simple tweening helper for numeric state transitions
let __svg_tween_cancel = null;
function tweenProps(from, to, duration = 400, onUpdate){
  if (__svg_tween_cancel) __svg_tween_cancel();
  const start = performance.now();
  const keys = Object.keys(to);
  let rafId = null;
  let cancelled = false;
  function step(now){
    const t = Math.min(1, (now - start) / duration);
    // ease in-out cubic
    const eased = t<0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2;
    const cur = {};
    keys.forEach(k => {
      const a = typeof from[k]==='number' ? from[k] : 0;
      const b = typeof to[k]==='number' ? to[k] : a;
      cur[k] = a + (b - a) * eased;
    });
    try { onUpdate(cur); } catch(e){}
    if (t < 1 && !cancelled) rafId = requestAnimationFrame(step);
    else {
      // final commit
      try { onUpdate(Object.assign({}, to)); } catch(e){}
      __svg_tween_cancel = null;
    }
  }
  rafId = requestAnimationFrame(step);
  __svg_tween_cancel = () => { cancelled = true; if (rafId) cancelAnimationFrame(rafId); __svg_tween_cancel = null; };
  return __svg_tween_cancel;
}

// animate to target params (s, x, y, r)
function animateTo(params, duration = 450){
  if (!params) return Promise.resolve();
  const target = {
    scale: typeof params.s === 'number' ? params.s : state.scale,
    tx: typeof params.x === 'number' ? params.x : state.tx,
    ty: typeof params.y === 'number' ? params.y : state.ty,
    rotation: typeof params.r === 'number' ? params.r : state.rotation
  };
  return new Promise(resolve => {
    tweenProps({ scale: state.scale, tx: state.tx, ty: state.ty, rotation: state.rotation },
               { scale: target.scale, tx: target.tx, ty: target.ty, rotation: target.rotation },
               duration,
               (cur) => {
                 state.scale = cur.scale; state.tx = cur.tx; state.ty = cur.ty; state.rotation = cur.rotation;
                 // update UI controls during animation
                 try { rotateInput.value = Math.round(state.rotation); } catch(e){}
                 try { zoomInput.value = Math.round(state.scale*100); } catch(e){}
                 render();
               });
    // resolve after duration (plus tiny buffer)
    setTimeout(() => { resolve(); }, duration + 20);
  });
}

// interaction
svgContainer.addEventListener('mousedown', (e)=>{
  isDragging=true;
  dragStart=[e.clientX,e.clientY];
  // store current pixel tx/ty
  dragStartState={tx:state.tx,ty:state.ty};
  svgContainer.style.cursor='grabbing';
});
window.addEventListener('mouseup', ()=>{ if (isDragging){ isDragging=false; svgContainer.style.cursor=''; commitHash(); }});
window.addEventListener('mousemove', (e)=>{
  if (!isDragging) return;
  const dx = (e.clientX - dragStart[0]);
  const dy = (e.clientY - dragStart[1]);
  // dragStartState stored pixel tx/ty
  state.tx = dragStartState.tx + dx;
  state.ty = dragStartState.ty + dy;
  render();
});

// wheel zoom centered at mouse
svgContainer.addEventListener('wheel', (e)=>{
  e.preventDefault();
  const delta = -e.deltaY;
  const factor = delta>0?1.1:0.9;
  // compute mouse pos relative to svg container
  const rect = svgContainer.getBoundingClientRect();
  const mx = e.clientX - rect.left; const my = e.clientY - rect.top;
  // Compute SVG-space point under mouse before zoom: (svgX, svgY) = (mx - tx)/scale, (my - ty)/scale
  const beforeX = (mx - state.tx) / state.scale;
  const beforeY = (my - state.ty) / state.scale;
  // apply zoom
  const newScale = state.scale * factor;
  // after scale, compute new tx/ty so the before point maps to same screen position
  state.tx = mx - beforeX * newScale;
  state.ty = my - beforeY * newScale;
  state.scale = newScale;
  zoomInput.value = Math.round(state.scale*100);
  render();
});

rotateInput.addEventListener('input', ()=>{
  state.rotation = Number(rotateInput.value)||0;
  render();
});

zoomInput.addEventListener('input', ()=>{
  const newScale = Number(zoomInput.value)/100;
  if (!isNaN(newScale)) state.scale = newScale;
  render();
});

resetBtn.addEventListener('click', ()=>{
  fitToContainer(); state.rotation=0; rotateInput.value=0; zoomInput.value=Math.round(state.scale*100); render(); commitHash();
});

// Hash management: only write final state on interaction end or reset
let hashTimeout = null;
function commitHash(){
  const url = currentUrl || '';
  const rot = Math.round(state.rotation||0);
  const parsed = parseHash();
  const annotations = (parsed && parsed.annotations) ? parsed.annotations : { boxes:[], lines:[], color:'ff0000' };
  // Use same 6-field format: view&opacity&boxes&lines&url&rotation
  const viewParam = '';
  const opacity = 100;
  // Serialize params into url token
  function buildUrlToken(url, params) {
    let token = url || '';
    for (const k of Object.keys(params || {})) {
      token += `@${k}=${encodeURIComponent(String(params[k]))}`;
    }
    return token;
  }
  const params = { s: Math.round(state.scale*100)/100, x: Math.round(state.tx*100)/100, y: Math.round(state.ty*100)/100, r: rot };
  const token = buildUrlToken(url, params);
  const newHash = `${viewParam}&${opacity}&&&${token}&${rot}`;
  // write hash
  location.hash = newHash;
}

let currentUrl = '';

// When we write location.hash from a UI interaction, the browser fires a hashchange
// event which can re-apply visibility programmatically and cancel in-progress
// animations. Use this flag to skip the next hashchange apply when the change
// originated locally.
window.__suppressHashChangeApply = false;
// debounced hash write to avoid immediate reapplication during animations
let __hashWriteTimeout = null;

// Public: accept messy hrefs like parent does
window.acceptViewerHash = function(raw){
  try{
    if (!raw || typeof raw !== 'string') return false;
    const s = raw.trim();
    const ampIdx = s.indexOf('&&&');
    if (ampIdx !== -1) {
      const after = s.slice(ampIdx+3);
      const token = after.split('&')[0] || '';
      if (!token) return false;
      location.hash = '#&&&'+token;
      return true;
    }
  const urlMatch = s.match(/(https?:\/\/[^#\s]+|\/[^#\s]+|[^#\s]+\.svg)/i);
    if (urlMatch && urlMatch[0]){
      let url = urlMatch[0];
      try{ const u = new URL(url, location.origin); url = u.pathname + (u.search||''); } catch(e){}
      location.hash = '#'+url; return true;
    }
    return false;
  } catch(e){ return false; }
}

// Initial load (guarded startup to tolerate injected scripts that may throw)
function startViewer(){
  try {
    const parsed = parseHash();
    let url = parsed.url || '';
    // Only load if an explicit .svg filename is present in the hash
    if (!url || url.indexOf('.svg') === -1) {
      setStatus('waiting for #file.svg');
      window.viewerReady = false;
      return Promise.resolve();
    }
    currentUrl = url;
    // Apply params if present (scale/tx/ty/rotation) after load
    // queue visibility to apply after load if present
    if (parsed.vis) pendingVis = parsed.vis;
    return loadSVG(url).then(() => {
      try {
        if (parsed.params) {
              // animate into the requested params rather than snapping
              animateTo(parsed.params, 500).catch(()=>{});
            }
      } catch (e) {
        console.warn('Applying params failed', e);
      }
    }).catch(e => {
      console.warn('Initial load failed', e);
      pendingVis = null;
    });
  } catch (e) {
    console.warn('startViewer caught', e);
    return Promise.resolve();
  }
}

// Global non-fatal error handler: log but don't let injected scripts abort viewer startup
window.addEventListener('error', (ev) => {
  // Keep default behavior but ensure it's logged to console for tests
  try { console.warn('PAGE ERROR (non-fatal):', ev && ev.message ? ev.message : ev); } catch(e){}
  // do not call ev.preventDefault() so other handlers can run; we only avoid throwing here
});

// Kick off startup asynchronously (guarded)
setTimeout(() => { startViewer(); }, 0);

// respond to external hash changes
window.addEventListener('hashchange', ()=>{
  // If this hashchange was caused by our own UI write, skip re-applying
  // visibility/state to avoid cancelling user-initiated animations.
  if (window.__suppressHashChangeApply) { window.__suppressHashChangeApply = false; return; }
  const parsed = parseHash();
  if (!parsed) return;
  // if URL changed, load new svg immediately
  if (parsed.url && parsed.url !== currentUrl) {
    currentUrl = parsed.url;
    loadSVG(currentUrl);
    return;
  }
  // if same URL but params changed, animate to new params
    if (parsed.url === currentUrl) {
    if (parsed.params) animateTo(parsed.params, 400).catch(()=>{});
    if (parsed.vis) {
      if (!svgEl) { pendingVis = parsed.vis; }
      else { try { applyVisibilityFromVis(parsed.vis, { animate: true }); } catch(e){} }
    }
  }
});

window.viewerReady = false;
</script>
</body>
</html>
